# 1 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/propname.cpp"
# 1 "C:\\Users\\will\\Documents\\UtterSpeech\\marmalade\\icu\\common\\build_common_vc10//"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "C:/Users/will/Documents/UtterSpeech/marmalade/icu/common/build_common_vc10/temp_defines_debug.h" 1
# 1 "<command-line>" 2
# 1 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/propname.cpp"
# 12 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/propname.cpp"
# 1 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/propname.h" 1
# 15 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/propname.h"
# 1 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/utypes.h" 1
# 36 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/utypes.h"
# 1 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/umachine.h" 1
# 61 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/umachine.h"
# 1 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/ptypes.h" 1
# 23 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/ptypes.h"
# 1 "c:/marmalade/5.2/s3e/h/std/sys/types.h" 1
# 15 "c:/marmalade/5.2/s3e/h/std/sys/types.h"
# 1 "c:/marmalade/5.2/s3e/h/s3eTypes.h" 1
# 37 "c:/marmalade/5.2/s3e/h/s3eTypes.h"
typedef unsigned char s3e_uint8_t;
typedef signed char s3e_int8_t;
typedef unsigned short int s3e_uint16_t;
typedef signed short int s3e_int16_t;
typedef unsigned int s3e_uint32_t;
typedef signed int s3e_int32_t;
# 51 "c:/marmalade/5.2/s3e/h/s3eTypes.h"
  typedef signed long long s3e_int64_t;
  typedef unsigned long long s3e_uint64_t;
# 74 "c:/marmalade/5.2/s3e/h/s3eTypes.h"
typedef s3e_uint64_t uint64_t;
typedef s3e_int64_t int64_t;
typedef s3e_uint32_t uint32_t;
typedef s3e_int32_t int32_t;
typedef s3e_uint16_t uint16_t;
typedef s3e_int16_t int16_t;
typedef s3e_uint8_t uint8_t;
typedef s3e_int8_t int8_t;
# 96 "c:/marmalade/5.2/s3e/h/s3eTypes.h"
    typedef int intptr_t;
    typedef unsigned int uintptr_t;
# 108 "c:/marmalade/5.2/s3e/h/s3eTypes.h"
typedef unsigned int uint;
typedef unsigned short int ushort;
typedef unsigned long int ulong;
typedef unsigned char uint8;
typedef signed char int8;







typedef int64_t int64;
typedef uint64_t uint64;





typedef unsigned int uint32;






typedef signed int int32;






typedef uint16_t uint16;




typedef int16_t int16;
# 226 "c:/marmalade/5.2/s3e/h/s3eTypes.h"
typedef enum s3eResult
{
    S3E_RESULT_SUCCESS = 0,
    S3E_RESULT_ERROR = 1
} s3eResult;




typedef uint8 s3eBool;
# 244 "c:/marmalade/5.2/s3e/h/s3eTypes.h"
typedef wchar_t s3eWChar;
# 256 "c:/marmalade/5.2/s3e/h/s3eTypes.h"
typedef int32 (*s3eCallback) (void* systemData, void* userData);
# 16 "c:/marmalade/5.2/s3e/h/std/sys/types.h" 2
# 1 "c:/marmalade/5.2/s3e/h/std/stddef.h" 1
# 16 "c:/marmalade/5.2/s3e/h/std/stddef.h"
typedef signed int ptrdiff_t;


    typedef unsigned int wint_t;
    typedef unsigned long int wctype_t;







typedef unsigned int size_t;
# 17 "c:/marmalade/5.2/s3e/h/std/sys/types.h" 2
# 1 "c:/marmalade/5.2/s3e/h/std/stdint.h" 1
# 19 "c:/marmalade/5.2/s3e/h/std/stdint.h"
typedef signed char int_least8_t;
typedef short int_least16_t;
typedef long int_least32_t;
typedef int64_t int_least64_t;

typedef unsigned char uint_least8_t;
typedef unsigned short uint_least16_t;
typedef unsigned long uint_least32_t;
typedef uint64_t uint_least64_t;

typedef signed char int_fast8_t;
typedef short int_fast16_t;
typedef long int_fast32_t;
typedef int64_t int_fast64_t;

typedef unsigned char uint_fast8_t;
typedef unsigned short uint_fast16_t;
typedef unsigned long uint_fast32_t;
typedef uint64_t uint_fast64_t;

typedef int64_t intmax_t;
typedef uint64_t uintmax_t;
# 18 "c:/marmalade/5.2/s3e/h/std/sys/types.h" 2
# 1 "c:/marmalade/5.2/s3e/h/std/sys/select.h" 1
# 24 "c:/marmalade/5.2/s3e/h/std/sys/select.h"
struct timeval;

typedef struct fd_set
{
    char fds_bits[256/8];
} fd_set;
# 39 "c:/marmalade/5.2/s3e/h/std/sys/select.h"
extern "C" {

int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);

}
# 19 "c:/marmalade/5.2/s3e/h/std/sys/types.h" 2



typedef long off_t;

typedef int64_t off64_t;


namespace std
{
    typedef ::size_t size_t;
}


typedef uint u_int;
typedef uint8_t u_int8_t;
typedef uint16_t u_int16_t;
typedef uint32_t u_int32_t;
typedef uint64_t u_int64_t;

typedef unsigned short u_short;
typedef unsigned long u_long;
typedef unsigned char u_char;

typedef int ssize_t;
typedef int pid_t;
typedef short uid_t;
typedef short gid_t;
typedef int idtype_t;
typedef int id_t;
typedef uint32 mode_t;
typedef short dev_t;
typedef short ino_t;
typedef int key_t;
typedef void* caddr_t;
# 24 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/ptypes.h" 2

# 1 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/platform.h" 1
# 26 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/ptypes.h" 2
# 51 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/ptypes.h"
# 1 "c:/marmalade/5.2/s3e/h/std/inttypes.h" 1
# 17 "c:/marmalade/5.2/s3e/h/std/inttypes.h"
typedef struct
{
    long int quot;
    long int rem;
} imaxdiv_t;


extern "C" {

imaxdiv_t imaxdiv(intmax_t numerator, intmax_t denominator);

}
# 52 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/ptypes.h" 2
# 62 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/umachine.h" 2
# 231 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/umachine.h"
typedef int8_t UBool;
# 322 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/umachine.h"
    typedef wchar_t UChar;
# 349 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/umachine.h"
typedef int32_t UChar32;
# 386 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/umachine.h"
# 1 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/urename.h" 1
# 35 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/urename.h"
# 1 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/umachine.h" 1
# 36 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/urename.h" 2




# 1 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uvernum.h" 1
# 41 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/urename.h" 2
# 387 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/umachine.h" 2
# 37 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/utypes.h" 2
# 1 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/utf.h" 1
# 111 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/utf.h"
# 1 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/utypes.h" 1
# 112 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/utf.h" 2
# 230 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/utf.h"
# 1 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/utf8.h" 1
# 58 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/utf8.h"
extern "C" const uint8_t



utf8_countTrailBytes_48[256];
# 91 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/utf8.h"
extern "C" UChar32
utf8_nextCharSafeBody_48(const uint8_t *s, int32_t *pi, int32_t length, UChar32 c, UBool strict);
# 103 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/utf8.h"
extern "C" int32_t
utf8_appendCharSafeBody_48(uint8_t *s, int32_t i, int32_t length, UChar32 c, UBool *pIsError);
# 115 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/utf8.h"
extern "C" UChar32
utf8_prevCharSafeBody_48(const uint8_t *s, int32_t start, int32_t *pi, UChar32 c, UBool strict);
# 127 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/utf8.h"
extern "C" int32_t
utf8_back1SafeBody_48(const uint8_t *s, int32_t start, int32_t i);
# 231 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/utf.h" 2
# 1 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/utf16.h" 1
# 232 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/utf.h" 2


# 1 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/utf_old.h" 1
# 235 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/utf.h" 2
# 38 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/utypes.h" 2
# 1 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uversion.h" 1
# 57 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uversion.h"
typedef uint8_t UVersionInfo[4];
# 109 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uversion.h"
        namespace icu_48 { }
        namespace icu = icu_48;
# 122 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uversion.h"
        using namespace icu_48;
# 152 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uversion.h"
extern "C" void
u_versionFromString_48(UVersionInfo versionArray, const char *versionString);
# 166 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uversion.h"
extern "C" void
u_versionFromUString_48(UVersionInfo versionArray, const UChar *versionString);
# 182 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uversion.h"
extern "C" void
u_versionToString_48(UVersionInfo versionArray, char *versionString);
# 193 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uversion.h"
extern "C" void
u_getVersion_48(UVersionInfo versionArray);
# 39 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/utypes.h" 2
# 1 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uconfig.h" 1
# 40 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/utypes.h" 2
# 1 "c:/marmalade/5.2/s3e/h/std/float.h" 1
# 31 "c:/marmalade/5.2/s3e/h/std/float.h"
  extern "C" {
# 109 "c:/marmalade/5.2/s3e/h/std/float.h"
extern "C" {

unsigned _controlfp(unsigned, unsigned);
unsigned _clearfp(void);
unsigned _statusfp(void);

}
# 150 "c:/marmalade/5.2/s3e/h/std/float.h"
    }
# 41 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/utypes.h" 2
# 314 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/utypes.h"
typedef double UDate;
# 385 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/utypes.h"
typedef void* UClassID;
# 639 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/utypes.h"
typedef enum UErrorCode {





    U_USING_FALLBACK_WARNING = -128,

    U_ERROR_WARNING_START = -128,

    U_USING_DEFAULT_WARNING = -127,

    U_SAFECLONE_ALLOCATED_WARNING = -126,

    U_STATE_OLD_WARNING = -125,

    U_STRING_NOT_TERMINATED_WARNING = -124,

    U_SORT_KEY_TOO_SHORT_WARNING = -123,

    U_AMBIGUOUS_ALIAS_WARNING = -122,

    U_DIFFERENT_UCA_VERSION = -121,

    U_PLUGIN_CHANGED_LEVEL_WARNING = -120,

    U_ERROR_WARNING_LIMIT,


    U_ZERO_ERROR = 0,

    U_ILLEGAL_ARGUMENT_ERROR = 1,
    U_MISSING_RESOURCE_ERROR = 2,
    U_INVALID_FORMAT_ERROR = 3,
    U_FILE_ACCESS_ERROR = 4,
    U_INTERNAL_PROGRAM_ERROR = 5,
    U_MESSAGE_PARSE_ERROR = 6,
    U_MEMORY_ALLOCATION_ERROR = 7,
    U_INDEX_OUTOFBOUNDS_ERROR = 8,
    U_PARSE_ERROR = 9,
    U_INVALID_CHAR_FOUND = 10,
    U_TRUNCATED_CHAR_FOUND = 11,
    U_ILLEGAL_CHAR_FOUND = 12,
    U_INVALID_TABLE_FORMAT = 13,
    U_INVALID_TABLE_FILE = 14,
    U_BUFFER_OVERFLOW_ERROR = 15,
    U_UNSUPPORTED_ERROR = 16,
    U_RESOURCE_TYPE_MISMATCH = 17,
    U_ILLEGAL_ESCAPE_SEQUENCE = 18,
    U_UNSUPPORTED_ESCAPE_SEQUENCE = 19,
    U_NO_SPACE_AVAILABLE = 20,
    U_CE_NOT_FOUND_ERROR = 21,
    U_PRIMARY_TOO_LONG_ERROR = 22,
    U_STATE_TOO_OLD_ERROR = 23,
    U_TOO_MANY_ALIASES_ERROR = 24,

    U_ENUM_OUT_OF_SYNC_ERROR = 25,
    U_INVARIANT_CONVERSION_ERROR = 26,
    U_INVALID_STATE_ERROR = 27,
    U_COLLATOR_VERSION_MISMATCH = 28,
    U_USELESS_COLLATOR_ERROR = 29,
    U_NO_WRITE_PERMISSION = 30,

    U_STANDARD_ERROR_LIMIT,



    U_BAD_VARIABLE_DEFINITION=0x10000,
    U_PARSE_ERROR_START = 0x10000,
    U_MALFORMED_RULE,
    U_MALFORMED_SET,
    U_MALFORMED_SYMBOL_REFERENCE,
    U_MALFORMED_UNICODE_ESCAPE,
    U_MALFORMED_VARIABLE_DEFINITION,
    U_MALFORMED_VARIABLE_REFERENCE,
    U_MISMATCHED_SEGMENT_DELIMITERS,
    U_MISPLACED_ANCHOR_START,
    U_MISPLACED_CURSOR_OFFSET,
    U_MISPLACED_QUANTIFIER,
    U_MISSING_OPERATOR,
    U_MISSING_SEGMENT_CLOSE,
    U_MULTIPLE_ANTE_CONTEXTS,
    U_MULTIPLE_CURSORS,
    U_MULTIPLE_POST_CONTEXTS,
    U_TRAILING_BACKSLASH,
    U_UNDEFINED_SEGMENT_REFERENCE,
    U_UNDEFINED_VARIABLE,
    U_UNQUOTED_SPECIAL,
    U_UNTERMINATED_QUOTE,
    U_RULE_MASK_ERROR,
    U_MISPLACED_COMPOUND_FILTER,
    U_MULTIPLE_COMPOUND_FILTERS,
    U_INVALID_RBT_SYNTAX,
    U_INVALID_PROPERTY_PATTERN,
    U_MALFORMED_PRAGMA,
    U_UNCLOSED_SEGMENT,
    U_ILLEGAL_CHAR_IN_SEGMENT,
    U_VARIABLE_RANGE_EXHAUSTED,
    U_VARIABLE_RANGE_OVERLAP,
    U_ILLEGAL_CHARACTER,
    U_INTERNAL_TRANSLITERATOR_ERROR,
    U_INVALID_ID,
    U_INVALID_FUNCTION,
    U_PARSE_ERROR_LIMIT,




    U_UNEXPECTED_TOKEN=0x10100,
    U_FMT_PARSE_ERROR_START=0x10100,
    U_MULTIPLE_DECIMAL_SEPARATORS,
    U_MULTIPLE_DECIMAL_SEPERATORS = U_MULTIPLE_DECIMAL_SEPARATORS,
    U_MULTIPLE_EXPONENTIAL_SYMBOLS,
    U_MALFORMED_EXPONENTIAL_PATTERN,
    U_MULTIPLE_PERCENT_SYMBOLS,
    U_MULTIPLE_PERMILL_SYMBOLS,
    U_MULTIPLE_PAD_SPECIFIERS,
    U_PATTERN_SYNTAX_ERROR,
    U_ILLEGAL_PAD_POSITION,
    U_UNMATCHED_BRACES,
    U_UNSUPPORTED_PROPERTY,
    U_UNSUPPORTED_ATTRIBUTE,
    U_ARGUMENT_TYPE_MISMATCH,
    U_DUPLICATE_KEYWORD,
    U_UNDEFINED_KEYWORD,
    U_DEFAULT_KEYWORD_MISSING,
    U_DECIMAL_NUMBER_SYNTAX_ERROR,
    U_FORMAT_INEXACT_ERROR,
    U_FMT_PARSE_ERROR_LIMIT,




    U_BRK_INTERNAL_ERROR=0x10200,
    U_BRK_ERROR_START=0x10200,
    U_BRK_HEX_DIGITS_EXPECTED,
    U_BRK_SEMICOLON_EXPECTED,
    U_BRK_RULE_SYNTAX,
    U_BRK_UNCLOSED_SET,
    U_BRK_ASSIGN_ERROR,
    U_BRK_VARIABLE_REDFINITION,
    U_BRK_MISMATCHED_PAREN,
    U_BRK_NEW_LINE_IN_QUOTED_STRING,
    U_BRK_UNDEFINED_VARIABLE,
    U_BRK_INIT_ERROR,
    U_BRK_RULE_EMPTY_SET,
    U_BRK_UNRECOGNIZED_OPTION,
    U_BRK_MALFORMED_RULE_TAG,
    U_BRK_ERROR_LIMIT,




    U_REGEX_INTERNAL_ERROR=0x10300,
    U_REGEX_ERROR_START=0x10300,
    U_REGEX_RULE_SYNTAX,
    U_REGEX_INVALID_STATE,
    U_REGEX_BAD_ESCAPE_SEQUENCE,
    U_REGEX_PROPERTY_SYNTAX,
    U_REGEX_UNIMPLEMENTED,
    U_REGEX_MISMATCHED_PAREN,
    U_REGEX_NUMBER_TOO_BIG,
    U_REGEX_BAD_INTERVAL,
    U_REGEX_MAX_LT_MIN,
    U_REGEX_INVALID_BACK_REF,
    U_REGEX_INVALID_FLAG,
    U_REGEX_LOOK_BEHIND_LIMIT,
    U_REGEX_SET_CONTAINS_STRING,
    U_REGEX_OCTAL_TOO_BIG,
    U_REGEX_MISSING_CLOSE_BRACKET,
    U_REGEX_INVALID_RANGE,
    U_REGEX_STACK_OVERFLOW,
    U_REGEX_TIME_OUT,
    U_REGEX_STOPPED_BY_CALLER,
    U_REGEX_ERROR_LIMIT,




    U_IDNA_PROHIBITED_ERROR=0x10400,
    U_IDNA_ERROR_START=0x10400,
    U_IDNA_UNASSIGNED_ERROR,
    U_IDNA_CHECK_BIDI_ERROR,
    U_IDNA_STD3_ASCII_RULES_ERROR,
    U_IDNA_ACE_PREFIX_ERROR,
    U_IDNA_VERIFICATION_ERROR,
    U_IDNA_LABEL_TOO_LONG_ERROR,
    U_IDNA_ZERO_LENGTH_LABEL_ERROR,
    U_IDNA_DOMAIN_NAME_TOO_LONG_ERROR,
    U_IDNA_ERROR_LIMIT,



    U_STRINGPREP_PROHIBITED_ERROR = U_IDNA_PROHIBITED_ERROR,
    U_STRINGPREP_UNASSIGNED_ERROR = U_IDNA_UNASSIGNED_ERROR,
    U_STRINGPREP_CHECK_BIDI_ERROR = U_IDNA_CHECK_BIDI_ERROR,




    U_PLUGIN_ERROR_START=0x10500,
    U_PLUGIN_TOO_HIGH=0x10500,
    U_PLUGIN_DIDNT_SET_LEVEL,
    U_PLUGIN_ERROR_LIMIT,

    U_ERROR_LIMIT=U_PLUGIN_ERROR_LIMIT
} UErrorCode;
# 855 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/utypes.h"
    static
    inline UBool U_SUCCESS(UErrorCode code) { return (UBool)(code<=U_ZERO_ERROR); }




    static
    inline UBool U_FAILURE(UErrorCode code) { return (UBool)(code>U_ZERO_ERROR); }
# 882 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/utypes.h"
extern "C" const char *
u_errorName_48(UErrorCode code);
# 16 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/propname.h" 2
# 1 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/bytestrie.h" 1
# 24 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/bytestrie.h"
# 1 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/stringpiece.h" 1
# 29 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/stringpiece.h"
# 1 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uobject.h" 1
# 22 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uobject.h"
extern "C++" { namespace icu_48 {
# 101 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uobject.h"
class UMemory {
public:
# 120 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uobject.h"
    static void * operator new(size_t size) throw();






    static void * operator new[](size_t size) throw();
# 137 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uobject.h"
    static void operator delete(void *p) throw();






    static void operator delete[](void *p) throw();







    static inline void * operator new(size_t, void *ptr) throw() { return ptr; }






    static inline void operator delete(void *, void *) throw() {}
# 191 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uobject.h"
};
# 215 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uobject.h"
class UObject : public UMemory {
public:





    virtual ~UObject();






    virtual UClassID getDynamicClassID() const = 0;

protected:
# 288 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uobject.h"
};
# 350 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uobject.h"
} }
# 30 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/stringpiece.h" 2
# 1 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/std_string.h" 1
# 39 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/std_string.h"
# 1 "c:/marmalade/5.2/s3e/h/std/c++/string" 1
# 24 "c:/marmalade/5.2/s3e/h/std/c++/string"
# 1 "c:/marmalade/5.2/s3e/h/std/c++/stl/_prolog.h" 1
# 10 "c:/marmalade/5.2/s3e/h/std/c++/stl/_prolog.h"
# 1 "c:/marmalade/5.2/s3e/h/std/c++/stl/_config.h" 1
# 62 "c:/marmalade/5.2/s3e/h/std/c++/stl/_config.h"
# 1 "c:/marmalade/5.2/s3e/h/std/c++/stl_user_config.h" 1
# 63 "c:/marmalade/5.2/s3e/h/std/c++/stl/_config.h" 2




# 1 "c:/marmalade/5.2/s3e/h/std/c++/stl/_config_compat.h" 1
# 68 "c:/marmalade/5.2/s3e/h/std/c++/stl/_config.h" 2



# 1 "c:/marmalade/5.2/s3e/h/std/c++/stl/_site_config.h" 1
# 72 "c:/marmalade/5.2/s3e/h/std/c++/stl/_config.h" 2


# 1 "c:/marmalade/5.2/s3e/h/std/c++/config/stlcomp.h" 1
# 54 "c:/marmalade/5.2/s3e/h/std/c++/config/stlcomp.h"
# 1 "c:/marmalade/5.2/s3e/h/std/c++/config/stl_gcc_s3e.h" 1
# 67 "c:/marmalade/5.2/s3e/h/std/c++/config/stl_gcc_s3e.h"
     typedef char __stl_char;
# 55 "c:/marmalade/5.2/s3e/h/std/c++/config/stlcomp.h" 2
# 75 "c:/marmalade/5.2/s3e/h/std/c++/stl/_config.h" 2
# 83 "c:/marmalade/5.2/s3e/h/std/c++/stl/_config.h"
# 1 "c:/marmalade/5.2/s3e/h/std/c++/config/stl_confix.h" 1
# 84 "c:/marmalade/5.2/s3e/h/std/c++/stl/_config.h" 2
# 488 "c:/marmalade/5.2/s3e/h/std/c++/stl/_config.h"
namespace std { }
namespace __std_alias = std;
# 546 "c:/marmalade/5.2/s3e/h/std/c++/stl/_config.h"
namespace _STL { }

namespace stlport = _STL;
# 11 "c:/marmalade/5.2/s3e/h/std/c++/stl/_prolog.h" 2





# 1 "c:/marmalade/5.2/s3e/h/std/c++/config/_prolog.h" 1
# 17 "c:/marmalade/5.2/s3e/h/std/c++/stl/_prolog.h" 2
# 25 "c:/marmalade/5.2/s3e/h/std/c++/string" 2



         
# 45 "c:/marmalade/5.2/s3e/h/std/c++/string"
# 1 "c:/marmalade/5.2/s3e/h/std/c++/stl/_string.h" 1
# 23 "c:/marmalade/5.2/s3e/h/std/c++/stl/_string.h"
# 1 "c:/marmalade/5.2/s3e/h/std/c++/memory" 1
# 28 "c:/marmalade/5.2/s3e/h/std/c++/memory"
         



# 1 "c:/marmalade/5.2/s3e/h/std/c++/stl/_alloc.h" 1
# 31 "c:/marmalade/5.2/s3e/h/std/c++/stl/_alloc.h"
# 1 "c:/marmalade/5.2/s3e/h/std/c++/cstddef" 1
# 37 "c:/marmalade/5.2/s3e/h/std/c++/cstddef"
# 1 "c:/marmalade/5.2/s3e/h/ext/../std/stddef.h" 1
# 38 "c:/marmalade/5.2/s3e/h/std/c++/cstddef" 2



namespace _STL {
using ::ptrdiff_t;
using ::size_t;
}
# 32 "c:/marmalade/5.2/s3e/h/std/c++/stl/_alloc.h" 2







# 1 "c:/marmalade/5.2/s3e/h/std/c++/cstdlib" 1
# 27 "c:/marmalade/5.2/s3e/h/std/c++/cstdlib"
# 1 "c:/marmalade/5.2/s3e/h/ext/../std/stdlib.h" 1
# 16 "c:/marmalade/5.2/s3e/h/ext/../std/stdlib.h"
# 1 "c:/marmalade/5.2/s3e/h/std/malloc.h" 1
# 16 "c:/marmalade/5.2/s3e/h/std/malloc.h"
# 1 "c:/marmalade/5.2/s3e/h/std/alloca.h" 1
# 17 "c:/marmalade/5.2/s3e/h/std/alloca.h"
extern "C" {


    extern void *alloca(size_t __size);
# 35 "c:/marmalade/5.2/s3e/h/std/alloca.h"
}
# 17 "c:/marmalade/5.2/s3e/h/std/malloc.h" 2

extern "C" {

void *calloc(size_t nmemb, size_t size);
void *malloc(size_t size);
void free(void *ptr);
void *realloc(void *ptr, size_t size);

}
# 17 "c:/marmalade/5.2/s3e/h/ext/../std/stdlib.h" 2
# 28 "c:/marmalade/5.2/s3e/h/ext/../std/stdlib.h"
extern "C" {

double atof(const char* string);
int atoi(const char *nptr);
long atol(const char *nptr);
int64_t atoll(const char *nptr);
int64_t atoq(const char *nptr);
int abs(int j);
long int labs(long int j);
int64_t llabs(int64_t j);
void qsort(void *base, size_t nmemb, size_t size, int(*compar)(const void *, const void *));
void *bsearch(const void *key, const void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));
void abort(void);
int putenv(char *string);
char *getenv(const char *name);
int setenv(const char *name, const char *value, int overwrite);
int unsetenv(const char *name);
void exit(int status) __attribute__ ((noreturn));
void _exit(int status) __attribute__ ((noreturn));
void _Exit(int status) __attribute__ ((noreturn));
unsigned long int strtoul(const char *nptr, char **endptr, int base);
uint64_t strtoull(const char *nptr, char **endptr, int base);
long int strtol(const char *nptr, char **endptr, int base);
int64_t strtoll(const char *nptr, char **endptr, int base);
double strtod(const char *nptr, char **endptr);
float strtof(const char *nptr, char **endptr);
long double strtold(const char *nptr, char **endptr);
int atexit(void (*function)(void));
int system(const char *command);
int posix_memalign(void **memptr, size_t alignment, size_t size);
char *mktemp(char *templ);
int mkstemp(char *templ);



int rand(void);
void srand(unsigned int seed);

long int random(void);
void srandom(unsigned int seed);

size_t __ctype_get_mb_cur_max();


int mblen(const char *s, size_t n);
int mbtowc(wchar_t *pwc, const char *s, size_t n);
int wctomb(char *s, wchar_t wc);
size_t mbstowcs(wchar_t *dest, const char *src, size_t n);
size_t wcstombs(char *dest, const wchar_t *src, size_t n);

typedef struct
{
    int quot;
    int rem;
} div_t;

typedef struct
{
    int quot;
    int rem;
} ldiv_t;

typedef struct
{
    int64_t quot;
    int64_t rem;
} lldiv_t;

div_t div(int numerator, int denominator);
ldiv_t ldiv(long numerator, long denominator);
lldiv_t lldiv(int64_t numerator, int64_t denominator);
# 112 "c:/marmalade/5.2/s3e/h/ext/../std/stdlib.h"
}
# 28 "c:/marmalade/5.2/s3e/h/std/c++/cstdlib" 2
# 41 "c:/marmalade/5.2/s3e/h/std/c++/cstdlib"
namespace _STL {
using ::div_t;
using ::ldiv_t;
using ::size_t;


using ::abort;
using ::atexit;
using ::exit;
using ::getenv;
using ::calloc;
using ::free;
using ::malloc;
using ::realloc;
using ::atof;
using ::atoi;
using ::atol;
using ::mblen;
using ::mbstowcs;
using ::mbtowc;
using ::strtod;
using ::strtol;
using ::strtoul;
using ::system;


using ::wcstombs;
using ::wctomb;

using ::bsearch;
using ::qsort;




using ::div;
using ::labs;
using ::ldiv;
using ::rand;
using ::srand;

}


namespace _STL {



inline long abs(long __x) { return ::labs(__x); }


inline ldiv_t div(long __x, long __y) { return ::ldiv(__x, __y); }
# 103 "c:/marmalade/5.2/s3e/h/std/c++/cstdlib"
}
# 40 "c:/marmalade/5.2/s3e/h/std/c++/stl/_alloc.h" 2


# 1 "c:/marmalade/5.2/s3e/h/std/c++/cstring" 1
# 27 "c:/marmalade/5.2/s3e/h/std/c++/cstring"
# 1 "c:/marmalade/5.2/s3e/h/ext/../std/string.h" 1
# 17 "c:/marmalade/5.2/s3e/h/ext/../std/string.h"
extern "C" {

void *memcpy(void *dest, const void *src, size_t n);
void *memset(void *s, int c, size_t n);
int memcmp(const void *s1, const void *s2, size_t n);
void *memmove(void *dest, const void *src, size_t n);
void *memchr(const void *s, int c, size_t n);
void *memrchr(const void *s, int c, size_t n);







int strcmp(const char *s1, const char *s2);
int strncmp(const char *s1, const char *s2, size_t n);
char *strsep(char **stringp, const char *delim);
char *strcpy(char *dest, const char *src);
char *strncpy(char *dest, const char *src, size_t n);
char *strchr(const char *s, int c);
char *strstr(const char *haystack, const char *needle);
char *strrchr(const char *s, int c);
char *strdup(const char *s);
char *strtok(char *str, const char *delim);
char *strtok_r(char *str, const char *delim, char **saveptr);
char *strcat(char *dest, const char *src);
char *strncat(char *dest, const char *src, size_t n);
size_t strlen(const char *s);
size_t strnlen(const char *s, size_t n);
int strcasecmp(const char *s1, const char *s2);
int strncasecmp(const char *s1, const char *s2, size_t n);
size_t strspn(const char *s, const char *accept);
size_t strcspn(const char *s, const char *reject);
char *strpbrk(const char *s, const char *accept);
int strcoll(const char *s1, const char *s2);
char *strerror(int errnum);
size_t strxfrm(char *dest, const char *src, size_t n);

int strerror_r(int errnum, char *buf, size_t buflen);





size_t strlcpy(char* dest, const char* src, size_t len);
size_t strlcat(char* dest, const char* src, size_t len);

}
# 28 "c:/marmalade/5.2/s3e/h/std/c++/cstring" 2



namespace _STL {
# 1 "c:/marmalade/5.2/s3e/h/std/c++/using/cstring" 1
using ::size_t;
# 17 "c:/marmalade/5.2/s3e/h/std/c++/using/cstring"
 using ::memmove;
 using ::memcpy;




using ::memchr;
using ::strchr;
using ::strpbrk;
using ::strrchr;
using ::strstr;


using ::memcmp;
using ::memset;

using ::strcat;


using ::strcmp;


using ::strcoll;

using ::strcpy;

using ::strcspn;
using ::strerror;
using ::strlen;
using ::strncat;
using ::strncmp;

using ::strncpy;
using ::strspn;

using ::strtok;
using ::strxfrm;
# 33 "c:/marmalade/5.2/s3e/h/std/c++/cstring" 2
}
# 43 "c:/marmalade/5.2/s3e/h/std/c++/stl/_alloc.h" 2





# 1 "c:/marmalade/5.2/s3e/h/std/c++/cstdio" 1
# 35 "c:/marmalade/5.2/s3e/h/std/c++/cstdio"
# 1 "c:/marmalade/5.2/s3e/h/ext/../std/stdio.h" 1
# 19 "c:/marmalade/5.2/s3e/h/ext/../std/stdio.h"
struct __XXFILE;
typedef struct __XXFILE FILE;

typedef uint32 fpos_t;
# 38 "c:/marmalade/5.2/s3e/h/ext/../std/stdio.h"
extern "C" {



struct _reent
{
  int _errno;
  void *_stdin, *_stdout, *_stderr;
};
extern struct _reent *_impure_ptr;
# 66 "c:/marmalade/5.2/s3e/h/ext/../std/stdio.h"
FILE *fopen(const char *path, const char *mode);
int fclose(FILE *fp);
int fcloseall();
int fflush(FILE *stream);

FILE *fopen(const char *path, const char *mode);
FILE *fdopen(int fildes, const char *mode);
FILE *freopen(const char *path, const char *mode, FILE *stream);

size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);

int fputc(int c, FILE *stream);
int fputs(const char *s, FILE *stream);
int putc(int c, FILE *stream);
int putchar(int c);
int puts(const char *s);

int fgetc(FILE *stream);
char *fgets(char *s, int size, FILE *stream);
int getc(FILE *stream);
int getchar(void);
char *gets(char *s);
int ungetc(int c, FILE *stream);

int fseek(FILE *stream, long offset, int whence);
long ftell(FILE *stream);
void rewind(FILE *stream);
int fgetpos(FILE *stream, fpos_t *pos);
int fsetpos(FILE *stream, fpos_t *pos);

void flockfile(FILE *filehandle);
int ftrylockfile(FILE *filehandle);
void funlockfile(FILE *filehandle);

int getc_unlocked(FILE *stream);
int getchar_unlocked(void);
int putc_unlocked(int c, FILE *stream);
int putchar_unlocked(int c);

FILE *popen(const char *command, const char *type);
int pclose(FILE *stream);

char *tempnam(const char *dir, const char *pfx);




int printf(const char *format, ...) __attribute__((format(printf, 1, 2)));



int fprintf(FILE *stream, const char* format, ...) __attribute__((format(printf, 2, 3)));



int sprintf(char *str, const char* format, ...) __attribute__((format(printf, 2, 3)));



int snprintf(char *str, size_t size, const char *format, ...) __attribute__((format(printf, 3, 4)));




int scanf(const char *format, ...);



int fscanf(FILE *stream, const char *format, ...);



int sscanf(const char *str, const char *format, ...);

void clearerr(FILE *stream);
int feof(FILE *stream);
int ferror(FILE *stream);
int fileno(FILE *stream);

int remove(const char *pathname);
int rename(const char *oldpath, const char *newpath);

void perror(const char *s);



FILE *tmpfile(void);
char *tmpnam(char *s);

void setbuf(FILE *stream, char *buf);
void setbuffer(FILE *stream, char *buf, size_t size);
void setlinebuf(FILE *stream);
int setvbuf(FILE *stream, char *buf, int mode , size_t size);

# 1 "c:/marmalade/5.2/s3e/h/std/stdarg.h" 1
# 54 "c:/marmalade/5.2/s3e/h/std/stdarg.h"
typedef __builtin_va_list va_list;
# 162 "c:/marmalade/5.2/s3e/h/ext/../std/stdio.h" 2

int vfprintf(FILE *stream, const char *format, va_list ap);
int vsprintf(char *str, const char *format, va_list ap);
int vsnprintf(char *str, size_t size, const char *format, va_list ap);
int vprintf(const char *format, va_list ap);
int asprintf(char **strp, const char *fmt, ...);
int vasprintf(char **strp, const char *fmt, va_list ap);

int vscanf(const char *format, va_list ap);
int vsscanf(const char *str, const char *format, va_list ap);
int vfscanf(FILE *stream, const char *format, va_list ap);

}
# 36 "c:/marmalade/5.2/s3e/h/std/c++/cstdio" 2
# 58 "c:/marmalade/5.2/s3e/h/std/c++/cstdio"
namespace _STL {
using ::FILE;
using ::fpos_t;
using ::size_t;
# 72 "c:/marmalade/5.2/s3e/h/std/c++/cstdio"
using ::clearerr;
using ::fclose;
using ::feof;
using ::ferror;
using ::fflush;
using ::fgetc;
using ::fgetpos;
using ::fgets;
using ::fopen;
using ::fprintf;
using ::fputc;
using ::fputs;
using ::fread;
using ::freopen;
using ::fscanf;
using ::fseek;
using ::fsetpos;
using ::ftell;
using ::fwrite;


 using ::getc;
 using ::getchar;
 using ::putc;
 using ::putchar;


using ::gets;
using ::perror;
using ::printf;
using ::puts;
using ::remove;
using ::rename;
using ::rewind;
using ::scanf;
using ::setbuf;
using ::setvbuf;
using ::sprintf;
using ::sscanf;
using ::tmpfile;
using ::tmpnam;
using ::ungetc;
using ::vfprintf;
using ::vprintf;
using ::vsprintf;





}
# 49 "c:/marmalade/5.2/s3e/h/std/c++/stl/_alloc.h" 2
# 60 "c:/marmalade/5.2/s3e/h/std/c++/stl/_alloc.h"
# 1 "c:/marmalade/5.2/s3e/h/std/c++/stl/_new.h" 1
# 11 "c:/marmalade/5.2/s3e/h/std/c++/stl/_new.h"
# 1 "c:/marmalade/5.2/s3e/h/std/c++/exception" 1
# 58 "c:/marmalade/5.2/s3e/h/std/c++/exception"
# 1 "c:/marmalade/5.2/s3e/h/ext/../std/c++/exception.h" 1
# 18 "c:/marmalade/5.2/s3e/h/ext/../std/c++/exception.h"
# 1 "c:/marmalade/5.2/s3e/h/std/c++/exception_gcc" 1
# 44 "c:/marmalade/5.2/s3e/h/std/c++/exception_gcc"
extern "C++" {

namespace std
{
# 56 "c:/marmalade/5.2/s3e/h/std/c++/exception_gcc"
  class exception
  {
  public:
    exception() throw() { }
    virtual ~exception() throw();


    virtual const char* what() const throw();
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() throw() { }


    virtual ~bad_exception() throw();
  };


  typedef void (*terminate_handler) ();

  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) throw();


  void terminate() __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) throw();


  void unexpected() __attribute__ ((__noreturn__));
# 104 "c:/marmalade/5.2/s3e/h/std/c++/exception_gcc"
  bool uncaught_exception() throw();
}

namespace __gnu_cxx
{
# 119 "c:/marmalade/5.2/s3e/h/std/c++/exception_gcc"
  void __verbose_terminate_handler ();
}

}
# 19 "c:/marmalade/5.2/s3e/h/ext/../std/c++/exception.h" 2
# 59 "c:/marmalade/5.2/s3e/h/std/c++/exception" 2
# 75 "c:/marmalade/5.2/s3e/h/std/c++/exception"
namespace _STL {


using __std_alias::exception;
using __std_alias::bad_exception;
# 106 "c:/marmalade/5.2/s3e/h/std/c++/exception"
}
# 12 "c:/marmalade/5.2/s3e/h/std/c++/stl/_new.h" 2

namespace _STL {

struct nothrow_t {};


extern const nothrow_t nothrow;




class bad_alloc : public exception {
public:
  bad_alloc () throw() { }
  bad_alloc(const bad_alloc&) throw() { }
  bad_alloc& operator=(const bad_alloc&) throw() {return *this;}
  ~bad_alloc () throw() { }
  const char* what() const throw() { return "bad alloc"; }
};

}
# 50 "c:/marmalade/5.2/s3e/h/std/c++/stl/_new.h"
# 1 "c:/marmalade/5.2/s3e/h/std/c++/new" 1
# 38 "c:/marmalade/5.2/s3e/h/std/c++/new"
# 1 "c:/marmalade/5.2/s3e/h/std/c++/new.h" 1
# 52 "c:/marmalade/5.2/s3e/h/std/c++/new.h"
inline void* operator new(size_t, void* p) { return p;};
inline void* operator new[](size_t, void* p) { return p;};
inline void operator delete(void*, void*) {};
inline void operator delete[](void*, void*) {};
# 39 "c:/marmalade/5.2/s3e/h/std/c++/new" 2
# 51 "c:/marmalade/5.2/s3e/h/std/c++/stl/_new.h" 2
# 80 "c:/marmalade/5.2/s3e/h/std/c++/stl/_new.h"
namespace _STL {





inline void* __stl_new(size_t __n) { void* __y = ::operator new(__n);if (__y == 0){;}return __y; }
inline void __stl_delete(void* __p) { ::operator delete(__p); }

}
# 61 "c:/marmalade/5.2/s3e/h/std/c++/stl/_alloc.h" 2



# 1 "c:/marmalade/5.2/s3e/h/std/c++/stl/_threads.h" 1
# 57 "c:/marmalade/5.2/s3e/h/std/c++/stl/_threads.h"
  typedef size_t __stl_atomic_t;
# 280 "c:/marmalade/5.2/s3e/h/std/c++/stl/_threads.h"
namespace _STL {




template <int __inst>
struct _STLP_mutex_spin {
  enum { __low_max = 30, __high_max = 1000 };

  static unsigned __max;
  static unsigned __last;
  static void _M_do_lock(volatile __stl_atomic_t* __lock);
  static void _S_nsec_sleep(int __log_nsec);
};
# 311 "c:/marmalade/5.2/s3e/h/std/c++/stl/_threads.h"
struct _STLP_mutex_base
{
# 441 "c:/marmalade/5.2/s3e/h/std/c++/stl/_threads.h"
  inline void _M_initialize() {}
  inline void _M_destroy() {}
  inline void _M_acquire_lock() {}
  inline void _M_release_lock() {}

};
# 458 "c:/marmalade/5.2/s3e/h/std/c++/stl/_threads.h"
typedef _STLP_mutex_base _STLP_mutex_nodemand;





class _STLP_mutex : public _STLP_mutex_nodemand {
  public:
    inline _STLP_mutex () { _M_initialize(); }
    inline ~_STLP_mutex () { _M_destroy(); }
  private:
    _STLP_mutex(const _STLP_mutex&);
    void operator=(const _STLP_mutex&);
};
# 569 "c:/marmalade/5.2/s3e/h/std/c++/stl/_threads.h"
struct _Refcount_Base
{

  volatile __stl_atomic_t _M_ref_count;


  _STLP_mutex _M_mutex;



  _Refcount_Base(__stl_atomic_t __n) : _M_ref_count(__n) {}
# 597 "c:/marmalade/5.2/s3e/h/std/c++/stl/_threads.h"
  void _M_incr() { ++_M_ref_count; }
  void _M_decr() { --_M_ref_count; }

};
# 632 "c:/marmalade/5.2/s3e/h/std/c++/stl/_threads.h"
static inline __stl_atomic_t
_Atomic_swap(volatile __stl_atomic_t * __p, __stl_atomic_t __q) {
  __stl_atomic_t __result = *__p;
  *__p = __q;
  return __result;
}






struct _STLP_auto_lock
{
  _STLP_mutex_base& _M_lock;

  _STLP_auto_lock(_STLP_mutex_base& __lock) : _M_lock(__lock)
    { _M_lock._M_acquire_lock(); }
  ~_STLP_auto_lock() { _M_lock._M_release_lock(); }

private:
  void operator=(const _STLP_auto_lock&);
  _STLP_auto_lock(const _STLP_auto_lock&);
};

typedef _STLP_auto_lock _STLP_mutex_lock;
# 710 "c:/marmalade/5.2/s3e/h/std/c++/stl/_threads.h"
}


# 1 "c:/marmalade/5.2/s3e/h/std/c++/stl/_threads.c" 1
# 714 "c:/marmalade/5.2/s3e/h/std/c++/stl/_threads.h" 2
# 65 "c:/marmalade/5.2/s3e/h/std/c++/stl/_alloc.h" 2



# 1 "c:/marmalade/5.2/s3e/h/std/c++/stl/_construct.h" 1
# 43 "c:/marmalade/5.2/s3e/h/std/c++/stl/_construct.h"
# 1 "c:/marmalade/5.2/s3e/h/std/c++/stl/_iterator_base.h" 1
# 44 "c:/marmalade/5.2/s3e/h/std/c++/stl/_iterator_base.h"
# 1 "c:/marmalade/5.2/s3e/h/std/c++/stl/type_traits.h" 1
# 62 "c:/marmalade/5.2/s3e/h/std/c++/stl/type_traits.h"
namespace _STL {

struct __true_type {};
struct __false_type {};


template <int _Is> struct __bool2type {
  typedef __false_type _Ret;
};

template<>
struct __bool2type<1> { typedef __true_type _Ret; };

template<>
struct __bool2type<0> { typedef __false_type _Ret; };


template <class _P1, class _P2, class _P3>
struct _Land3 {
  typedef __false_type _Ret;
};

template<>
struct _Land3<__true_type, __true_type, __true_type> {
  typedef __true_type _Ret;
};



template <class _Tp> struct __type_traits;
template <int _IsPOD> struct __type_traits_aux {
   typedef __false_type has_trivial_default_constructor;
   typedef __false_type has_trivial_copy_constructor;
   typedef __false_type has_trivial_assignment_operator;
   typedef __false_type has_trivial_destructor;
   typedef __false_type is_POD_type;
};

template<>
struct __type_traits_aux<0> {
   typedef __false_type has_trivial_default_constructor;
   typedef __false_type has_trivial_copy_constructor;
   typedef __false_type has_trivial_assignment_operator;
   typedef __false_type has_trivial_destructor;
   typedef __false_type is_POD_type;
};

template<>
struct __type_traits_aux<1> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};
# 188 "c:/marmalade/5.2/s3e/h/std/c++/stl/type_traits.h"
template <class _Tp>
struct __type_traits {
   typedef __true_type this_dummy_member_must_be_first;
# 206 "c:/marmalade/5.2/s3e/h/std/c++/stl/type_traits.h"
   typedef __false_type has_trivial_default_constructor;
   typedef __false_type has_trivial_copy_constructor;
   typedef __false_type has_trivial_assignment_operator;
   typedef __false_type has_trivial_destructor;
   typedef __false_type is_POD_type;
};


template <class _Tp> struct _IsPtr { enum { _Ret = 0 }; };
template <class _Tp> struct _IsPtrType {
  static __false_type _Ret() { return __false_type();}
};
template <class _Tp1, class _Tp2> struct _BothPtrType {
  static __false_type _Ret() { return __false_type();}
};

template <class _Tp1, class _Tp2>
struct _IsSame { enum { _Ret = 0 }; };





template <class _Tp> struct _IsPtr<_Tp*> { enum { _Ret = 1 }; };
template <class _Tp> struct _IsPtrType<_Tp*> {
  static __true_type _Ret() { return __true_type();}
};
template <class _Tp1, class _Tp2> struct _BothPtrType<_Tp1*, _Tp2*> {
  static __true_type _Ret() { return __true_type();}
};
template <class _Tp>
struct _IsSame<_Tp, _Tp> { enum { _Ret = 1 }; };
# 246 "c:/marmalade/5.2/s3e/h/std/c++/stl/type_traits.h"
template<> struct __type_traits<bool> : __type_traits_aux<1> {};

template<> struct __type_traits<char> : __type_traits_aux<1> {};

template<> struct __type_traits<signed char> : __type_traits_aux<1> {};

template<> struct __type_traits<unsigned char> : __type_traits_aux<1> {};




template<> struct __type_traits<short> : __type_traits_aux<1> {};
template<> struct __type_traits<unsigned short> : __type_traits_aux<1> {};
template<> struct __type_traits<int> : __type_traits_aux<1> {};
template<> struct __type_traits<unsigned int> : __type_traits_aux<1> {};
template<> struct __type_traits<long> : __type_traits_aux<1> {};
template<> struct __type_traits<unsigned long> : __type_traits_aux<1> {};


template<> struct __type_traits<long long> : __type_traits_aux<1> {};
template<> struct __type_traits<unsigned long long> : __type_traits_aux<1> {};


template<> struct __type_traits<float> : __type_traits_aux<1> {};
template<> struct __type_traits<double> : __type_traits_aux<1> {};


template<> struct __type_traits<long double> : __type_traits_aux<1> {};



template <class _Tp> struct __type_traits<_Tp*> : __type_traits_aux<1> {};





template <class _Tp> struct _Is_integer {
  typedef __false_type _Integral;
};



template<> struct _Is_integer<bool> {
  typedef __true_type _Integral;
};



template<> struct _Is_integer<char> {
  typedef __true_type _Integral;
};



template<> struct _Is_integer<signed char> {
  typedef __true_type _Integral;
};


template<> struct _Is_integer<unsigned char> {
  typedef __true_type _Integral;
};
# 318 "c:/marmalade/5.2/s3e/h/std/c++/stl/type_traits.h"
template<> struct _Is_integer<short> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<unsigned short> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<int> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<unsigned int> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<long> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<unsigned long> {
  typedef __true_type _Integral;
};



template<> struct _Is_integer<long long> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<unsigned long long> {
  typedef __true_type _Integral;
};



template <class _Tp1, class _Tp2>
struct _OKToMemCpy {
  enum { _Same = _IsSame<_Tp1,_Tp2>::_Ret } ;
  typedef typename __type_traits<_Tp1>::has_trivial_assignment_operator _Tr1;
  typedef typename __type_traits<_Tp2>::has_trivial_assignment_operator _Tr2;
  typedef typename __bool2type< _Same >::_Ret _Tr3;
  typedef typename _Land3<_Tr1, _Tr2, _Tr3>::_Ret _Type;
  static _Type _Ret() { return _Type(); }
};

template <class _Tp1, class _Tp2>
inline _OKToMemCpy<_Tp1, _Tp2> _IsOKToMemCpy(_Tp1*, _Tp2*) {
  return _OKToMemCpy<_Tp1, _Tp2>();
}

template <class _Tp>
struct _IsPOD {
  typedef typename __type_traits<_Tp>::is_POD_type _Type;
  static _Type _Ret() { return _Type(); }
};

template <class _Tp>
inline _IsPOD<_Tp> _Is_POD (_Tp*) { return _IsPOD<_Tp>(); }
# 411 "c:/marmalade/5.2/s3e/h/std/c++/stl/type_traits.h"
}
# 45 "c:/marmalade/5.2/s3e/h/std/c++/stl/_iterator_base.h" 2


namespace _STL {

struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag : public input_iterator_tag {};
struct bidirectional_iterator_tag : public forward_iterator_tag {};
struct random_access_iterator_tag : public bidirectional_iterator_tag {};


template <class _Category, class _Tp, class _Distance = ptrdiff_t,
          class _Pointer = _Tp*, class _Reference = _Tp& >
struct iterator {
  typedef _Category iterator_category;
  typedef _Tp value_type;
  typedef _Distance difference_type;
  typedef _Pointer pointer;
  typedef _Reference reference;
};
template<>
struct iterator<output_iterator_tag, void, void, void, void> {
  typedef output_iterator_tag iterator_category;

  typedef void value_type;
  typedef void difference_type;
  typedef void pointer;
  typedef void reference;

};
# 96 "c:/marmalade/5.2/s3e/h/std/c++/stl/_iterator_base.h"
template <class _Iterator>
struct iterator_traits {
  typedef typename _Iterator::iterator_category iterator_category;
  typedef typename _Iterator::value_type value_type;
  typedef typename _Iterator::difference_type difference_type;
  typedef typename _Iterator::pointer pointer;
  typedef typename _Iterator::reference reference;
};
# 115 "c:/marmalade/5.2/s3e/h/std/c++/stl/_iterator_base.h"
template <class _Tp>
struct iterator_traits<const _Tp*> {
  typedef random_access_iterator_tag iterator_category;
  typedef _Tp value_type;
  typedef ptrdiff_t difference_type;
  typedef const _Tp* pointer;
  typedef const _Tp& reference;
};

template <class _Tp>
struct iterator_traits<_Tp*> {
  typedef random_access_iterator_tag iterator_category;
  typedef _Tp value_type;
  typedef ptrdiff_t difference_type;
  typedef _Tp* pointer;
  typedef _Tp& reference;
};
# 164 "c:/marmalade/5.2/s3e/h/std/c++/stl/_iterator_base.h"
template <class _Iter>
inline typename iterator_traits<_Iter>::iterator_category __iterator_category(const _Iter&) {
  typedef typename iterator_traits<_Iter>::iterator_category _Category;
  return _Category();
}

template <class _Iter>
inline typename iterator_traits<_Iter>::difference_type* __distance_type(const _Iter&) {
  typedef typename iterator_traits<_Iter>::difference_type _diff_type;
  return static_cast<_diff_type*>(0);
}

template <class _Iter>
inline typename iterator_traits<_Iter>::value_type* __value_type(const _Iter&) {
  typedef typename iterator_traits<_Iter>::value_type _value_type;
  return static_cast<_value_type*>(0);
}
# 236 "c:/marmalade/5.2/s3e/h/std/c++/stl/_iterator_base.h"
template <class _Tp, class _Distance> struct input_iterator :
  public iterator <input_iterator_tag, _Tp, _Distance, _Tp*, _Tp&> {};
struct output_iterator : public iterator <output_iterator_tag, void, void, void, void> {};
template <class _Tp, class _Distance> struct forward_iterator :
  public iterator<forward_iterator_tag, _Tp, _Distance, _Tp*, _Tp&> {};
template <class _Tp, class _Distance> struct bidirectional_iterator :
  public iterator<bidirectional_iterator_tag, _Tp, _Distance, _Tp*, _Tp&> {};
template <class _Tp, class _Distance> struct random_access_iterator :
  public iterator<random_access_iterator_tag, _Tp, _Distance, _Tp*, _Tp&> {};
# 281 "c:/marmalade/5.2/s3e/h/std/c++/stl/_iterator_base.h"
template <class _InputIterator, class _Distance>
inline void __distance(const _InputIterator& __first, const _InputIterator& __last,
      _Distance& __n, const input_iterator_tag &) {
  _InputIterator __it(__first);
  while (__it != __last) { ++__it; ++__n; }
}
# 305 "c:/marmalade/5.2/s3e/h/std/c++/stl/_iterator_base.h"
template <class _RandomAccessIterator, class _Distance>
inline void __distance(const _RandomAccessIterator& __first,
      const _RandomAccessIterator& __last,
      _Distance& __n, const random_access_iterator_tag &) {
  __n += __last - __first;
}


template <class _InputIterator, class _Distance>
inline void distance(const _InputIterator& __first,
    const _InputIterator& __last, _Distance& __n) {
  __distance(__first, __last, __n, typename iterator_traits< _InputIterator >::iterator_category());
}


template <class _InputIterator>
inline typename iterator_traits<_InputIterator>::difference_type
__distance(const _InputIterator& __first, const _InputIterator& __last, const input_iterator_tag &) {
  typename iterator_traits<_InputIterator>::difference_type __n = 0;
  _InputIterator __it(__first);
  while (__it != __last) {
    ++__it; ++__n;
  }
  return __n;
}
# 359 "c:/marmalade/5.2/s3e/h/std/c++/stl/_iterator_base.h"
template <class _RandomAccessIterator>
inline typename iterator_traits<_RandomAccessIterator>::difference_type
__distance(const _RandomAccessIterator& __first, const _RandomAccessIterator& __last,
           const random_access_iterator_tag &) {
  return __last - __first;
}

template <class _InputIterator>
inline typename iterator_traits<_InputIterator>::difference_type
distance(const _InputIterator& __first, const _InputIterator& __last) {
  return __distance(__first, __last, typename iterator_traits< _InputIterator >::iterator_category());
}



template <class _Tp>
struct _Nonconst_traits;

template <class _Tp>
struct _Const_traits {
  typedef _Tp value_type;
  typedef const _Tp& reference;
  typedef const _Tp* pointer;
  typedef _Nonconst_traits<_Tp> _Non_const_traits;
};

template <class _Tp>
struct _Nonconst_traits {
  typedef _Tp value_type;
  typedef _Tp& reference;
  typedef _Tp* pointer;
  typedef _Nonconst_traits<_Tp> _Non_const_traits;
};
# 414 "c:/marmalade/5.2/s3e/h/std/c++/stl/_iterator_base.h"
template <class _InputIter, class _Distance>
inline void __advance(_InputIter& __i, _Distance __n, const input_iterator_tag &) {
  while (__n--) ++__i;
}


template <class _InputIter, class _Distance>
inline void __advance(_InputIter& __i, _Distance __n, const output_iterator_tag &) {
  while (__n--) ++__i;
}
# 432 "c:/marmalade/5.2/s3e/h/std/c++/stl/_iterator_base.h"
template <class _BidirectionalIterator, class _Distance>
inline void __advance(_BidirectionalIterator& __i, _Distance __n,
                      const bidirectional_iterator_tag &) {
  if (__n > 0)
    while (__n--) ++__i;
  else
    while (__n++) --__i;
}

template <class _RandomAccessIterator, class _Distance>
inline void __advance(_RandomAccessIterator& __i, _Distance __n,
                      const random_access_iterator_tag &) {
  __i += __n;
}

template <class _InputIterator, class _Distance>
inline void advance(_InputIterator& __i, _Distance __n) {
  __advance(__i, __n, typename iterator_traits< _InputIterator >::iterator_category());
}

}
# 44 "c:/marmalade/5.2/s3e/h/std/c++/stl/_construct.h" 2


namespace _STL {
# 55 "c:/marmalade/5.2/s3e/h/std/c++/stl/_construct.h"
template <class _Tp>
inline void _Destroy(_Tp* __pointer) {
# 67 "c:/marmalade/5.2/s3e/h/std/c++/stl/_construct.h"
    __pointer->~_Tp();





}
# 92 "c:/marmalade/5.2/s3e/h/std/c++/stl/_construct.h"
template <class _T1, class _T2>
inline void _Construct(_T1* __p, const _T2& __val) {



    new (__p) _T1(__val);
}

template <class _T1>
inline void _Construct(_T1* __p) {







  new (__p) _T1();

}
# 120 "c:/marmalade/5.2/s3e/h/std/c++/stl/_construct.h"
template <class _ForwardIterator>
inline void
__destroy_aux(_ForwardIterator __first, _ForwardIterator __last, const __false_type&) {
  for ( ; __first != __last; ++__first)
    _STL::_Destroy(&*__first);
}

template <class _ForwardIterator>
inline void __destroy_aux(_ForwardIterator, _ForwardIterator, const __true_type&) {}

template <class _ForwardIterator, class _Tp>
inline void
__destroy(_ForwardIterator __first, _ForwardIterator __last, _Tp*) {
  typedef typename __type_traits<_Tp>::has_trivial_destructor _Trivial_destructor;
  __destroy_aux(__first, __last, _Trivial_destructor());
}

template <class _ForwardIterator>
inline void _Destroy(_ForwardIterator __first, _ForwardIterator __last) {
  __destroy(__first, __last, (typename iterator_traits< _ForwardIterator >::value_type*)0);
}

inline void _Destroy(char*, char*) {}

inline void _Destroy(wchar_t*, wchar_t*) {}
inline void _Destroy(const wchar_t*, const wchar_t*) {}






template <class _T1, class _T2>
inline void construct(_T1* __p, const _T2& __val) {_Construct(__p, __val); }
template <class _T1>
inline void construct(_T1* __p) { _Construct(__p); }
template <class _Tp>
inline void destroy(_Tp* __pointer) { _STL::_Destroy(__pointer); }
template <class _ForwardIterator>
inline void destroy(_ForwardIterator __first, _ForwardIterator __last) { _STL::_Destroy(__first, __last); }

}
# 69 "c:/marmalade/5.2/s3e/h/std/c++/stl/_alloc.h" 2
# 85 "c:/marmalade/5.2/s3e/h/std/c++/stl/_alloc.h"
namespace _STL {
# 94 "c:/marmalade/5.2/s3e/h/std/c++/stl/_alloc.h"
typedef void (* __oom_handler_type)();

template <int __inst>
class __malloc_alloc {
private:
  static void* _S_oom_malloc(size_t);
  static __oom_handler_type __oom_handler;
public:

  typedef char value_type;





  static void* allocate(size_t __n) {
    void* __result = malloc(__n);
    if (0 == __result) __result = _S_oom_malloc(__n);
    return __result;
  }
  static void deallocate(void* __p, size_t ) { free((char*)__p); }
  static __oom_handler_type set_malloc_handler(__oom_handler_type __f) {
    __oom_handler_type __old = __oom_handler;
    __oom_handler = __f;
    return(__old);
  }
};




class __new_alloc {
public:

  typedef char value_type;





  static void* allocate(size_t __n) { return __stl_new(__n); }
  static void deallocate(void* __p, size_t) { __stl_delete(__p); }
};
# 146 "c:/marmalade/5.2/s3e/h/std/c++/stl/_alloc.h"
template <class _Alloc>
class __debug_alloc : public _Alloc {
public:
  typedef _Alloc __allocator_type;
  typedef typename _Alloc::value_type value_type;
private:
  struct __alloc_header {
    size_t __magic: 16;
    size_t __type_size:16;
    unsigned long _M_size;
  };

  enum { __pad=8, __magic=0xdeba, __deleted_magic = 0xdebd,
  __shred_byte= 0xA3
  };

  enum { __extra_before = 16, __extra_after = 8 };



  static size_t __extra_before_chunk() {
    return (long)__extra_before/sizeof(value_type)+
      (size_t)((long)__extra_before%sizeof(value_type)>0);
  }
  static size_t __extra_after_chunk() {
    return (long)__extra_after/sizeof(value_type)+
      (size_t)((long)__extra_after%sizeof(value_type)>0);
  }
public:





  __debug_alloc() {}
  ~__debug_alloc() {}
  static void * allocate(size_t);
  static void deallocate(void *, size_t);
};
# 214 "c:/marmalade/5.2/s3e/h/std/c++/stl/_alloc.h"
enum {_ALIGN = 8, _ALIGN_SHIFT=3, _MAX_BYTES = 128};



class _Node_alloc_obj {
public:
    _Node_alloc_obj * _M_free_list_link;
};

template <bool __threads, int __inst>
class __node_alloc {
  public:
  static inline size_t _S_round_up(size_t __bytes) { return (((__bytes) + (size_t)_ALIGN-1) & ~((size_t)_ALIGN - 1)); }
  typedef _Node_alloc_obj _Obj;
private:

  static void* _S_refill(size_t __n);


  static char* _S_chunk_alloc(size_t __p_size, int& __nobjs);

  static _Node_alloc_obj * _S_free_list[16];
  static char* _S_start_free;
  static char* _S_end_free;
  static size_t _S_heap_size;
  static void * _M_allocate(size_t __n);

  static void _M_deallocate(void *__p, size_t __n);
public:

  typedef char value_type;






  static void * allocate(size_t __n) { return (__n > (size_t)_MAX_BYTES) ? __stl_new(__n) : _M_allocate(__n); }

  static void deallocate(void *__p, size_t __n) { if (__n > (size_t)_MAX_BYTES) __stl_delete(__p); else _M_deallocate(__p, __n); }
};





typedef __node_alloc<false, 0> _Node_alloc;
# 301 "c:/marmalade/5.2/s3e/h/std/c++/stl/_alloc.h"
typedef __malloc_alloc<0> __sgi_alloc;


typedef __malloc_alloc<0> __single_client_alloc;
typedef __malloc_alloc<0> __multithreaded_alloc;
# 329 "c:/marmalade/5.2/s3e/h/std/c++/stl/_alloc.h"
template <class _Tp>
class allocator {
public:

  typedef _Tp value_type;
  typedef value_type * pointer;
  typedef const _Tp* const_pointer;
  typedef _Tp& reference;
  typedef const _Tp& const_reference;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };

  allocator() {}

  template <class _Tp1> allocator(const allocator<_Tp1>&) {}

  allocator(const allocator<_Tp>&) {}
  ~allocator() {}
  pointer address(reference __x) const { return &__x; }
  const_pointer address(const_reference __x) const { return &__x; }

  _Tp* allocate(size_type __n, const void* = 0) {
    return __n != 0 ? reinterpret_cast<value_type*>(__sgi_alloc::allocate(__n * sizeof(value_type))) : 0;
  }

  void deallocate(pointer __p, size_type __n) {
   
      if (__p != 0) __sgi_alloc::deallocate((void*)__p, __n * sizeof(value_type));
  }

  void deallocate(pointer __p) const { if (__p != 0) __sgi_alloc::deallocate((void*)__p, sizeof(value_type)); }
  size_type max_size() const { return size_t(-1) / sizeof(value_type); }
  void construct(pointer __p, const _Tp& __val) { _STL::_Construct(__p, __val); }
  void destroy(pointer __p) { _STL::_Destroy(__p); }




};

template<>
class allocator<void> {
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef void* pointer;
  typedef const void* const_pointer;

  typedef void value_type;


  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };





};


template <class _T1, class _T2> inline bool operator==(const allocator<_T1>&, const allocator<_T2>&) { return true; }
template <class _T1, class _T2> inline bool operator!=(const allocator<_T1>&, const allocator<_T2>&) { return false; }
# 411 "c:/marmalade/5.2/s3e/h/std/c++/stl/_alloc.h"
template <class _Tp, class _Allocator>
struct _Alloc_traits
{
  typedef _Allocator _Orig;

  typedef typename _Allocator::template rebind<_Tp> _Rebind_type;
  typedef typename _Rebind_type::other allocator_type;
  static allocator_type create_allocator(const _Orig& __a) { return allocator_type(__a); }





};
# 457 "c:/marmalade/5.2/s3e/h/std/c++/stl/_alloc.h"
template <class _Tp, class _Alloc>
inline typename _Alloc_traits<_Tp, _Alloc>::allocator_type
__stl_alloc_create(const _Alloc& __a, const _Tp*) {
  typedef typename _Alloc::template rebind<_Tp>::other _Rebound_type;
  return _Rebound_type(__a);
}
# 480 "c:/marmalade/5.2/s3e/h/std/c++/stl/_alloc.h"
template <class _Value, class _Tp, class _MaybeReboundAlloc>
class _STLP_alloc_proxy : public _MaybeReboundAlloc {
private:
  typedef _MaybeReboundAlloc _Base;
  typedef _STLP_alloc_proxy<_Value, _Tp, _MaybeReboundAlloc> _Self;
public:
  _Value _M_data;
  inline _STLP_alloc_proxy(const _MaybeReboundAlloc& __a, _Value __p) : _MaybeReboundAlloc(__a), _M_data(__p) {}
# 509 "c:/marmalade/5.2/s3e/h/std/c++/stl/_alloc.h"
};
# 520 "c:/marmalade/5.2/s3e/h/std/c++/stl/_alloc.h"
}
# 33 "c:/marmalade/5.2/s3e/h/std/c++/memory" 2



# 1 "c:/marmalade/5.2/s3e/h/std/c++/stl/_tempbuf.h" 1
# 34 "c:/marmalade/5.2/s3e/h/std/c++/stl/_tempbuf.h"
# 1 "c:/marmalade/5.2/s3e/h/std/c++/climits" 1
# 32 "c:/marmalade/5.2/s3e/h/std/c++/climits"
# 1 "c:/marmalade/5.2/s3e/h/std/limits.h" 1
# 33 "c:/marmalade/5.2/s3e/h/std/c++/climits" 2
# 35 "c:/marmalade/5.2/s3e/h/std/c++/stl/_tempbuf.h" 2





# 1 "c:/marmalade/5.2/s3e/h/std/c++/stl/_uninitialized.h" 1
# 38 "c:/marmalade/5.2/s3e/h/std/c++/stl/_uninitialized.h"
# 1 "c:/marmalade/5.2/s3e/h/std/c++/stl/_algobase.h" 1
# 51 "c:/marmalade/5.2/s3e/h/std/c++/stl/_algobase.h"
# 1 "c:/marmalade/5.2/s3e/h/std/c++/stl/_pair.h" 1
# 34 "c:/marmalade/5.2/s3e/h/std/c++/stl/_pair.h"
namespace _STL {

template <class _T1, class _T2>
struct pair {
  typedef _T1 first_type;
  typedef _T2 second_type;

  _T1 first;
  _T2 second;



  pair() : first(_T1()), second(_T2()) {}

  pair(const _T1& __a, const _T2& __b) : first(__a), second(__b) {}


  template <class _U1, class _U2>
  pair(const pair<_U1, _U2>& __p) : first(__p.first), second(__p.second) {}

  pair(const pair<_T1,_T2>& __o) : first(__o.first), second(__o.second) {}

 
};

template <class _T1, class _T2>
inline bool operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
{
  return __x.first == __y.first && __x.second == __y.second;
}

template <class _T1, class _T2>
inline bool operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
{
  return __x.first < __y.first ||
         (!(__y.first < __x.first) && __x.second < __y.second);
}



template <class _T1, class _T2>
inline bool operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
  return !(__x == __y);
}

template <class _T1, class _T2>
inline bool operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
  return __y < __x;
}

template <class _T1, class _T2>
inline bool operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
  return !(__y < __x);
}

template <class _T1, class _T2>
inline bool operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
  return !(__x < __y);
}





template <class _T1, class _T2, int _Sz>
inline pair<_T1, _T2 const*> make_pair(_T1 const& __x,
                                       _T2 const (&__y)[_Sz])
{
  return pair<_T1, _T2 const*>(__x, static_cast<_T2 const*>(__y));
}

template <class _T1, class _T2, int _Sz>
inline pair<_T1 const*, _T2> make_pair(_T1 const (&__x)[_Sz],
                                       _T2 const& __y)
{
  return pair<_T1 const*, _T2>(static_cast<_T1 const*>(__x), __y);
}

template <class _T1, class _T2, int _Sz1, int _Sz2>
inline pair<_T1 const*, _T2 const*> make_pair(_T1 const (&__x)[_Sz1],
                                              _T2 const (&__y)[_Sz2])
{
  return pair<_T1 const*, _T2 const*>(static_cast<_T1 const*>(__x),
                                      static_cast<_T2 const*>(__y));
}


template <class _T1, class _T2>
inline pair<_T1, _T2> make_pair(const _T1& __x, const _T2& __y)
{
  return pair<_T1, _T2>(__x, __y);
}


}


namespace _STL { namespace rel_ops {

template <class _Tp>
inline bool operator!=(const _Tp& __x, const _Tp& __y) {
  return !(__x == __y);
}

template <class _Tp>
inline bool operator>(const _Tp& __x, const _Tp& __y) {
  return __y < __x;
}

template <class _Tp>
inline bool operator<=(const _Tp& __x, const _Tp& __y) {
  return !(__y < __x);
}

template <class _Tp>
inline bool operator>=(const _Tp& __x, const _Tp& __y) {
  return !(__x < __y);
}

} }
# 52 "c:/marmalade/5.2/s3e/h/std/c++/stl/_algobase.h" 2






namespace _STL {

template <class _Tp>
inline void swap(_Tp& __a, _Tp& __b) {
  _Tp __tmp = __a;
  __a = __b;
  __b = __tmp;
}

template <class _ForwardIter1, class _ForwardIter2>
inline void iter_swap(_ForwardIter1 __i1, _ForwardIter2 __i2) {
  swap(*__i1, *__i2);
}





template <class _Tp>
inline const _Tp& (min)(const _Tp& __a, const _Tp& __b) { return __b < __a ? __b : __a; }
template <class _Tp>
inline const _Tp& (max)(const _Tp& __a, const _Tp& __b) { return __a < __b ? __b : __a; }







template <class _Tp, class _Compare>
inline const _Tp& (min)(const _Tp& __a, const _Tp& __b, _Compare __comp) {
  return __comp(__b, __a) ? __b : __a;
}

template <class _Tp, class _Compare>
inline const _Tp& (max)(const _Tp& __a, const _Tp& __b, _Compare __comp) {
  return __comp(__a, __b) ? __b : __a;
}
# 106 "c:/marmalade/5.2/s3e/h/std/c++/stl/_algobase.h"
template <class _InputIter, class _OutputIter, class _Distance>
inline _OutputIter __copy(_InputIter __first, _InputIter __last,
                          _OutputIter __result,
                          const input_iterator_tag &, _Distance*) {
  for ( ; __first != __last; ++__result, ++__first)
    *__result = *__first;
  return __result;
}
# 134 "c:/marmalade/5.2/s3e/h/std/c++/stl/_algobase.h"
template <class _RandomAccessIter, class _OutputIter, class _Distance>
inline _OutputIter
__copy(_RandomAccessIter __first, _RandomAccessIter __last,
       _OutputIter __result, const random_access_iterator_tag &, _Distance*) {
  for (_Distance __n = __last - __first; __n > 0; --__n) {
    *__result = *__first;
    ++__first;
    ++__result;
  }
  return __result;
}

inline void*
__copy_trivial(const void* __first, const void* __last, void* __result) {
  return (__last == __first) ? __result :
    ((char*)memmove(__result, __first, ((const char*)__last - (const char*)__first))) +
    ((const char*)__last - (const char*)__first);
}




template <class _BidirectionalIter1, class _BidirectionalIter2,
          class _Distance>
inline _BidirectionalIter2 __copy_backward(_BidirectionalIter1 __first,
                                           _BidirectionalIter1 __last,
                                           _BidirectionalIter2 __result,
                                           const bidirectional_iterator_tag &,
                                           _Distance*)
{
  while (__first != __last)
    *--__result = *--__last;
  return __result;
}

template <class _RandomAccessIter, class _BidirectionalIter, class _Distance>
inline _BidirectionalIter __copy_backward(_RandomAccessIter __first,
                                          _RandomAccessIter __last,
                                          _BidirectionalIter __result,
                                          const random_access_iterator_tag &,
                                          _Distance*)
{
  for (_Distance __n = __last - __first; __n > 0; --__n)
    *--__result = *--__last;
  return __result;
}

inline void*
__copy_trivial_backward(const void* __first, const void* __last, void* __result) {
  const ptrdiff_t _Num = (const char*)__last - (const char*)__first;
  return (_Num > 0) ? memmove((char*)__result - _Num, __first, _Num) : __result ;
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_ptrs(_InputIter __first, _InputIter __last, _OutputIter __result, const __false_type&) {
  return __copy(__first, __last, __result,
                typename iterator_traits< _InputIter >::iterator_category(),
                (typename iterator_traits< _InputIter >::difference_type*)0);
}
template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_ptrs(_InputIter __first, _InputIter __last, _OutputIter __result, const __true_type&) {


  return (_OutputIter)__copy_trivial(__first, __last, __result);
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_aux(_InputIter __first, _InputIter __last, _OutputIter __result, const __true_type&) {
  return __copy_ptrs(__first, __last, __result,
                     _IsOKToMemCpy((typename iterator_traits< _InputIter >::value_type*)0,
                                   (typename iterator_traits< _OutputIter >::value_type*)0)._Ret());
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_aux(_InputIter __first, _InputIter __last, _OutputIter __result, const __false_type&) {
  return __copy(__first, __last, __result,
  typename iterator_traits< _InputIter >::iterator_category(), (typename iterator_traits< _InputIter >::difference_type*)0);
}

template <class _InputIter, class _OutputIter>
inline _OutputIter copy(_InputIter __first, _InputIter __last, _OutputIter __result) {
 
    return __copy_aux(__first, __last, __result, _BothPtrType< _InputIter, _OutputIter> :: _Ret());
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_backward_ptrs(_InputIter __first, _InputIter __last, _OutputIter __result, const __false_type&) {
  return __copy_backward(__first, __last, __result, typename iterator_traits< _InputIter >::iterator_category(), (typename iterator_traits< _InputIter >::difference_type*)0);
}
template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_backward_ptrs(_InputIter __first, _InputIter __last, _OutputIter __result, const __true_type&) {
  return (_OutputIter)__copy_trivial_backward(__first, __last, __result);
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_backward_aux(_InputIter __first, _InputIter __last, _OutputIter __result, const __false_type&) {
  return __copy_backward(__first, __last, __result, typename iterator_traits< _InputIter >::iterator_category(), (typename iterator_traits< _InputIter >::difference_type*)0);
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_backward_aux(_InputIter __first, _InputIter __last, _OutputIter __result, const __true_type&) {
  return __copy_backward_ptrs(__first, __last, __result,
                              _IsOKToMemCpy((typename iterator_traits< _InputIter >::value_type*)0,
                                            (typename iterator_traits< _OutputIter >::value_type*)0)._Ret());
}

template <class _InputIter, class _OutputIter>
inline _OutputIter copy_backward(_InputIter __first, _InputIter __last, _OutputIter __result) {
 
    return __copy_backward_aux(__first, __last, __result, _BothPtrType< _InputIter, _OutputIter> :: _Ret() );
}
# 282 "c:/marmalade/5.2/s3e/h/std/c++/stl/_algobase.h"
template <class _InputIter, class _Size, class _OutputIter>
inline
pair<_InputIter, _OutputIter> __copy_n(_InputIter __first, _Size __count,
                                       _OutputIter __result,
                                       const input_iterator_tag &) {
  for ( ; __count > 0; --__count) {
    *__result = *__first;
    ++__first;
    ++__result;
  }
  return pair<_InputIter, _OutputIter>(__first, __result);
}

template <class _RAIter, class _Size, class _OutputIter>
inline pair<_RAIter, _OutputIter>
__copy_n(_RAIter __first, _Size __count,
         _OutputIter __result,
         const random_access_iterator_tag &) {
  _RAIter __last = __first + __count;
  return pair<_RAIter, _OutputIter>(__last, copy(__first, __last, __result));
}

template <class _InputIter, class _Size, class _OutputIter>
inline pair<_InputIter, _OutputIter>
__copy_n(_InputIter __first, _Size __count, _OutputIter __result) {
 
  return __copy_n(__first, __count, __result, typename iterator_traits< _InputIter >::iterator_category());
}

template <class _InputIter, class _Size, class _OutputIter>
inline pair<_InputIter, _OutputIter>
copy_n(_InputIter __first, _Size __count, _OutputIter __result) {
 
  return __copy_n(__first, __count, __result, typename iterator_traits< _InputIter >::iterator_category());
}





template <class _ForwardIter, class _Tp>
inline
void fill(_ForwardIter __first, _ForwardIter __last, const _Tp& __val) {
 
  for ( ; __first != __last; ++__first)
    *__first = __val;
}

template <class _OutputIter, class _Size, class _Tp>
inline
_OutputIter fill_n(_OutputIter __first, _Size __n, const _Tp& __val) {
 
  for ( ; __n > 0; --__n, ++__first)
    *__first = __val;
  return __first;
}




inline void fill(unsigned char* __first, unsigned char* __last,
                 const unsigned char& __val) {
  unsigned char __tmp = __val;
  memset(__first, __tmp, __last - __first);
}

inline void fill(signed char* __first, signed char* __last,
                 const signed char& __val) {
  signed char __tmp = __val;
  memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
}

inline void fill(char* __first, char* __last, const char& __val) {
  char __tmp = __val;
  memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
}



template <class _Size>
inline unsigned char* fill_n(unsigned char* __first, _Size __n,
                             const unsigned char& __val) {
  fill(__first, __first + __n, __val);
  return __first + __n;
}

template <class _Size>
inline signed char* fill_n(char* __first, _Size __n,
                           const signed char& __val) {
  fill(__first, __first + __n, __val);
  return __first + __n;
}

template <class _Size>
inline char* fill_n(char* __first, _Size __n, const char& __val) {
  fill(__first, __first + __n, __val);
  return __first + __n;
}







template <class _InputIter1, class _InputIter2>
inline
pair<_InputIter1, _InputIter2> mismatch(_InputIter1 __first1,
                                        _InputIter1 __last1,
                                        _InputIter2 __first2) {
 
 
  while (__first1 != __last1 && *__first1 == *__first2) {
    ++__first1;
    ++__first2;
  }
  return pair<_InputIter1, _InputIter2>(__first1, __first2);
}

template <class _InputIter1, class _InputIter2, class _BinaryPredicate>
inline
pair<_InputIter1, _InputIter2> mismatch(_InputIter1 __first1,
                                        _InputIter1 __last1,
                                        _InputIter2 __first2,
                                        _BinaryPredicate __binary_pred) {
 
 
  while (__first1 != __last1 && __binary_pred(*__first1, *__first2)) {
    ++__first1;
    ++__first2;
  }
  return pair<_InputIter1, _InputIter2>(__first1, __first2);
}

template <class _InputIter1, class _InputIter2>
inline
bool equal(_InputIter1 __first1, _InputIter1 __last1,
                  _InputIter2 __first2) {
 
 
  for ( ; __first1 != __last1; ++__first1, ++__first2)
    if (!(*__first1 == *__first2))
      return false;
  return true;
}

template <class _InputIter1, class _InputIter2, class _BinaryPredicate>
inline
bool equal(_InputIter1 __first1, _InputIter1 __last1,
                  _InputIter2 __first2, _BinaryPredicate __binary_pred) {
 
 
  for ( ; __first1 != __last1; ++__first1, ++__first2)
    if (!__binary_pred(*__first1, *__first2))
      return false;
  return true;
}





template <class _InputIter1, class _InputIter2>
bool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2);

template <class _InputIter1, class _InputIter2, class _Compare>
bool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2,
                             _Compare __comp);

inline bool
lexicographical_compare(const unsigned char* __first1,
                        const unsigned char* __last1,
                        const unsigned char* __first2,
                        const unsigned char* __last2)
{
  const size_t __len1 = __last1 - __first1;
  const size_t __len2 = __last2 - __first2;
 
 

  const int __result = memcmp(__first1, __first2, (min) (__len1, __len2));
  return __result != 0 ? (__result < 0) : (__len1 < __len2);
}



inline bool lexicographical_compare(const char* __first1, const char* __last1,
                                    const char* __first2, const char* __last2)
{
 
 

  return lexicographical_compare((const unsigned char*) __first1,
                                 (const unsigned char*) __last1,
                                 (const unsigned char*) __first2,
                                 (const unsigned char*) __last2);
}


template <class _InputIter1, class _InputIter2>
int __lexicographical_compare_3way(_InputIter1 __first1, _InputIter1 __last1,
                                   _InputIter2 __first2, _InputIter2 __last2);

inline int
__lexicographical_compare_3way(const unsigned char* __first1,
                               const unsigned char* __last1,
                               const unsigned char* __first2,
                               const unsigned char* __last2)
{
  const ptrdiff_t __len1 = __last1 - __first1;
  const ptrdiff_t __len2 = __last2 - __first2;
  const int __result = memcmp(__first1, __first2, (min) (__len1, __len2));
  return __result != 0 ? __result
                       : (__len1 == __len2 ? 0 : (__len1 < __len2 ? -1 : 1));
}



inline int
__lexicographical_compare_3way(const char* __first1, const char* __last1,
                               const char* __first2, const char* __last2)
{
  return __lexicographical_compare_3way((const unsigned char*) __first1,
                                        (const unsigned char*) __last1,
                                        (const unsigned char*) __first2,
                                        (const unsigned char*) __last2);
}




template <class _InputIter1, class _InputIter2>
int lexicographical_compare_3way(_InputIter1 __first1, _InputIter1 __last1,
                                 _InputIter2 __first2, _InputIter2 __last2);




template <class _InputIter, class _Tp>
inline typename iterator_traits<_InputIter>::difference_type
count(_InputIter __first, _InputIter __last, const _Tp& __val) {
 
  typename iterator_traits<_InputIter>::difference_type __n = 0;
  for ( ; __first != __last; ++__first)
    if (*__first == __val)
      ++__n;
  return __n;
}


template <class _InputIter, class _Tp>
_InputIter find(_InputIter __first, _InputIter __last, const _Tp& __val);
template <class _InputIter, class _Predicate>
_InputIter find_if(_InputIter __first, _InputIter __last, _Predicate __pred);


template <class _ForwardIter1, class _ForwardIter2, class _BinaryPred>
_ForwardIter1 search(_ForwardIter1 __first1, _ForwardIter1 __last1,
                     _ForwardIter2 __first2, _ForwardIter2 __last2, _BinaryPred __predicate);


template <class _InputIter, class _ForwardIter, class _BinaryPredicate>
_InputIter __find_first_of(_InputIter __first1, _InputIter __last1,
                           _ForwardIter __first2, _ForwardIter __last2,
                           _BinaryPredicate __comp);

template <class _ForwardIter1, class _ForwardIter2,
          class _BinaryPredicate>
_ForwardIter1
find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,
         _ForwardIter2 __first2, _ForwardIter2 __last2,
         _BinaryPredicate __comp);


template <class _ForwardIter, class _Tp>
inline void
replace(_ForwardIter __first, _ForwardIter __last,
        const _Tp& __old_value, const _Tp& __new_value) {
 
  for ( ; __first != __last; ++__first)
    if (*__first == __old_value)
      *__first = __new_value;
}

template <class _ForwardIter, class _Tp, class _Compare, class _Distance>
_ForwardIter __lower_bound(_ForwardIter __first, _ForwardIter __last,
                              const _Tp& __val, const _Compare& __comp, _Distance*);

}


# 1 "c:/marmalade/5.2/s3e/h/std/c++/stl/_algobase.c" 1
# 32 "c:/marmalade/5.2/s3e/h/std/c++/stl/_algobase.c"
namespace _STL {

template <class _InputIter1, class _InputIter2>
bool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2) {
 
   
    for ( ; __first1 != __last1 && __first2 != __last2
     ; ++__first1, ++__first2) {
      if (*__first1 < *__first2)
 return true;
      if (*__first2 < *__first1)
 return false;
    }
  return __first1 == __last1 && __first2 != __last2;
}

template <class _InputIter1, class _InputIter2, class _Compare>
bool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2,
                             _Compare __comp) {
 
   
    for ( ; __first1 != __last1 && __first2 != __last2
     ; ++__first1, ++__first2) {
      if (__comp(*__first1, *__first2))
 return true;
      if (__comp(*__first2, *__first1))
 return false;
    }
  return __first1 == __last1 && __first2 != __last2;
}



template <class _InputIter1, class _InputIter2>
int __lexicographical_compare_3way(_InputIter1 __first1, _InputIter1 __last1,
                                   _InputIter2 __first2, _InputIter2 __last2)
{
  while (__first1 != __last1 && __first2 != __last2) {
    if (*__first1 < *__first2)
      return -1;
    if (*__first2 < *__first1)
      return 1;
    ++__first1;
    ++__first2;
  }
  if (__first2 == __last2) {
    return !(__first1 == __last1);
  }
  else {
    return -1;
  }
}


template <class _InputIter1, class _InputIter2>
int lexicographical_compare_3way(_InputIter1 __first1, _InputIter1 __last1,
                                 _InputIter2 __first2, _InputIter2 __last2)
{
 
   
    return __lexicographical_compare_3way(__first1, __last1, __first2, __last2);
}


template <class _RandomAccessIter, class _Tp>
inline _RandomAccessIter __find(_RandomAccessIter __first, _RandomAccessIter __last,
                                           const _Tp& __val,
                                           const random_access_iterator_tag &)
{
  typename iterator_traits<_RandomAccessIter>::difference_type __trip_count = (__last - __first) >> 2;

  for ( ; __trip_count > 0 ; --__trip_count) {
    if (*__first == __val) return __first;
    ++__first;

    if (*__first == __val) return __first;
    ++__first;

    if (*__first == __val) return __first;
    ++__first;

    if (*__first == __val) return __first;
    ++__first;
  }

  switch(__last - __first) {
  case 3:
    if (*__first == __val) return __first;
    ++__first;
  case 2:
    if (*__first == __val) return __first;
    ++__first;
  case 1:
    if (*__first == __val) return __first;
    ++__first;
  case 0:
  default:
    return __last;
  }
}

template <class _RandomAccessIter, class _Predicate>
inline _RandomAccessIter __find_if(_RandomAccessIter __first, _RandomAccessIter __last,
                                              _Predicate __pred,
                                              const random_access_iterator_tag &)
{
  typename iterator_traits<_RandomAccessIter>::difference_type __trip_count = (__last - __first) >> 2;

  for ( ; __trip_count > 0 ; --__trip_count) {
    if (__pred(*__first)) return __first;
    ++__first;

    if (__pred(*__first)) return __first;
    ++__first;

    if (__pred(*__first)) return __first;
    ++__first;

    if (__pred(*__first)) return __first;
    ++__first;
  }

  switch(__last - __first) {
  case 3:
    if (__pred(*__first)) return __first;
    ++__first;
  case 2:
    if (__pred(*__first)) return __first;
    ++__first;
  case 1:
    if (__pred(*__first)) return __first;

  case 0:
  default:
    return __last;
  }
}

template <class _InputIter, class _Tp>
inline _InputIter __find(_InputIter __first, _InputIter __last,
    const _Tp& __val,
    const input_iterator_tag &)
{
  while (__first != __last && !(*__first == __val))
    ++__first;
  return __first;
}

template <class _InputIter, class _Predicate>
inline _InputIter __find_if(_InputIter __first, _InputIter __last,
                            _Predicate __pred,
                            const input_iterator_tag &)
{
  while (__first != __last && !__pred(*__first))
    ++__first;
  return __first;
}

template <class _InputIter, class _Predicate>
_InputIter find_if(_InputIter __first, _InputIter __last,
                   _Predicate __pred) {
 
    return __find_if(__first, __last, __pred, typename iterator_traits< _InputIter >::iterator_category());
}

template <class _InputIter, class _Tp>
_InputIter find(_InputIter __first, _InputIter __last, const _Tp& __val)
{
 
    return __find(__first, __last, __val, typename iterator_traits< _InputIter >::iterator_category());
}

template <class _ForwardIter1, class _ForwardIter2, class _BinaryPred>
_ForwardIter1 search(_ForwardIter1 __first1, _ForwardIter1 __last1,
                     _ForwardIter2 __first2, _ForwardIter2 __last2,
                     _BinaryPred __predicate)
{
 
   

    if (__first1 == __last1 || __first2 == __last2)
      return __first1;


  _ForwardIter2 __tmp(__first2);
  ++__tmp;
  if (__tmp == __last2) {
    while (__first1 != __last1 && !__predicate(*__first1, *__first2))
      ++__first1;
    return __first1;
  }



  _ForwardIter2 __p1, __p;

  __p1 = __first2; ++__p1;



  while (__first1 != __last1) {
    while (__first1 != __last1) {
      if (__predicate(*__first1, *__first2))
        break;
      ++__first1;
    }
    while (__first1 != __last1 && !__predicate(*__first1, *__first2))
      ++__first1;
    if (__first1 == __last1)
      return __last1;

    __p = __p1;
    _ForwardIter1 __current = __first1;
    if (++__current == __last1) return __last1;

    while (__predicate(*__current, *__p)) {
      if (++__p == __last2)
        return __first1;
      if (++__current == __last1)
        return __last1;
    }

    ++__first1;
  }
  return __first1;
}



template <class _InputIter, class _ForwardIter, class _BinaryPredicate>
_InputIter __find_first_of(_InputIter __first1, _InputIter __last1,
                           _ForwardIter __first2, _ForwardIter __last2,
                           _BinaryPredicate __comp) {
  for ( ; __first1 != __last1; ++__first1)
    for (_ForwardIter __iter = __first2; __iter != __last2; ++__iter)
      if (__comp(*__first1, *__iter))
        return __first1;
  return __last1;
}
# 282 "c:/marmalade/5.2/s3e/h/std/c++/stl/_algobase.c"
template <class _ForwardIter1, class _ForwardIter2,
  class _BinaryPredicate>
_ForwardIter1 __find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,
                         _ForwardIter2 __first2, _ForwardIter2 __last2,
                         const forward_iterator_tag &, const forward_iterator_tag &,
                         _BinaryPredicate __comp)
{
  if (__first2 == __last2)
    return __last1;
  else {
    _ForwardIter1 __result = __last1;
    while (1) {
      _ForwardIter1 __new_result
        = search(__first1, __last1, __first2, __last2, __comp);
      if (__new_result == __last1)
        return __result;
      else {
        __result = __new_result;
        __first1 = __new_result;
        ++__first1;
      }
    }
  }
}





}
# 1 "c:/marmalade/5.2/s3e/h/std/c++/stl/_iterator.h" 1
# 37 "c:/marmalade/5.2/s3e/h/std/c++/stl/_iterator.h"
namespace _STL {
# 46 "c:/marmalade/5.2/s3e/h/std/c++/stl/_iterator.h"
template <class _Iterator>
class reverse_iterator :
  public iterator<typename iterator_traits<_Iterator>::iterator_category,
                  typename iterator_traits<_Iterator>::value_type,
                  typename iterator_traits<_Iterator>::difference_type,
                  typename iterator_traits<_Iterator>::pointer,
                  typename iterator_traits<_Iterator>::reference>
{
protected:
  _Iterator current;
  typedef reverse_iterator<_Iterator> _Self;
public:
  typedef typename iterator_traits<_Iterator>::iterator_category iterator_category;
  typedef typename iterator_traits<_Iterator>::value_type value_type;
  typedef typename iterator_traits<_Iterator>::difference_type difference_type;
  typedef typename iterator_traits<_Iterator>::pointer pointer;
  typedef typename iterator_traits<_Iterator>::reference reference;
  typedef _Iterator iterator_type;
public:
  reverse_iterator() {}
  explicit reverse_iterator(iterator_type __x) : current(__x) {}
  reverse_iterator(const _Self& __x) : current(__x.current) {}
  _Self& operator = (const _Self& __x) { current = __x.base(); return *this; }

  template <class _Iter>
  reverse_iterator(const reverse_iterator<_Iter>& __x) : current(__x.base()) {}
  template <class _Iter>
  _Self& operator = (const reverse_iterator<_Iter>& __x) { current = __x.base(); return *this; }


  iterator_type base() const { return current; }
  reference operator*() const {
    _Iterator __tmp = current;
    return *--__tmp;
  }
  pointer operator->() const { return &(operator*()); }
  _Self& operator++() {
    --current;
    return *this;
  }
  _Self operator++(int) {
    _Self __tmp = *this;
    --current;
    return __tmp;
  }
  _Self& operator--() {
    ++current;
    return *this;
  }
  _Self operator--(int) {
    _Self __tmp = *this;
    ++current;
    return __tmp;
  }

  _Self operator+(difference_type __n) const {
    return _Self(current - __n);
  }
  _Self& operator+=(difference_type __n) {
    current -= __n;
    return *this;
  }
  _Self operator-(difference_type __n) const {
    return _Self(current + __n);
  }
  _Self& operator-=(difference_type __n) {
    current += __n;
    return *this;
  }
  reference operator[](difference_type __n) const { return *(*this + __n); }
};

template <class _Iterator>
inline bool operator==(const reverse_iterator<_Iterator>& __x,
                       const reverse_iterator<_Iterator>& __y) {
  return __x.base() == __y.base();
}

template <class _Iterator>
inline bool operator<(const reverse_iterator<_Iterator>& __x,
                      const reverse_iterator<_Iterator>& __y) {
  return __y.base() < __x.base();
}



template <class _Iterator>
inline bool operator!=(const reverse_iterator<_Iterator>& __x,
                       const reverse_iterator<_Iterator>& __y) {
  return !(__x == __y);
}

template <class _Iterator>
inline bool operator>(const reverse_iterator<_Iterator>& __x,
                      const reverse_iterator<_Iterator>& __y) {
  return __y < __x;
}

template <class _Iterator>
inline bool operator<=(const reverse_iterator<_Iterator>& __x,
                       const reverse_iterator<_Iterator>& __y) {
  return !(__y < __x);
}

template <class _Iterator>
inline bool operator>=(const reverse_iterator<_Iterator>& __x,
                      const reverse_iterator<_Iterator>& __y) {
  return !(__x < __y);
}



template <class _Iterator>



inline typename reverse_iterator<_Iterator>::difference_type

operator-(const reverse_iterator<_Iterator>& __x,
          const reverse_iterator<_Iterator>& __y) {
  return __y.base() - __x.base();
}

template <class _Iterator, class _DifferenceType>
inline reverse_iterator<_Iterator>
operator+(_DifferenceType n,const reverse_iterator<_Iterator>& x) {
  return x.operator+(n);
}



template <class _Container>
class back_insert_iterator
  : public iterator<output_iterator_tag,void,void,void,void>
{
protected:
  _Container* container;
public:
  typedef _Container container_type;
  typedef output_iterator_tag iterator_category;

  explicit back_insert_iterator(_Container& __x) : container(&__x) {}
  back_insert_iterator<_Container>&
  operator=(const typename _Container::value_type& __val) {
    container->push_back(__val);
    return *this;
  }
  back_insert_iterator<_Container>& operator*() { return *this; }
  back_insert_iterator<_Container>& operator++() { return *this; }
  back_insert_iterator<_Container> operator++(int) { return *this; }
};

template <class _Container>
inline back_insert_iterator<_Container> back_inserter(_Container& __x) {
  return back_insert_iterator<_Container>(__x);
}

template <class _Container>
class front_insert_iterator
  : public iterator<output_iterator_tag,void,void,void,void>
{
protected:
  _Container* container;
public:
  typedef _Container container_type;
  typedef output_iterator_tag iterator_category;
  explicit front_insert_iterator(_Container& __x) : container(&__x) {}
  front_insert_iterator<_Container>&
  operator=(const typename _Container::value_type& __val) {
    container->push_front(__val);
    return *this;
  }
  front_insert_iterator<_Container>& operator*() { return *this; }
  front_insert_iterator<_Container>& operator++() { return *this; }
  front_insert_iterator<_Container>& operator++(int) { return *this; }
};

template <class _Container>
inline front_insert_iterator<_Container> front_inserter(_Container& __x) {
  return front_insert_iterator<_Container>(__x);
}

template <class _Container>
class insert_iterator
  : public iterator<output_iterator_tag,void,void,void,void>
{
protected:
  _Container* container;
  typename _Container::iterator iter;
public:
  typedef _Container container_type;
  typedef output_iterator_tag iterator_category;
  insert_iterator(_Container& __x, typename _Container::iterator __i)
    : container(&__x), iter(__i) {}
  insert_iterator<_Container>&
  operator=(const typename _Container::value_type& __val) {
    iter = container->insert(iter, __val);
    ++iter;
    return *this;
  }
  insert_iterator<_Container>& operator*() { return *this; }
  insert_iterator<_Container>& operator++() { return *this; }
  insert_iterator<_Container>& operator++(int) { return *this; }
};

template <class _Container, class _Iterator>
inline insert_iterator<_Container>
inserter(_Container& __x, _Iterator __i)
{
  typedef typename _Container::iterator __iter;
  return insert_iterator<_Container>(__x, __iter(__i));
}

}
# 313 "c:/marmalade/5.2/s3e/h/std/c++/stl/_algobase.c" 2
namespace _STL {


template <class _BidirectionalIter1, class _BidirectionalIter2,
  class _BinaryPredicate>
_BidirectionalIter1
__find_end(_BidirectionalIter1 __first1, _BidirectionalIter1 __last1,
           _BidirectionalIter2 __first2, _BidirectionalIter2 __last2,
           const bidirectional_iterator_tag &, const bidirectional_iterator_tag &,
           _BinaryPredicate __comp)
{
  typedef reverse_iterator<_BidirectionalIter1> _RevIter1;
  typedef reverse_iterator<_BidirectionalIter2> _RevIter2;

  _RevIter1 __rlast1(__first1);
  _RevIter2 __rlast2(__first2);
  _RevIter1 __rresult = search(_RevIter1(__last1), __rlast1,
                               _RevIter2(__last2), __rlast2,
                               __comp);

  if (__rresult == __rlast1)
    return __last1;
  else {
    _BidirectionalIter1 __result = __rresult.base();
    advance(__result, -distance(__first2, __last2));
    return __result;
  }
}


template <class _ForwardIter1, class _ForwardIter2,
  class _BinaryPredicate>
_ForwardIter1
find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,
         _ForwardIter2 __first2, _ForwardIter2 __last2,
         _BinaryPredicate __comp)
{
 
   
    return __find_end(__first1, __last1, __first2, __last2,

        typename iterator_traits< _ForwardIter1 >::iterator_category(),
        typename iterator_traits< _ForwardIter2 >::iterator_category(),




        __comp);
}

template <class _ForwardIter, class _Tp, class _Compare, class _Distance>
_ForwardIter __lower_bound(_ForwardIter __first, _ForwardIter __last,
      const _Tp& __val, const _Compare& __comp, _Distance*)
{
  _Distance __len = distance(__first, __last);
  _Distance __half;
  _ForwardIter __middle;

  while (__len > 0) {
    __half = __len >> 1;
    __middle = __first;
    advance(__middle, __half);
    if (__comp(*__middle, __val)) {
      __first = __middle;
      ++__first;
      __len = __len - __half - 1;
    }
    else
      __len = __half;
  }
  return __first;
}

}
# 576 "c:/marmalade/5.2/s3e/h/std/c++/stl/_algobase.h" 2
# 39 "c:/marmalade/5.2/s3e/h/std/c++/stl/_uninitialized.h" 2






namespace _STL {





template <class _InputIter, class _ForwardIter>
inline _ForwardIter
__uninitialized_copy(_InputIter __first, _InputIter __last, _ForwardIter __result,
                     const __true_type&) {
  return __copy_aux(__first, __last, __result, _BothPtrType< _InputIter, _ForwardIter> :: _Ret());
}

template <class _InputIter, class _ForwardIter>
inline
_ForwardIter
__uninitialized_copy(_InputIter __first, _InputIter __last, _ForwardIter __result,
                     const __false_type&)
{
  _ForwardIter __cur = __result;
  {
    for ( ; __first != __last; ++__first, ++__cur)
      _Construct(&*__cur, *__first);
    return __cur;
  }
  ;



}

template <class _InputIter, class _ForwardIter>
inline _ForwardIter
uninitialized_copy(_InputIter __first, _InputIter __last, _ForwardIter __result) {
  return __uninitialized_copy(__first, __last, __result, typename __type_traits< typename iterator_traits< _ForwardIter >::value_type >::is_POD_type());
}

inline char*
uninitialized_copy(const char* __first, const char* __last, char* __result) {
  return (char*)__copy_trivial (__first, __last, __result);
}


inline wchar_t*
uninitialized_copy(const wchar_t* __first, const wchar_t* __last, wchar_t* __result) {
  return (wchar_t*)__copy_trivial (__first, __last, __result);
}





template <class _InputIter, class _Size, class _ForwardIter>
inline
pair<_InputIter, _ForwardIter>
__uninitialized_copy_n(_InputIter __first, _Size __count,
                       _ForwardIter __result,
                       const input_iterator_tag &)
{
  _ForwardIter __cur = __result;
  {
    for ( ; __count > 0 ; --__count, ++__first, ++__cur)
      _Construct(&*__cur, *__first);
    return pair<_InputIter, _ForwardIter>(__first, __cur);
  }
  ;



}
# 135 "c:/marmalade/5.2/s3e/h/std/c++/stl/_uninitialized.h"
template <class _RandomAccessIter, class _Size, class _ForwardIter>
inline pair<_RandomAccessIter, _ForwardIter>
__uninitialized_copy_n(_RandomAccessIter __first, _Size __count, _ForwardIter __result, const random_access_iterator_tag &) {
  _RandomAccessIter __last = __first + __count;
  return pair<_RandomAccessIter, _ForwardIter>( __last, __uninitialized_copy(__first, __last, __result,
                                                                             typename __type_traits< typename iterator_traits< _ForwardIter >::value_type >::is_POD_type()));
}


template <class _InputIter, class _Size, class _ForwardIter>
inline pair<_InputIter, _ForwardIter>
uninitialized_copy_n(_InputIter __first, _Size __count,
                     _ForwardIter __result) {
  return __uninitialized_copy_n(__first, __count, __result, typename iterator_traits< _InputIter >::iterator_category());
}




template <class _ForwardIter, class _Tp>
inline void
__uninitialized_fill(_ForwardIter __first, _ForwardIter __last,
                     const _Tp& __x, const __true_type&) {
  _STL::fill(__first, __last, __x);
}

template <class _ForwardIter, class _Tp>
inline void
__uninitialized_fill(_ForwardIter __first, _ForwardIter __last,
                     const _Tp& __x, const __false_type&)
{
  _ForwardIter __cur = __first;
  {
    for ( ; __cur != __last; ++__cur)
      _Construct(&*__cur, __x);
  }
  ;
}

template <class _ForwardIter, class _Tp>
inline void uninitialized_fill(_ForwardIter __first, _ForwardIter __last, const _Tp& __x) {
  __uninitialized_fill(__first, __last, __x, typename __type_traits< typename iterator_traits< _ForwardIter >::value_type >::is_POD_type());
}



template <class _ForwardIter, class _Size, class _Tp>
inline _ForwardIter
__uninitialized_fill_n(_ForwardIter __first, _Size __n,
                       const _Tp& __x, const __true_type&) {
  return _STL::fill_n(__first, __n, __x);
}

template <class _ForwardIter, class _Size, class _Tp>
inline _ForwardIter
__uninitialized_fill_n(_ForwardIter __first, _Size __n,
                       const _Tp& __x, const __false_type&)
{
  _ForwardIter __cur = __first;
  {
    for ( ; __n > 0; --__n, ++__cur)
      _Construct(&*__cur, __x);
    return __cur;
  }
  ;



}

template <class _ForwardIter, class _Size, class _Tp>
inline _ForwardIter
uninitialized_fill_n(_ForwardIter __first, _Size __n, const _Tp& __x) {
  return __uninitialized_fill_n(__first, __n, __x, typename __type_traits< typename iterator_traits< _ForwardIter >::value_type >::is_POD_type());
}
# 219 "c:/marmalade/5.2/s3e/h/std/c++/stl/_uninitialized.h"
template <class _InputIter1, class _InputIter2, class _ForwardIter>
inline _ForwardIter
__uninitialized_copy_copy(_InputIter1 __first1, _InputIter1 __last1,
                          _InputIter2 __first2, _InputIter2 __last2,
                          _ForwardIter __result, __true_type)
{
  return __uninitialized_copy(__first2, __last2,
                              __uninitialized_copy(__first1, __last1, __result, __true_type()), __true_type());
}

template <class _InputIter1, class _InputIter2, class _ForwardIter>
inline _ForwardIter
__uninitialized_copy_copy(_InputIter1 __first1, _InputIter1 __last1,
                          _InputIter2 __first2, _InputIter2 __last2,
                          _ForwardIter __result, __false_type)
{
  _ForwardIter __mid = __uninitialized_copy(__first1, __last1, __result, typename __type_traits< typename iterator_traits< _ForwardIter >::value_type >::is_POD_type());
  {
    return __uninitialized_copy(__first2, __last2, __mid , typename __type_traits< typename iterator_traits< _ForwardIter >::value_type >::is_POD_type());
  }
  ;



}




template <class _ForwardIter, class _Tp, class _InputIter>
inline _ForwardIter
__uninitialized_fill_copy(_ForwardIter __result, _ForwardIter __mid, const _Tp& __x,
                          _InputIter __first, _InputIter __last)
{
  typedef typename __type_traits<_Tp>::is_POD_type _I_POD;
  __uninitialized_fill(__result, __mid, __x, _I_POD());
  {
    return __uninitialized_copy(__first, __last, __mid, _I_POD());
  }
  ;



}




template <class _InputIter, class _ForwardIter, class _Tp>
inline void
__uninitialized_copy_fill(_InputIter __first1, _InputIter __last1,
                          _ForwardIter __first2, _ForwardIter __last2,
                          const _Tp& __x)
{
  typedef typename __type_traits<_Tp>::is_POD_type _I_POD;
  _ForwardIter __mid2 = __uninitialized_copy(__first1, __last1, __first2, _I_POD());
  {
    __uninitialized_fill(__mid2, __last2, __x, _I_POD());
  }
  ;
}

}
# 41 "c:/marmalade/5.2/s3e/h/std/c++/stl/_tempbuf.h" 2


namespace _STL {

template <class _Tp>
pair<_Tp*, ptrdiff_t>
__get_temporary_buffer(ptrdiff_t __len, _Tp*);



template <class _Tp>
inline pair<_Tp*, ptrdiff_t> get_temporary_buffer(ptrdiff_t __len) {
  return __get_temporary_buffer(__len, (_Tp*) 0);
}







template <class _Tp>
inline pair<_Tp*, ptrdiff_t>
get_temporary_buffer(ptrdiff_t __len, _Tp*) {
  return __get_temporary_buffer(__len, (_Tp*) 0);
}



template <class _Tp>
inline void return_temporary_buffer(_Tp* __p) {

  free((char*)__p);
}

template <class _ForwardIterator, class _Tp>
class _Temporary_buffer {
private:
  ptrdiff_t _M_original_len;
  ptrdiff_t _M_len;
  _Tp* _M_buffer;

  void _M_allocate_buffer() {
    _M_original_len = _M_len;
    _M_buffer = 0;

    if (_M_len > (ptrdiff_t)(0x7fffffffL / sizeof(_Tp)))
      _M_len = 0x7fffffffL / sizeof(_Tp);

    while (_M_len > 0) {
      _M_buffer = (_Tp*) malloc(_M_len * sizeof(_Tp));
      if (_M_buffer)
        break;
      _M_len /= 2;
    }
  }

  void _M_initialize_buffer(const _Tp&, const __true_type&) {}
  void _M_initialize_buffer(const _Tp& val, const __false_type&) {
    uninitialized_fill_n(_M_buffer, _M_len, val);
  }

public:
  ptrdiff_t size() const { return _M_len; }
  ptrdiff_t requested_size() const { return _M_original_len; }
  _Tp* begin() { return _M_buffer; }
  _Tp* end() { return _M_buffer + _M_len; }

  _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last) {




     typedef typename __type_traits<_Tp>::has_trivial_default_constructor _Trivial;

    {
      _M_len = distance(__first, __last);
      _M_allocate_buffer();
      if (_M_len > 0)
        _M_initialize_buffer(*__first, _Trivial());
    }
    ;
  }

  ~_Temporary_buffer() {
    _STL::_Destroy(_M_buffer, _M_buffer + _M_len);
    free(_M_buffer);
  }

private:

  _Temporary_buffer(const _Temporary_buffer<_ForwardIterator, _Tp>&) {}
  void operator=(const _Temporary_buffer<_ForwardIterator, _Tp>&) {}
};





template <class _ForwardIterator,
          class _Tp

                    = typename iterator_traits<_ForwardIterator>::value_type

         >
struct temporary_buffer : public _Temporary_buffer<_ForwardIterator, _Tp>
{
  temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)
    : _Temporary_buffer<_ForwardIterator, _Tp>(__first, __last) {}
  ~temporary_buffer() {}
};



}


# 1 "c:/marmalade/5.2/s3e/h/std/c++/stl/_tempbuf.c" 1
# 33 "c:/marmalade/5.2/s3e/h/std/c++/stl/_tempbuf.c"
namespace _STL {

template <class _Tp>
pair<_Tp*, ptrdiff_t>
__get_temporary_buffer(ptrdiff_t __len, _Tp*)
{
  if (__len > ptrdiff_t(0x7fffffffL / sizeof(_Tp)))
    __len = 0x7fffffffL / sizeof(_Tp);

  while (__len > 0) {
    _Tp* __tmp = (_Tp*) malloc((size_t)__len * sizeof(_Tp));
    if (__tmp != 0)
      return pair<_Tp*, ptrdiff_t>(__tmp, __len);
    __len /= 2;
  }

  return pair<_Tp*, ptrdiff_t>((_Tp*)0, 0);
}
}
# 159 "c:/marmalade/5.2/s3e/h/std/c++/stl/_tempbuf.h" 2
# 37 "c:/marmalade/5.2/s3e/h/std/c++/memory" 2



# 1 "c:/marmalade/5.2/s3e/h/std/c++/stl/_raw_storage_iter.h" 1
# 37 "c:/marmalade/5.2/s3e/h/std/c++/stl/_raw_storage_iter.h"
namespace _STL {

template <class _ForwardIterator, class _Tp>
class raw_storage_iterator



{
protected:
  _ForwardIterator _M_iter;
public:
  typedef output_iterator_tag iterator_category;

  typedef void value_type;
  typedef void difference_type;
  typedef void pointer;
  typedef void reference;

  explicit raw_storage_iterator(_ForwardIterator __x) : _M_iter(__x) {}
  raw_storage_iterator<_ForwardIterator, _Tp>& operator*() { return *this; }
  raw_storage_iterator<_ForwardIterator, _Tp>& operator=(const _Tp& __element) {
    _Construct(&*_M_iter, __element);
    return *this;
  }
  raw_storage_iterator<_ForwardIterator, _Tp>& operator++() {
    ++_M_iter;
    return *this;
  }
  raw_storage_iterator<_ForwardIterator, _Tp> operator++(int) {
    raw_storage_iterator<_ForwardIterator, _Tp> __tmp = *this;
    ++_M_iter;
    return __tmp;
  }
};





}
# 41 "c:/marmalade/5.2/s3e/h/std/c++/memory" 2


# 1 "c:/marmalade/5.2/s3e/h/std/c++/stl/_auto_ptr.h" 1
# 22 "c:/marmalade/5.2/s3e/h/std/c++/stl/_auto_ptr.h"
namespace _STL {

class __ptr_base {
public:
  void* _M_p;
  void __set(const void* p) { _M_p = const_cast<void*>(p); }
  void __set(void* p) { _M_p = p; }
};

template <class _Tp> class auto_ptr_ref {
public:
  __ptr_base& _M_r;
  _Tp* const _M_p;

  auto_ptr_ref(__ptr_base& __r, _Tp* __p) : _M_r(__r), _M_p(__p) { }

  _Tp* release() const { _M_r.__set((void*)0); return _M_p; }

};

template<class _Tp> class auto_ptr : public __ptr_base {
public:
  typedef _Tp element_type;
  typedef auto_ptr<_Tp> _Self;

  _Tp* release() {
    _Tp* __px = this->get();
    this->_M_p = 0;
    return __px;
  }

  void reset(_Tp* __px=0) {
    _Tp* __pt = this->get();
    if (__px != __pt)
      delete __pt;
    this->__set(__px);
  }

  _Tp* get() const { return reinterpret_cast<_Tp*>(const_cast<void*>(_M_p)); }


  _Tp* operator->() const {
   
    return get();
  }

  _Tp& operator*() const {
   
    return *get();
  }

  auto_ptr() { this->_M_p = 0; }

  explicit auto_ptr(_Tp* __px) { this->__set(__px); }



  template<class _Tp1> auto_ptr(auto_ptr<_Tp1>& __r) {
    _Tp* __conversionCheck = __r.release();
    this->__set(__conversionCheck);
  }

  template<class _Tp1> auto_ptr<_Tp>& operator=(auto_ptr<_Tp1>& __r) {
    _Tp* __conversionCheck = __r.release();
    reset(__conversionCheck);
    return *this;
  }


  auto_ptr(_Self& __r) { this->__set(__r.release()); }

  _Self& operator=(_Self& __r) {
    reset(__r.release());
    return *this;
  }

  ~auto_ptr() { delete this->get(); }

  auto_ptr(auto_ptr_ref<_Tp> __r) {
    this->__set(__r.release());
  }

  _Self& operator=(auto_ptr_ref<_Tp> __r) {
    reset(__r.release());
    return *this;
  }


  template<class _Tp1> operator auto_ptr_ref<_Tp1>() {
    return auto_ptr_ref<_Tp1>(*this, this->get());
  }
  template<class _Tp1> operator auto_ptr<_Tp1>() {
    return auto_ptr<_Tp1>(release());
  }





};
}
# 44 "c:/marmalade/5.2/s3e/h/std/c++/memory" 2
# 24 "c:/marmalade/5.2/s3e/h/std/c++/stl/_string.h" 2



# 1 "c:/marmalade/5.2/s3e/h/std/c++/cctype" 1
# 30 "c:/marmalade/5.2/s3e/h/std/c++/cctype"
# 1 "c:/marmalade/5.2/s3e/h/std/ctype.h" 1
# 17 "c:/marmalade/5.2/s3e/h/std/ctype.h"
extern "C" {
# 31 "c:/marmalade/5.2/s3e/h/std/ctype.h"
int toupper(int c);
int tolower(int c);
int isalnum(int c);
int isalpha(int c);

int isblank(int c);
int iscntrl(int c);
int isdigit(int c);
int isgraph(int c);
int islower(int c);
int isprint(int c);
int ispunct(int c);
int isspace(int c);
int isupper(int c);
int isxdigit(int c);

}
# 31 "c:/marmalade/5.2/s3e/h/std/c++/cctype" 2
# 51 "c:/marmalade/5.2/s3e/h/std/c++/cctype"
namespace _STL {
using ::isalnum;
using ::isalpha;
using ::iscntrl;
using ::isdigit;
using ::isgraph;
using ::islower;
using ::isprint;
using ::ispunct;
using ::isspace;
using ::isupper;
using ::isxdigit;
using ::tolower;
using ::toupper;
}
# 28 "c:/marmalade/5.2/s3e/h/std/c++/stl/_string.h" 2



# 1 "c:/marmalade/5.2/s3e/h/std/c++/stl/_string_fwd.h" 1
# 23 "c:/marmalade/5.2/s3e/h/std/c++/stl/_string_fwd.h"
# 1 "c:/marmalade/5.2/s3e/h/std/c++/iosfwd" 1
# 28 "c:/marmalade/5.2/s3e/h/std/c++/iosfwd"
         





# 1 "c:/marmalade/5.2/s3e/h/std/c++/cwchar" 1
# 49 "c:/marmalade/5.2/s3e/h/std/c++/cwchar"
# 1 "c:/marmalade/5.2/s3e/h/ext/../std/wchar.h" 1
# 16 "c:/marmalade/5.2/s3e/h/ext/../std/wchar.h"
# 1 "c:/marmalade/5.2/s3e/h/std/stdio.h" 1
# 17 "c:/marmalade/5.2/s3e/h/ext/../std/wchar.h" 2
# 1 "c:/marmalade/5.2/s3e/h/std/time.h" 1
# 19 "c:/marmalade/5.2/s3e/h/std/time.h"
typedef long time_t;





typedef long clock_t;




struct tm
{
    int tm_sec;
    int tm_min;
    int tm_hour;
    int tm_mday;
    int tm_mon;
    int tm_year;
    int tm_wday;
    int tm_yday;
    int tm_isdst;
};



struct timespec
{
    time_t tv_sec;
    long int tv_nsec;
};

extern "C" {






time_t time(time_t *t);

void tzset(void);

char *asctime(const struct tm *tm);
char *asctime_r(const struct tm *tm, char *buf);

char *ctime(const time_t *timep);
char *ctime_r(const time_t *timep, char *buf);

struct tm *gmtime(const time_t *timep);
struct tm *gmtime_r(const time_t *timep, struct tm *result);

struct tm *localtime(const time_t *timep);
struct tm *localtime_r(const time_t *timep, struct tm *result);

time_t mktime(struct tm *tm);

size_t strftime(char *s, size_t max, const char *format, const struct tm *tm);

clock_t clock(void);

double difftime(time_t time1, time_t time0);

int nanosleep(const struct timespec *req, struct timespec *rem);



    extern char *_tzname[2];
    extern int _daylight;
    extern long int _timezone;
# 101 "c:/marmalade/5.2/s3e/h/std/time.h"
typedef int clockid_t;

int clock_getres(clockid_t clk_id, struct timespec *res);

int clock_gettime(clockid_t clk_id, struct timespec *tp);

int clock_settime(clockid_t clk_id, const struct timespec *tp);

}

# 1 "c:/marmalade/5.2/s3e/h/std/sys/time.h" 1
# 16 "c:/marmalade/5.2/s3e/h/std/sys/time.h"
# 1 "c:/marmalade/5.2/s3e/h/std/time.h" 1
# 17 "c:/marmalade/5.2/s3e/h/std/sys/time.h" 2



extern "C" {

typedef long suseconds_t;
struct timeval
{
    time_t tv_sec;
    suseconds_t tv_usec;
};

struct _timezone
{
    int tz_minuteswest;
    int tz_dsttime;
};

int gettimeofday(struct timeval *tv, struct _timezone *tz);
int settimeofday(const struct timeval *tv , const struct _timezone *tz);

int utimes(const char *filename, const struct timeval times[2]);

}
# 112 "c:/marmalade/5.2/s3e/h/std/time.h" 2
# 18 "c:/marmalade/5.2/s3e/h/ext/../std/wchar.h" 2
# 1 "c:/marmalade/5.2/s3e/h/std/wctype.h" 1
# 18 "c:/marmalade/5.2/s3e/h/std/wctype.h"
extern "C" {

typedef const int32* wctrans_t;

wctype_t wctype(const char *name);
wctrans_t wctrans(const char *name);
int iswctype(wint_t wc, wctype_t desc);
wint_t towctrans(wint_t wc, wctrans_t desc);

int towupper(int c);
int towlower(int c);
int iswalnum(int c);
int iswalpha(int c);
int iswascii(int c);
int iswblank(int c);
int iswcntrl(int c);
int iswdigit(int c);
int iswgraph(int c);
int iswlower(int c);
int iswprint(int c);
int iswpunct(int c);
int iswspace(int c);
int iswupper(int c);
int iswxdigit(int c);

}
# 19 "c:/marmalade/5.2/s3e/h/ext/../std/wchar.h" 2


extern "C" {



typedef int mbstate_t;

wchar_t fgetwc(FILE *stream);
wchar_t *fgetws(wchar_t *ws, int n, FILE *stream);
wchar_t fputwc(wchar_t wc, FILE *stream);
wchar_t putwc(wchar_t wc, FILE *stream);
wchar_t getwc(FILE *stream);
wchar_t getwchar(void);
wchar_t ungetwc(wchar_t wc, FILE *stream);

int fputws(const wchar_t *ws, FILE *stream);
int fwide(FILE *stream, int mode);

int mbsinit(const mbstate_t *ps);
wchar_t btowc(int c);
size_t mbrlen(const char *s, size_t n, mbstate_t *ps);
size_t mbsrtowcs(wchar_t *dest, const char **src, size_t len, mbstate_t *ps);
size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *ps);
wchar_t putwchar(wchar_t wc);
wchar_t *wmemset(wchar_t *wcs, wchar_t wc, size_t n);
wchar_t *wcspbrk(const wchar_t *wcs, const wchar_t *accept);
wchar_t *wcsrchr(const wchar_t *wcs, wchar_t wc);
wchar_t *wmemchr(const wchar_t *s, wchar_t c, size_t n);
int wmemcmp(const wchar_t *s1, const wchar_t *s2, size_t n);
size_t wcslen(const wchar_t *s);
size_t wcsnlen(const wchar_t *s, size_t n);
size_t wcsrtombs(char *dest, const wchar_t **src, size_t len, mbstate_t *ps);
wchar_t *wmemmove(wchar_t *dest, const wchar_t *src, size_t n);
wchar_t *wmemcpy(wchar_t *dest, const wchar_t *src, size_t n);
wchar_t *wcsstr(const wchar_t *haystack, const wchar_t *needle);
wchar_t *wcschr(const wchar_t *wcs, wchar_t wc);
size_t wcsspn(const wchar_t *wcs, const wchar_t *accept);
wchar_t *wcstok(wchar_t *wcs, const wchar_t *delim, wchar_t **ptr);
wchar_t *wcsncpy(wchar_t *dest, const wchar_t *src, size_t n);
wchar_t *wcscat(wchar_t *dest, const wchar_t *src);
wchar_t *wcscpy(wchar_t *dest, const wchar_t *src);
size_t wcsxfrm (wchar_t *s1, const wchar_t *s2, size_t n);
float wcstof(const wchar_t *nptr, wchar_t **endptr);

int wcscoll (const wchar_t *s1, const wchar_t *s2);

int wprintf(const wchar_t *format, ...);
int fwprintf(FILE *stream, const wchar_t *format, ...);
int swprintf(wchar_t *wcs, size_t maxlen, const wchar_t *format, ...);

int wscanf(const wchar_t *format, ...);
int fwscanf(FILE *stream, const wchar_t *format, ...);
int swscanf(const wchar_t *str, const wchar_t *format, ...);

size_t wcrtomb(char *s, wchar_t wc, mbstate_t *ps);
int wcscmp(const wchar_t *s1, const wchar_t *s2);
int wcsncmp(const wchar_t *s1, const wchar_t *s2, size_t n);
size_t wcsftime(wchar_t *s, size_t maxsize, const wchar_t *format, const struct tm *tp);
int wctob(wint_t c);
size_t wcscspn(const wchar_t *wcs, const wchar_t *reject);
wchar_t *wcsncat(wchar_t *dest, const wchar_t *src, size_t n);

int64 wcstoll(wchar_t *nptr, wchar_t **endptr, int base);
uint64 wcstoull(wchar_t *nptr, wchar_t **endptr, int base);
long int wcstol(const wchar_t *nptr, wchar_t **endptr, int base);
unsigned long int wcstoul(const wchar_t *nptr, wchar_t **endptr, int base);
double wcstod(const wchar_t *nptr, wchar_t **endptr);
long double wcstold(wchar_t *nptr, wchar_t **endptr);

int vwprintf(const wchar_t *format, va_list args);
int vfwprintf(FILE *stream, const wchar_t *format, va_list args);
int vswprintf(wchar_t *wcs, size_t maxlen, const wchar_t *format, va_list args);

int vfwscanf(FILE *s, const wchar_t *format, va_list arg);
int vswscanf(wchar_t *s, wchar_t *format, va_list arg);
int vwscanf(wchar_t *format, va_list arg);






}
# 50 "c:/marmalade/5.2/s3e/h/std/c++/cwchar" 2
# 98 "c:/marmalade/5.2/s3e/h/std/c++/cwchar"
# 1 "c:/marmalade/5.2/s3e/h/std/c++/stl/_cwchar.h" 1
# 21 "c:/marmalade/5.2/s3e/h/std/c++/stl/_cwchar.h"
# 1 "c:/marmalade/5.2/s3e/h/std/c++/cwchar" 1
# 22 "c:/marmalade/5.2/s3e/h/std/c++/stl/_cwchar.h" 2
# 99 "c:/marmalade/5.2/s3e/h/std/c++/cwchar" 2
# 107 "c:/marmalade/5.2/s3e/h/std/c++/cwchar"
namespace _STL {





using ::wint_t;






using ::size_t;


using ::mbstate_t;
# 147 "c:/marmalade/5.2/s3e/h/std/c++/cwchar"
using ::fgetwc;
using ::fgetws;
using ::fputwc;
using ::fputws;





using ::fwide;

using ::fwprintf;
using ::fwscanf;
using ::getwchar;



using ::getwc;
using ::ungetwc;

using ::putwc;
using ::putwchar;




using ::swprintf;
using ::swscanf;
using ::vfwprintf;
using ::vwprintf;
using ::vswprintf;


using ::wcsftime;

using ::wcstok;




using ::wcscat;
using ::wcsrchr;
using ::wcscmp;
using ::wcscoll;

using ::wcscpy;
using ::wcscspn;

using ::wcslen;
using ::wcsncat;
using ::wcsncmp;
using ::wcsncpy;
using ::wcspbrk;
using ::wcschr;

using ::wcsspn;
using ::wcsxfrm;





using ::wcstod;
using ::wcstol;





using ::wcsstr;
using ::wmemchr;




using ::wctob;
using ::wmemcmp;

using ::wmemmove;
using ::wprintf;
using ::wscanf;



using ::wmemcpy;
using ::wmemset;



}
# 35 "c:/marmalade/5.2/s3e/h/std/c++/iosfwd" 2


# 1 "c:/marmalade/5.2/s3e/h/std/c++/stl/_iosfwd.h" 1
# 22 "c:/marmalade/5.2/s3e/h/std/c++/stl/_iosfwd.h"
# 1 "c:/marmalade/5.2/s3e/h/std/c++/stl/char_traits.h" 1
# 53 "c:/marmalade/5.2/s3e/h/std/c++/stl/char_traits.h"
namespace _STL {



template <class _Tp> class allocator;
# 67 "c:/marmalade/5.2/s3e/h/std/c++/stl/char_traits.h"
typedef long streamoff;


typedef ptrdiff_t streamsize;




template <class _StateT> class fpos
{
public:
  fpos(streamoff __pos) : _M_pos(__pos), _M_st(_StateT()) {}
  fpos() : _M_pos(0), _M_st(_StateT()) {}

  operator streamoff() const { return _M_pos; }

  bool operator==(const fpos<_StateT>& __y) const
    { return _M_pos == __y._M_pos; }
  bool operator!=(const fpos<_StateT>& __y) const
    { return _M_pos != __y._M_pos; }

  fpos<_StateT>& operator+=(streamoff __off) {
    _M_pos += __off;
    return *this;
  }
  fpos<_StateT>& operator-=(streamoff __off) {
    _M_pos -= __off;
    return *this;
  }

  fpos<_StateT> operator+(streamoff __off) {
    fpos<_StateT> __tmp(*this);
    __tmp += __off;
    return __tmp;
  }
  fpos<_StateT> operator-(streamoff __off) {
    fpos<_StateT> __tmp(*this);
    __tmp -= __off;
    return __tmp;
  }

public:
  _StateT state() const { return _M_st; }
  void state(_StateT __st) { _M_st = __st; }
private:
  streamoff _M_pos;
  _StateT _M_st;
};

typedef fpos<mbstate_t> streampos;
typedef fpos<mbstate_t> wstreampos;




template <class _CharT, class _IntT> class __char_traits_base {
public:
  typedef _CharT char_type;
  typedef _IntT int_type;

  typedef streamoff off_type;
  typedef streampos pos_type;



  typedef mbstate_t state_type;



  static void assign(char_type& __c1, const char_type& __c2) { __c1 = __c2; }
  static bool eq(const _CharT& __c1, const _CharT& __c2)
    { return __c1 == __c2; }
  static bool lt(const _CharT& __c1, const _CharT& __c2)
    { return __c1 < __c2; }

  static int compare(const _CharT* __s1, const _CharT* __s2, size_t __n) {
    for (size_t __i = 0; __i < __n; ++__i)
      if (!eq(__s1[__i], __s2[__i]))
        return __s1[__i] < __s2[__i] ? -1 : 1;
    return 0;
  }

  static size_t length(const _CharT* __s) {
    const _CharT _NullChar = _CharT();
    size_t __i;
    for (__i = 0; !eq(__s[__i], _NullChar); ++__i)
      {}
    return __i;
  }

  static const _CharT* find(const _CharT* __s, size_t __n, const _CharT& __c) {
    for ( ; __n > 0 ; ++__s, --__n)
      if (eq(*__s, __c))
        return __s;
    return 0;
  }


  static _CharT* move(_CharT* __s1, const _CharT* __s2, size_t _Sz) {
    return (_Sz == 0 ? __s1 : (_CharT*)memmove(__s1, __s2, _Sz * sizeof(_CharT)));
  }

  static _CharT* copy(_CharT* __s1, const _CharT* __s2, size_t __n) {
    return (__n == 0 ? __s1 :
     (_CharT*)memcpy(__s1, __s2, __n * sizeof(_CharT)));
    }

  static _CharT* assign(_CharT* __s, size_t __n, _CharT __c) {
    for (size_t __i = 0; __i < __n; ++__i)
      __s[__i] = __c;
    return __s;
  }

  static int_type not_eof(const int_type& __c) {
    return !eq_int_type(__c, eof()) ? __c : static_cast<int_type>(0);
  }

  static char_type to_char_type(const int_type& __c) {
    return (char_type)__c;
  }

  static int_type to_int_type(const char_type& __c) {
    return (int_type)__c;
  }

  static bool eq_int_type(const int_type& __c1, const int_type& __c2) {
    return __c1 == __c2;
  }

  static int_type eof() {
    return (int_type)-1;

  }
};






template <class _CharT> class char_traits
  : public __char_traits_base<_CharT, _CharT>
{};



template<> class char_traits<char>
  : public __char_traits_base<char, int>
{
public:
  typedef char char_type;
  typedef int int_type;

  typedef streamoff off_type;

  typedef streampos pos_type;
  typedef mbstate_t state_type;



  static char to_char_type(const int& __c) {
    return (char)(unsigned char)__c;
  }

  static int to_int_type(const char& __c) {
    return (unsigned char)__c;
  }

  static int compare(const char* __s1, const char* __s2, size_t __n)
    { return memcmp(__s1, __s2, __n); }

  static size_t length(const char* __s) { return strlen(__s); }

  static void assign(char& __c1, const char& __c2) { __c1 = __c2; }

  static char* assign(char* __s, size_t __n, char __c)
    { memset(__s, __c, __n); return __s; }
};



template<> class char_traits<wchar_t>
  : public __char_traits_base<wchar_t, wint_t>
{};


}
# 23 "c:/marmalade/5.2/s3e/h/std/c++/stl/_iosfwd.h" 2


namespace _STL {

class ios_base;

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_ios;

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_streambuf;

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_istream;

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_ostream;

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_iostream;

template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
class basic_stringbuf;

template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
class basic_istringstream;

template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
class basic_ostringstream;

template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
class basic_stringstream;

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_filebuf;

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_ifstream;

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_ofstream;

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_fstream;

template <class _CharT, class _Traits = char_traits<_CharT> >
class istreambuf_iterator;

template <class _CharT, class _Traits = char_traits<_CharT> >
class ostreambuf_iterator;

typedef basic_ios<char, char_traits<char> > ios;


typedef basic_ios<wchar_t, char_traits<wchar_t> > wios;



class locale;
# 95 "c:/marmalade/5.2/s3e/h/std/c++/stl/_iosfwd.h"
template <class _Facet> inline const _Facet& use_facet(const locale&);


template <class _CharT> class ctype;
template <class _CharT> class ctype_byname;
template <class _CharT> class collate;
template <class _CharT> class collate_byname;

template<> class ctype<char>;
template<> class ctype_byname<char>;
template<> class collate<char>;
template<> class collate_byname<char>;


template<> class ctype<wchar_t>;
template<> class ctype_byname<wchar_t>;
template<> class collate<wchar_t>;
template<> class collate_byname<wchar_t>;







typedef basic_istream<char, char_traits<char> > istream;
typedef basic_ostream<char, char_traits<char> > ostream;
typedef basic_iostream<char, char_traits<char> > iostream;
typedef basic_streambuf<char,char_traits<char> > streambuf;

typedef basic_stringbuf<char, char_traits<char>, allocator<char> > stringbuf;
typedef basic_istringstream<char, char_traits<char>, allocator<char> > istringstream;
typedef basic_ostringstream<char, char_traits<char>, allocator<char> > ostringstream;
typedef basic_stringstream<char, char_traits<char>, allocator<char> > stringstream;

typedef basic_filebuf<char, char_traits<char> > filebuf;
typedef basic_ifstream<char, char_traits<char> > ifstream;
typedef basic_ofstream<char, char_traits<char> > ofstream;
typedef basic_fstream<char, char_traits<char> > fstream;



typedef basic_streambuf<wchar_t, char_traits<wchar_t> > wstreambuf;
typedef basic_istream<wchar_t, char_traits<wchar_t> > wistream;
typedef basic_ostream<wchar_t, char_traits<wchar_t> > wostream;
typedef basic_iostream<wchar_t, char_traits<wchar_t> > wiostream;

typedef basic_stringbuf<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wstringbuf;
typedef basic_istringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wistringstream;
typedef basic_ostringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wostringstream;
typedef basic_stringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wstringstream;

typedef basic_filebuf<wchar_t, char_traits<wchar_t> > wfilebuf;
typedef basic_ifstream<wchar_t, char_traits<wchar_t> > wifstream;
typedef basic_ofstream<wchar_t, char_traits<wchar_t> > wofstream;
typedef basic_fstream<wchar_t, char_traits<wchar_t> > wfstream;


}
# 38 "c:/marmalade/5.2/s3e/h/std/c++/iosfwd" 2
# 24 "c:/marmalade/5.2/s3e/h/std/c++/stl/_string_fwd.h" 2


namespace _STL {


template <class _CharT,
          class _Traits = char_traits<_CharT>,
          class _Alloc = allocator<_CharT> >
class basic_string;







typedef basic_string<char, char_traits<char>, allocator<char> > string;


typedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wstring;



 const char*
__get_c_string(const string& __str);






}
# 32 "c:/marmalade/5.2/s3e/h/std/c++/stl/_string.h" 2



# 1 "c:/marmalade/5.2/s3e/h/std/c++/stl/_function.h" 1
# 34 "c:/marmalade/5.2/s3e/h/std/c++/stl/_function.h"
# 1 "c:/marmalade/5.2/s3e/h/std/c++/stl/_function_base.h" 1
# 37 "c:/marmalade/5.2/s3e/h/std/c++/stl/_function_base.h"
namespace _STL {

template <class _Arg, class _Result>
struct unary_function {
  typedef _Arg argument_type;
  typedef _Result result_type;
};

template <class _Arg1, class _Arg2, class _Result>
struct binary_function {
  typedef _Arg1 first_argument_type;
  typedef _Arg2 second_argument_type;
  typedef _Result result_type;
};

template <class _Tp>
struct equal_to : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x == __y; }
};

template <class _Tp>
struct not_equal_to : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x != __y; }
};

template <class _Tp>
struct greater : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x > __y; }
};

template <class _Tp>
struct less : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x < __y; }
};

template <class _Tp>
struct greater_equal : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x >= __y; }
};

template <class _Tp>
struct less_equal : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x <= __y; }
};

template <class _Tp>
less<_Tp> __less(_Tp* ) { return less<_Tp>(); }

template <class _Tp>
equal_to<_Tp> __equal_to(_Tp* ) { return equal_to<_Tp>(); }

template <class _Tp>
struct plus : public binary_function<_Tp,_Tp,_Tp> {
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x + __y; }
};

template <class _Tp>
struct minus : public binary_function<_Tp,_Tp,_Tp> {
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x - __y; }
};

template <class _Tp>
plus<_Tp> __plus(_Tp* ) { return plus<_Tp>(); }

template <class _Tp>
minus<_Tp> __minus(_Tp* ) { return minus<_Tp>(); }

template <class _Tp>
struct multiplies : public binary_function<_Tp,_Tp,_Tp> {
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x * __y; }
};

template <class _Tp>
struct divides : public binary_function<_Tp,_Tp,_Tp> {
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x / __y; }
};

template <class _Tp>
struct modulus : public binary_function<_Tp,_Tp,_Tp>
{
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x % __y; }
};

template <class _Tp>
struct negate : public unary_function<_Tp,_Tp>
{
  _Tp operator()(const _Tp& __x) const { return -__x; }
};

template <class _Tp>
struct logical_and : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x && __y; }
};

template <class _Tp>
struct logical_or : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x || __y; }
};

template <class _Tp>
struct logical_not : public unary_function<_Tp,bool>
{
  bool operator()(const _Tp& __x) const { return !__x; }
};

template <class _Pair>
struct _Select1st : public unary_function<_Pair, typename _Pair::first_type> {
  const typename _Pair::first_type& operator()(const _Pair& __x) const {
    return __x.first;
  }
};

template <class _Pair>
struct _Select2nd : public unary_function<_Pair, typename _Pair::second_type>
{
  const typename _Pair::second_type& operator()(const _Pair& __x) const {
    return __x.second;
  }
};


template <class _Arg1, class _Arg2>
struct _Project1st : public binary_function<_Arg1, _Arg2, _Arg1> {
  _Arg1 operator()(const _Arg1& __x, const _Arg2&) const { return __x; }
};

template <class _Arg1, class _Arg2>
struct _Project2nd : public binary_function<_Arg1, _Arg2, _Arg2> {
  _Arg2 operator()(const _Arg1&, const _Arg2& __y) const { return __y; }
};
# 188 "c:/marmalade/5.2/s3e/h/std/c++/stl/_function_base.h"
template <class _Tp>
struct _Identity : public unary_function<_Tp,_Tp> {
  const _Tp& operator()(const _Tp& __x) const { return __x; }
};

template <class _Result, class _Argument>
struct _Constant_unary_fun {
  typedef _Argument argument_type;
  typedef _Result result_type;
  result_type _M_val;

  _Constant_unary_fun(const result_type& __v) : _M_val(__v) {}
  const result_type& operator()(const _Argument&) const { return _M_val; }
};

template <class _Result, class _Arg1, class _Arg2>
struct _Constant_binary_fun {
  typedef _Arg1 first_argument_type;
  typedef _Arg2 second_argument_type;
  typedef _Result result_type;
  _Result _M_val;

  _Constant_binary_fun(const _Result& __v) : _M_val(__v) {}
  const result_type& operator()(const _Arg1&, const _Arg2&) const {
    return _M_val;
  }
};


template <class _Tp> inline _Tp __identity_element(plus<_Tp>) { return _Tp(0); }
template <class _Tp> inline _Tp __identity_element(multiplies<_Tp>) { return _Tp(1); }

}
# 35 "c:/marmalade/5.2/s3e/h/std/c++/stl/_function.h" 2


namespace _STL {



template <class _Tp> inline _Tp identity_element(plus<_Tp>) { return _Tp(0); }
template <class _Tp> inline _Tp identity_element(multiplies<_Tp>) { return _Tp(1); }
# 84 "c:/marmalade/5.2/s3e/h/std/c++/stl/_function.h"
template <class _Predicate>
class unary_negate :
    public unary_function<typename _Predicate::argument_type, bool> {
protected:
  _Predicate _M_pred;
public:
  explicit unary_negate(const _Predicate& __x) : _M_pred(__x) {}
  bool operator()(const typename _Predicate::argument_type& __x) const {
    return !_M_pred(__x);
  }
};

template <class _Predicate>
inline unary_negate<_Predicate>
not1(const _Predicate& __pred)
{
  return unary_negate<_Predicate>(__pred);
}

template <class _Predicate>
class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type,
                             bool> {
protected:
  _Predicate _M_pred;
public:
  explicit binary_negate(const _Predicate& __x) : _M_pred(__x) {}
  bool operator()(const typename _Predicate::first_argument_type& __x,
                  const typename _Predicate::second_argument_type& __y) const
  {
    return !_M_pred(__x, __y);
  }
};

template <class _Predicate>
inline binary_negate<_Predicate>
not2(const _Predicate& __pred)
{
  return binary_negate<_Predicate>(__pred);
}

template <class _Operation>
class binder1st :
    public unary_function<typename _Operation::second_argument_type,
                          typename _Operation::result_type > {
protected:
  _Operation _M_op;
  typename _Operation::first_argument_type _M_value;
public:
  binder1st(const _Operation& __x,
            const typename _Operation::first_argument_type& __y)
      : _M_op(__x), _M_value(__y) {}

  typename _Operation::result_type
  operator()(const typename _Operation::second_argument_type& __x) const {
    return _M_op(_M_value, __x);
  }

  typename _Operation::result_type
  operator()(typename _Operation::second_argument_type& __x) const {
    return _M_op(_M_value, __x);
  }
};

template <class _Operation, class _Tp>
inline binder1st<_Operation>
bind1st(const _Operation& __fn, const _Tp& __x)
{
  typedef typename _Operation::first_argument_type _Arg1_type;
  return binder1st<_Operation>(__fn, _Arg1_type(__x));
}

template <class _Operation>
class binder2nd
  : public unary_function<typename _Operation::first_argument_type,
                          typename _Operation::result_type> {
protected:
  _Operation _M_op;
  typename _Operation::second_argument_type value;
public:
  binder2nd(const _Operation& __x,
            const typename _Operation::second_argument_type& __y)
      : _M_op(__x), value(__y) {}

  typename _Operation::result_type
  operator()(const typename _Operation::first_argument_type& __x) const {
    return _M_op(__x, value);
  }

  typename _Operation::result_type
  operator()(typename _Operation::first_argument_type& __x) const {
    return _M_op(__x, value);
  }
};

template <class _Operation, class _Tp>
inline binder2nd<_Operation>
bind2nd(const _Operation& __fn, const _Tp& __x)
{
  typedef typename _Operation::second_argument_type _Arg2_type;
  return binder2nd<_Operation>(__fn, _Arg2_type(__x));
}




template <class _Operation1, class _Operation2>
class unary_compose :
  public unary_function<typename _Operation2::argument_type,
                        typename _Operation1::result_type> {
protected:
  _Operation1 _M_fn1;
  _Operation2 _M_fn2;
public:
  unary_compose(const _Operation1& __x, const _Operation2& __y)
    : _M_fn1(__x), _M_fn2(__y) {}

  typename _Operation1::result_type
  operator()(const typename _Operation2::argument_type& __x) const {
    return _M_fn1(_M_fn2(__x));
  }

  typename _Operation1::result_type
  operator()(typename _Operation2::argument_type& __x) const {
    return _M_fn1(_M_fn2(__x));
  }
};

template <class _Operation1, class _Operation2>
inline unary_compose<_Operation1,_Operation2>
compose1(const _Operation1& __fn1, const _Operation2& __fn2)
{
  return unary_compose<_Operation1,_Operation2>(__fn1, __fn2);
}

template <class _Operation1, class _Operation2, class _Operation3>
class binary_compose :
    public unary_function<typename _Operation2::argument_type,
                          typename _Operation1::result_type> {
protected:
  _Operation1 _M_fn1;
  _Operation2 _M_fn2;
  _Operation3 _M_fn3;
public:
  binary_compose(const _Operation1& __x, const _Operation2& __y,
                 const _Operation3& __z)
    : _M_fn1(__x), _M_fn2(__y), _M_fn3(__z) { }

  typename _Operation1::result_type
  operator()(const typename _Operation2::argument_type& __x) const {
    return _M_fn1(_M_fn2(__x), _M_fn3(__x));
  }

  typename _Operation1::result_type
  operator()(typename _Operation2::argument_type& __x) const {
    return _M_fn1(_M_fn2(__x), _M_fn3(__x));
  }
};

template <class _Operation1, class _Operation2, class _Operation3>
inline binary_compose<_Operation1, _Operation2, _Operation3>
compose2(const _Operation1& __fn1, const _Operation2& __fn2,
         const _Operation3& __fn3)
{
  return binary_compose<_Operation1,_Operation2,_Operation3>
    (__fn1, __fn2, __fn3);
}






template <class _Tp> struct identity : public _Identity<_Tp> {};

template <class _Pair> struct select1st : public _Select1st<_Pair> {};
template <class _Pair> struct select2nd : public _Select2nd<_Pair> {};

template <class _Arg1, class _Arg2>
struct project1st : public _Project1st<_Arg1, _Arg2> {};

template <class _Arg1, class _Arg2>
struct project2nd : public _Project2nd<_Arg1, _Arg2> {};






template <class _Result>
struct _Constant_void_fun {
  typedef _Result result_type;
  result_type _M_val;

  _Constant_void_fun(const result_type& __v) : _M_val(__v) {}
  const result_type& operator()() const { return _M_val; }
};


template <class _Result>
struct constant_void_fun : public _Constant_void_fun<_Result> {
  constant_void_fun(const _Result& __v) : _Constant_void_fun<_Result>(__v) {}
};

template <class _Result, class _Argument = _Result >
struct constant_unary_fun : public _Constant_unary_fun<_Result, _Argument>
{
  constant_unary_fun(const _Result& __v)
    : _Constant_unary_fun<_Result, _Argument>(__v) {}
};

template <class _Result, class _Arg1 = _Result, class _Arg2 = _Arg1 >
struct constant_binary_fun
  : public _Constant_binary_fun<_Result, _Arg1, _Arg2>
{
  constant_binary_fun(const _Result& __v)
    : _Constant_binary_fun<_Result, _Arg1, _Arg2>(__v) {}
};

template <class _Result>
inline constant_void_fun<_Result> constant0(const _Result& __val)
{
  return constant_void_fun<_Result>(__val);
}

template <class _Result>
inline constant_unary_fun<_Result,_Result> constant1(const _Result& __val)
{
  return constant_unary_fun<_Result,_Result>(__val);
}

template <class _Result>
inline constant_binary_fun<_Result,_Result,_Result>
constant2(const _Result& __val)
{
  return constant_binary_fun<_Result,_Result,_Result>(__val);
}



class subtractive_rng : public unary_function<unsigned long, unsigned long> {
private:
  unsigned long _M_table[55];
  unsigned long _M_index1;
  unsigned long _M_index2;
public:
  unsigned long operator()(unsigned long __limit) {
    _M_index1 = (_M_index1 + 1) % 55;
    _M_index2 = (_M_index2 + 1) % 55;
    _M_table[_M_index1] = _M_table[_M_index1] - _M_table[_M_index2];
    return _M_table[_M_index1] % __limit;
  }

  void _M_initialize(unsigned long __seed)
  {
    unsigned long __k = 1;
    _M_table[54] = __seed;
    unsigned long __i;
    for (__i = 0; __i < 54; __i++) {
        unsigned long __ii = (21 * (__i + 1) % 55) - 1;
        _M_table[__ii] = __k;
        __k = __seed - __k;
        __seed = _M_table[__ii];
    }
    for (int __loop = 0; __loop < 4; __loop++) {
        for (__i = 0; __i < 55; __i++)
            _M_table[__i] = _M_table[__i] - _M_table[(1 + __i + 30) % 55];
    }
    _M_index1 = 0;
    _M_index2 = 31;
  }

  subtractive_rng(unsigned int __seed) { _M_initialize(__seed); }
  subtractive_rng() { _M_initialize(161803398ul); }
};



}

# 1 "c:/marmalade/5.2/s3e/h/std/c++/stl/_function_adaptors.h" 1
# 58 "c:/marmalade/5.2/s3e/h/std/c++/stl/_function_adaptors.h"
namespace _STL {
# 411 "c:/marmalade/5.2/s3e/h/std/c++/stl/_function_adaptors.h"
template <class _Ret, class _Tp>
class mem_fun_t : public unary_function<_Tp*,_Ret> {
  typedef _Ret (_Tp::*__fun_type)(void);
public:
  explicit mem_fun_t(__fun_type __pf) : _M_f(__pf) {}
  _Ret operator()(_Tp* __p) const { return (__p->*_M_f)(); }
private:
  __fun_type _M_f;
};

template <class _Ret, class _Tp>
class const_mem_fun_t : public unary_function<const _Tp*,_Ret> {
  typedef _Ret (_Tp::*__fun_type)(void) const;
public:
  explicit const_mem_fun_t(__fun_type __pf) : _M_f(__pf) {}
  _Ret operator()(const _Tp* __p) const { return (__p->*_M_f)(); }
private:
  __fun_type _M_f;
};


template <class _Ret, class _Tp>
class mem_fun_ref_t : public unary_function<_Tp,_Ret> {
  typedef _Ret (_Tp::*__fun_type)(void);
public:
  explicit mem_fun_ref_t(__fun_type __pf) : _M_f(__pf) {}
  _Ret operator()(_Tp& __r) const { return (__r.*_M_f)(); }
private:
  __fun_type _M_f;
};

template <class _Ret, class _Tp>
class const_mem_fun_ref_t : public unary_function<_Tp,_Ret> {
  typedef _Ret (_Tp::*__fun_type)(void) const;
public:
  explicit const_mem_fun_ref_t(__fun_type __pf) : _M_f(__pf) {}
  _Ret operator()(const _Tp& __r) const { return (__r.*_M_f)(); }
private:
  __fun_type _M_f;
};

template <class _Ret, class _Tp, class _Arg>
class mem_fun1_t : public binary_function<_Tp*,_Arg,_Ret> {
  typedef _Ret (_Tp::*__fun_type)(_Arg);
public:
  explicit mem_fun1_t(__fun_type __pf) : _M_f(__pf) {}
  _Ret operator()(_Tp* __p, _Arg __x) const { return (__p->*_M_f)(__x); }
private:
  __fun_type _M_f;
};

template <class _Ret, class _Tp, class _Arg>
class const_mem_fun1_t : public binary_function<const _Tp*,_Arg,_Ret> {
  typedef _Ret (_Tp::*__fun_type)(_Arg) const;
public:
  explicit const_mem_fun1_t(__fun_type __pf) : _M_f(__pf) {}
  _Ret operator()(const _Tp* __p, _Arg __x) const
    { return (__p->*_M_f)(__x); }
private:
  __fun_type _M_f;
};

template <class _Ret, class _Tp, class _Arg>
class mem_fun1_ref_t : public binary_function<_Tp,_Arg,_Ret> {
  typedef _Ret (_Tp::*__fun_type)(_Arg);
public:
  explicit mem_fun1_ref_t(__fun_type __pf) : _M_f(__pf) {}
  _Ret operator()(_Tp& __r, _Arg __x) const { return (__r.*_M_f)(__x); }
private:
  __fun_type _M_f;
};

template <class _Ret, class _Tp, class _Arg>
class const_mem_fun1_ref_t : public binary_function<_Tp,_Arg,_Ret> {
  typedef _Ret (_Tp::*__fun_type)(_Arg) const;
public:
  explicit const_mem_fun1_ref_t(__fun_type __pf) : _M_f(__pf) {}
  _Ret operator()(const _Tp& __r, _Arg __x) const { return (__r.*_M_f)(__x); }
private:
  __fun_type _M_f;
};

template <class _Arg, class _Result>
class pointer_to_unary_function : public unary_function<_Arg, _Result> {
protected:
  _Result (*_M_ptr)(_Arg);
public:
  pointer_to_unary_function() {}
  explicit pointer_to_unary_function(_Result (*__x)(_Arg)) : _M_ptr(__x) {}
  _Result operator()(_Arg __x) const { return _M_ptr(__x); }
};

template <class _Arg1, class _Arg2, class _Result>
class pointer_to_binary_function :
  public binary_function<_Arg1,_Arg2,_Result> {
protected:
    _Result (*_M_ptr)(_Arg1, _Arg2);
public:
    pointer_to_binary_function() {}
    explicit pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) {}
    _Result operator()(_Arg1 __x, _Arg2 __y) const {
      return _M_ptr(__x, __y);
    }
};
# 737 "c:/marmalade/5.2/s3e/h/std/c++/stl/_function_adaptors.h"
template <class _Result, class _Tp>
inline mem_fun_t<_Result,_Tp>
mem_fun(_Result (_Tp::*__f)()) { return mem_fun_t<_Result,_Tp>(__f); }

template <class _Result, class _Tp>
inline const_mem_fun_t<_Result,_Tp>
mem_fun(_Result (_Tp::*__f)() const) { return const_mem_fun_t<_Result,_Tp>(__f); }

template <class _Result, class _Tp>
inline mem_fun_ref_t<_Result,_Tp>
mem_fun_ref(_Result (_Tp::*__f)()) { return mem_fun_ref_t<_Result,_Tp>(__f); }

template <class _Result, class _Tp>
inline const_mem_fun_ref_t<_Result,_Tp>
mem_fun_ref(_Result (_Tp::*__f)() const) { return const_mem_fun_ref_t<_Result,_Tp>(__f); }

template <class _Result, class _Tp, class _Arg>
inline mem_fun1_t<_Result,_Tp,_Arg>
mem_fun(_Result (_Tp::*__f)(_Arg)) { return mem_fun1_t<_Result,_Tp,_Arg>(__f); }

template <class _Result, class _Tp, class _Arg>
inline const_mem_fun1_t<_Result,_Tp,_Arg>
mem_fun(_Result (_Tp::*__f)(_Arg) const) { return const_mem_fun1_t<_Result,_Tp,_Arg>(__f); }

template <class _Result, class _Tp, class _Arg>
inline mem_fun1_ref_t<_Result,_Tp,_Arg>
mem_fun_ref(_Result (_Tp::*__f)(_Arg)) { return mem_fun1_ref_t<_Result,_Tp,_Arg>(__f); }

template <class _Result, class _Tp, class _Arg>
inline const_mem_fun1_ref_t<_Result,_Tp,_Arg>
mem_fun_ref(_Result (_Tp::*__f)(_Arg) const) { return const_mem_fun1_ref_t<_Result,_Tp,_Arg>(__f); }




template <class _Result, class _Tp, class _Arg>
inline mem_fun1_t<_Result,_Tp,_Arg>
mem_fun1(_Result (_Tp::*__f)(_Arg)) { return mem_fun1_t<_Result,_Tp,_Arg>(__f); }

template <class _Result, class _Tp, class _Arg>
inline const_mem_fun1_t<_Result,_Tp,_Arg>
mem_fun1(_Result (_Tp::*__f)(_Arg) const) { return const_mem_fun1_t<_Result,_Tp,_Arg>(__f); }

template <class _Result, class _Tp, class _Arg>
inline mem_fun1_ref_t<_Result,_Tp,_Arg>
mem_fun1_ref(_Result (_Tp::*__f)(_Arg)) { return mem_fun1_ref_t<_Result,_Tp,_Arg>(__f); }

template <class _Result, class _Tp, class _Arg>
inline const_mem_fun1_ref_t<_Result,_Tp,_Arg>
mem_fun1_ref(_Result (_Tp::*__f)(_Arg) const) { return const_mem_fun1_ref_t<_Result,_Tp,_Arg>(__f); }





template <class _Arg, class _Result>
inline pointer_to_unary_function<_Arg, _Result>
ptr_fun(_Result (*__f)(_Arg))
{ return pointer_to_unary_function<_Arg, _Result>(__f); }

template <class _Arg1, class _Arg2, class _Result>
inline pointer_to_binary_function<_Arg1,_Arg2,_Result>
ptr_fun(_Result (*__f)(_Arg1, _Arg2))
{ return pointer_to_binary_function<_Arg1,_Arg2,_Result>(__f); }

}
# 366 "c:/marmalade/5.2/s3e/h/std/c++/stl/_function.h" 2
# 36 "c:/marmalade/5.2/s3e/h/std/c++/stl/_string.h" 2


# 1 "c:/marmalade/5.2/s3e/h/std/c++/stl/_ctraits_fns.h" 1
# 28 "c:/marmalade/5.2/s3e/h/std/c++/stl/_ctraits_fns.h"
namespace _STL {

template <class _Traits>
struct _Eq_traits
  : public binary_function<typename _Traits::char_type,
                           typename _Traits::char_type,
                           bool>
{
  bool operator()(const typename _Traits::char_type& __x,
                  const typename _Traits::char_type& __y) const
    { return _Traits::eq(__x, __y); }
};

template <class _Traits>
struct _Eq_char_bound
  : public unary_function<typename _Traits::char_type, bool>
{
  typename _Traits::char_type __val;
  _Eq_char_bound(typename _Traits::char_type __c) : __val(__c) {}
  bool operator()(const typename _Traits::char_type& __x) const
    { return _Traits::eq(__x, __val); }
};

template <class _Traits>
struct _Neq_char_bound
  : public unary_function<typename _Traits::char_type, bool>
{
  typename _Traits::char_type __val;
  _Neq_char_bound(typename _Traits::char_type __c) : __val(__c) {}
  bool operator()(const typename _Traits::char_type& __x) const
    { return !_Traits::eq(__x, __val); }
};

template <class _Traits>
struct _Eq_int_bound
  : public unary_function<typename _Traits::char_type, bool>
{
  typename _Traits::int_type __val;

  _Eq_int_bound(typename _Traits::int_type __c) : __val(__c) {}
  bool operator()(const typename _Traits::char_type& __x) const
    { return _Traits::eq_int_type(_Traits::to_int_type(__x), __val); }
};
# 85 "c:/marmalade/5.2/s3e/h/std/c++/stl/_ctraits_fns.h"
}
# 39 "c:/marmalade/5.2/s3e/h/std/c++/stl/_string.h" 2
# 79 "c:/marmalade/5.2/s3e/h/std/c++/stl/_string.h"
namespace _STL {







template <class _Traits> struct _Not_within_traits
  : public unary_function<typename _Traits::char_type, bool> {
  typedef typename _Traits::char_type _CharT;
  const _CharT* _M_first;
  const _CharT* _M_last;

  _Not_within_traits(const typename _Traits::char_type* __f,
       const typename _Traits::char_type* __l)
    : _M_first(__f), _M_last(__l) {}

  bool operator()(const typename _Traits::char_type& __x) const {
    return find_if(_M_first, _M_last,
                   _Eq_char_bound<_Traits>(__x)) == _M_last;
  }
};
# 114 "c:/marmalade/5.2/s3e/h/std/c++/stl/_string.h"
template <class _Tp, class _Alloc> class _String_base {
public:
 
  typedef typename _Alloc_traits<_Tp, _Alloc>::allocator_type allocator_type;
  _Tp* _M_start;
  _Tp* _M_finish;
  _STLP_alloc_proxy<_Tp*, _Tp, allocator_type> _M_end_of_storage;

  void _M_allocate_block(size_t);
  void _M_deallocate_block()
    { _M_end_of_storage.deallocate(_M_start, _M_end_of_storage._M_data - _M_start); }

  size_t max_size() const { return (size_t(-1) / sizeof(_Tp)) - 1; }

  _String_base(const allocator_type& __a)
    : _M_start(0), _M_finish(0), _M_end_of_storage(__a, (_Tp*)0) {}

  _String_base(const allocator_type& __a, size_t __n)
    : _M_start(0), _M_finish(0), _M_end_of_storage(__a, (_Tp*)0)
    { _M_allocate_block(__n); }

  ~_String_base() { _M_deallocate_block(); }

  void _M_throw_length_error() const;
  void _M_throw_out_of_range() const;
};
# 164 "c:/marmalade/5.2/s3e/h/std/c++/stl/_string.h"
struct _String_reserve_t {};

template <class _CharT, class _Traits, class _Alloc> class basic_string : protected _String_base<_CharT,_Alloc> {
private:
  typedef _String_base<_CharT,_Alloc> _Base;
  typedef basic_string<_CharT, _Traits, _Alloc> _Self;


  typedef typename _Is_integer<_CharT>::_Integral _Char_Is_Integral;
public:
  typedef _CharT value_type;
  typedef _Traits traits_type;

  typedef value_type* pointer;
  typedef const value_type* const_pointer;
  typedef value_type& reference;
  typedef const value_type& const_reference;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef random_access_iterator_tag _Iterator_category;

  typedef const value_type* const_iterator;
  typedef value_type* iterator;

  typedef _STL::reverse_iterator<const_iterator> const_reverse_iterator; typedef _STL::reverse_iterator<iterator> reverse_iterator;







  static const size_t npos = ~(size_t)0;


  typedef _String_reserve_t _Reserve_t;
# 212 "c:/marmalade/5.2/s3e/h/std/c++/stl/_string.h"
public:
  typedef typename _String_base<_CharT,_Alloc>::allocator_type allocator_type;

  allocator_type get_allocator() const {
    return (const allocator_type&)this->_M_end_of_storage;
  }

  basic_string();

  explicit basic_string(const allocator_type& __a)
    : _String_base<_CharT,_Alloc>(__a, 8) {
    _M_terminate_string();
  }

  basic_string(_Reserve_t, size_t __n,
               const allocator_type& __a = allocator_type())
    : _String_base<_CharT,_Alloc>(__a, __n + 1) {
    _M_terminate_string();
  }

  basic_string(const basic_string<_CharT, _Traits, _Alloc>&);

  basic_string(const _Self& __s, size_type __pos, size_type __n = npos,
               const allocator_type& __a = allocator_type())
    : _String_base<_CharT,_Alloc>(__a) {
    if (__pos > __s.size())
      this->_M_throw_out_of_range();
    else
      _M_range_initialize(__s._M_start + __pos,
                          __s._M_start + __pos + (min) (__n, __s.size() - __pos));
  }

  basic_string(const _CharT* __s, size_type __n,
               const allocator_type& __a = allocator_type())
    : _String_base<_CharT,_Alloc>(__a)
    {
     
      _M_range_initialize(__s, __s + __n);
    }

  basic_string(const _CharT* __s,
               const allocator_type& __a = allocator_type());

  basic_string(size_type __n, _CharT __c,
               const allocator_type& __a = allocator_type())
    : _String_base<_CharT,_Alloc>(__a, __n + 1)
  {
    this->_M_finish = uninitialized_fill_n(this->_M_start, __n, __c);
    _M_terminate_string();
  }
# 274 "c:/marmalade/5.2/s3e/h/std/c++/stl/_string.h"
  template <class _InputIterator> basic_string(_InputIterator __f, _InputIterator __l,
               const allocator_type & __a = allocator_type())
    : _String_base<_CharT,_Alloc>(__a)
  {
    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
    _M_initialize_dispatch(__f, __l, _Integral());
  }
# 305 "c:/marmalade/5.2/s3e/h/std/c++/stl/_string.h"
  ~basic_string() { _STL::_Destroy(this->_M_start, this->_M_finish + 1); }

  _Self& operator=(const _Self& __s) {
    if (&__s != this)
      assign(__s._M_start, __s._M_finish);
    return *this;
  }

  _Self& operator=(const _CharT* __s) {
   
    return assign(__s, __s + traits_type::length(__s));
  }

  _Self& operator=(_CharT __c)
    { return assign(static_cast<size_type>(1), __c); }

  static _CharT _M_null() {
    return _CharT();
  }

private:


  void _M_construct_null_aux(_CharT* __p, const __false_type&) {
    _Construct(__p);
  }
  void _M_construct_null_aux(_CharT* __p, const __true_type&) {
    *__p = 0;
  }

  void _M_construct_null(_CharT* __p) {
    _M_construct_null_aux(__p, _Char_Is_Integral());
  }

private:



  void _M_terminate_string_aux(const __false_type&) {
    {
      _M_construct_null(this->_M_finish);
    }
    ;
  }

  void _M_terminate_string_aux(const __true_type&) {
    *(this->_M_finish)=0;
  }

  void _M_terminate_string() {
    _M_terminate_string_aux(_Char_Is_Integral());
  }






  template <class _InputIter>
  bool _M_inside(_InputIter __i) const {
    const _CharT* __s = static_cast<const _CharT*>(&(*__i));
    return (__s >= this->_M_start) && (__s < this->_M_finish);
  }




  template <class _InputIter> void _M_range_initialize(_InputIter __f, _InputIter __l,
                           const input_iterator_tag &) {
    this->_M_allocate_block(8);
    _M_construct_null(this->_M_finish);
    {
      append(__f, __l);
    }
    ;
  }

  template <class _ForwardIter> void _M_range_initialize(_ForwardIter __f, _ForwardIter __l,
                           const forward_iterator_tag &) {
    difference_type __n = distance(__f, __l);
    this->_M_allocate_block(__n + 1);
    this->_M_finish = uninitialized_copy(__f, __l, this->_M_start);
    _M_terminate_string();
  }

  template <class _InputIter> void _M_range_initialize(_InputIter __f, _InputIter __l) {
    _M_range_initialize(__f, __l, typename iterator_traits< _InputIter >::iterator_category());
  }

  template <class _Integer> void _M_initialize_dispatch(_Integer __n, _Integer __x, const __true_type&) {
    this->_M_allocate_block(__n + 1);
    this->_M_finish = uninitialized_fill_n(this->_M_start, __n, __x);
    _M_terminate_string();
  }

  template <class _InputIter> void _M_initialize_dispatch(_InputIter __f, _InputIter __l, const __false_type&) {
     _M_range_initialize(__f, __l);
  }
# 415 "c:/marmalade/5.2/s3e/h/std/c++/stl/_string.h"
public:
  iterator begin() { return this->_M_start; }
  iterator end() { return this->_M_finish; }
  const_iterator begin() const { return this->_M_start; }
  const_iterator end() const { return this->_M_finish; }

  reverse_iterator rbegin()
    { return reverse_iterator(this->_M_finish); }
  reverse_iterator rend()
    { return reverse_iterator(this->_M_start); }
  const_reverse_iterator rbegin() const
    { return const_reverse_iterator(this->_M_finish); }
  const_reverse_iterator rend() const
    { return const_reverse_iterator(this->_M_start); }

public:
  size_type size() const { return this->_M_finish - this->_M_start; }
  size_type length() const { return size(); }

  size_t max_size() const { return _Base::max_size(); }


  void resize(size_type __n, _CharT __c) {
    if (__n <= size())
      erase(begin() + __n, end());
    else
      append(__n - size(), __c);
  }
  void resize(size_type __n) { resize(__n, _M_null()); }

  void reserve(size_type = 0);

  size_type capacity() const { return (this->_M_end_of_storage._M_data - this->_M_start) - 1; }

  void clear() {
    if (!empty()) {
      _Traits::assign(*(this->_M_start), _M_null());
      _STL::_Destroy(this->_M_start+1, this->_M_finish+1);
      this->_M_finish = this->_M_start;
    }
  }

  bool empty() const { return this->_M_start == this->_M_finish; }

public:

  const_reference operator[](size_type __n) const
    { return *(this->_M_start + __n); }
  reference operator[](size_type __n)
    { return *(this->_M_start + __n); }

  const_reference at(size_type __n) const {
    if (__n >= size())
      this->_M_throw_out_of_range();
    return *(this->_M_start + __n);
  }

  reference at(size_type __n) {
    if (__n >= size())
      this->_M_throw_out_of_range();
    return *(this->_M_start + __n);
  }

public:

  _Self& operator+=(const _Self& __s) { return append(__s); }
  _Self& operator+=(const _CharT* __s) { return append(__s); }
  _Self& operator+=(_CharT __c) { push_back(__c); return *this; }

  _Self& append(const _Self& __s)
    { return append(__s._M_start, __s._M_finish); }

  _Self& append(const _Self& __s,
                       size_type __pos, size_type __n)
  {
    if (__pos > __s.size())
      this->_M_throw_out_of_range();
    return append(__s._M_start + __pos,
                  __s._M_start + __pos + (min) (__n, __s.size() - __pos));
  }

  _Self& append(const _CharT* __s, size_type __n)
    { return append(__s, __s+__n); }
  _Self& append(const _CharT* __s)
    { return append(__s, __s + traits_type::length(__s)); }
  _Self& append(size_type __n, _CharT __c);





  template <class _InputIter> _Self& append(_InputIter __first, _InputIter __last) {
    typedef typename _Is_integer<_InputIter>::_Integral _Integral;
    return _M_append_dispatch(__first, __last, _Integral());
  }







  void push_back(_CharT __c) {
    if (this->_M_finish + 1 == this->_M_end_of_storage._M_data)
      reserve(size() + (max)(size(), static_cast<size_type>(1)));
    _M_construct_null(this->_M_finish + 1);
    _Traits::assign(*(this->_M_finish), __c);
    ++this->_M_finish;
  }

  void pop_back() {
    _Traits::assign(*(this->_M_finish - 1), _M_null());
    _STL::_Destroy(this->_M_finish);
    --this->_M_finish;
  }

private:



  template <class _InputIter> _Self& append(_InputIter __first, _InputIter __last, const input_iterator_tag &)
  {
   for ( ; __first != __last ; ++__first)
     push_back(*__first);
   return *this;
 }

  template <class _ForwardIter> _Self& append(_ForwardIter __first, _ForwardIter __last,
                       const forward_iterator_tag &) {
    if (__first != __last) {
     const size_type __old_size = size();
     difference_type __n = distance(__first, __last);
     if (static_cast<size_type>(__n) > max_size() || __old_size > max_size() - static_cast<size_type>(__n))
       this->_M_throw_length_error();
     if (__old_size + __n > capacity()) {
       const size_type __len = __old_size +
                             (max)(__old_size, static_cast<size_type>(__n)) + 1;
       pointer __new_start = this->_M_end_of_storage.allocate(__len);
       pointer __new_finish = __new_start;
       {
         __new_finish = uninitialized_copy(this->_M_start, this->_M_finish, __new_start);
         __new_finish = uninitialized_copy(__first, __last, __new_finish);
         _M_construct_null(__new_finish);
       }
       ;

       _STL::_Destroy(this->_M_start, this->_M_finish + 1);
       this->_M_deallocate_block();
       this->_M_start = __new_start;
       this->_M_finish = __new_finish;
       this->_M_end_of_storage._M_data = __new_start + __len;
     }
     else {
       _ForwardIter __f1 = __first;
       ++__f1;
       uninitialized_copy(__f1, __last, this->_M_finish + 1);
       {
         _M_construct_null(this->_M_finish + __n);
       }
       ;
       _Traits::assign(*end(), *__first);
       this->_M_finish += __n;
     }
   }
   return *this;
 }

  template <class _Integer> _Self& _M_append_dispatch(_Integer __n, _Integer __x, const __true_type&) {
    return append((size_type) __n, (_CharT) __x);
  }

  template <class _InputIter> _Self& _M_append_dispatch(_InputIter __f, _InputIter __l,
                                   const __false_type&) {
    return append(__f, __l, typename iterator_traits< _InputIter >::iterator_category());
  }



public:

  _Self& assign(const _Self& __s)
    { return assign(__s._M_start, __s._M_finish); }

  _Self& assign(const _Self& __s,
                       size_type __pos, size_type __n) {
    if (__pos > __s.size())
      this->_M_throw_out_of_range();
    return assign(__s._M_start + __pos,
                  __s._M_start + __pos + (min) (__n, __s.size() - __pos));
  }

  _Self& assign(const _CharT* __s, size_type __n)
    { return assign(__s, __s + __n); }

  _Self& assign(const _CharT* __s)
    { return assign(__s, __s + _Traits::length(__s)); }

  _Self& assign(size_type __n, _CharT __c);



private:

  template <class _Integer>
  _Self& _M_assign_dispatch(_Integer __n, _Integer __x, const __true_type&) {
    return assign((size_type) __n, (_CharT) __x);
  }

  template <class _InputIter>
  _Self& _M_assign_dispatch(_InputIter __f, _InputIter __l,
       const __false_type&) {
    pointer __cur = this->_M_start;
    while (__f != __l && __cur != this->_M_finish) {
      _Traits::assign(*__cur, *__f);
      ++__f;
      ++__cur;
    }
    if (__f == __l)
      erase(__cur, end());
    else
      append(__f, __l);
    return *this;
  }

public:


  template <class _InputIter> _Self& assign(_InputIter __first, _InputIter __last) {
    typedef typename _Is_integer<_InputIter>::_Integral _Integral;
    return _M_assign_dispatch(__first, __last, _Integral());
  }



  _Self& assign(const _CharT* __f, const _CharT* __l)
  {
    ptrdiff_t __n = __l - __f;
    if (static_cast<size_type>(__n) <= size()) {
      _Traits::copy(this->_M_start, __f, __n);
      erase(begin() + __n, end());
    }
    else {
      _Traits::copy(this->_M_start, __f, size());
      append(__f + size(), __l);
    }
    return *this;
  }

public:

  _Self& insert(size_type __pos, const _Self& __s) {
    if (__pos > size())
      this->_M_throw_out_of_range();
    if (size() > max_size() - __s.size())
      this->_M_throw_length_error();
    insert(begin() + __pos, __s._M_start, __s._M_finish);
    return *this;
  }

  _Self& insert(size_type __pos, const _Self& __s,
                       size_type __beg, size_type __n) {
    if (__pos > size() || __beg > __s.size())
      this->_M_throw_out_of_range();
    size_type __len = (min) (__n, __s.size() - __beg);
    if (size() > max_size() - __len)
      this->_M_throw_length_error();
    insert(begin() + __pos,
           __s._M_start + __beg, __s._M_start + __beg + __len);
    return *this;
  }

  _Self& insert(size_type __pos, const _CharT* __s, size_type __n) {
   
    if (__pos > size())
      this->_M_throw_out_of_range();
    if (size() > max_size() - __n)
      this->_M_throw_length_error();
    insert(begin() + __pos, __s, __s + __n);
    return *this;
  }

  _Self& insert(size_type __pos, const _CharT* __s) {
   
    if (__pos > size())
      this->_M_throw_out_of_range();
    size_type __len = _Traits::length(__s);
    if (size() > max_size() - __len)
      this->_M_throw_length_error();
    insert(this->_M_start + __pos, __s, __s + __len);
    return *this;
  }

  _Self& insert(size_type __pos, size_type __n, _CharT __c) {
    if (__pos > size())
      this->_M_throw_out_of_range();
    if (size() > max_size() - __n)
      this->_M_throw_length_error();
    insert(begin() + __pos, __n, __c);
    return *this;
  }

  iterator insert(iterator __p, _CharT __c) {
   
    if (__p == end()) {
      push_back(__c);
      return this->_M_finish - 1;
    }
    else
      return _M_insert_aux(__p, __c);
  }

  void insert(iterator __p, size_t __n, _CharT __c);





  template <class _InputIter> void insert(iterator __p, _InputIter __first, _InputIter __last) {
    typedef typename _Is_integer<_InputIter>::_Integral _Integral;
    _M_insert_dispatch(__p, __first, __last, _Integral());
  }







private:



  template <class _InputIter> void insert(iterator __p, _InputIter __first, _InputIter __last,
       const input_iterator_tag &)
  {
   for ( ; __first != __last; ++__first) {
     __p = insert(__p, *__first);
     ++__p;
   }
 }

  template <class _ForwardIter>
  void insert(iterator __position, _ForwardIter __first, _ForwardIter __last,
       const forward_iterator_tag &) {
    if (__first != __last) {
      difference_type __n = distance(__first, __last);
      if (this->_M_end_of_storage._M_data - this->_M_finish >= __n + 1) {
 const difference_type __elems_after = this->_M_finish - __position;
 pointer __old_finish = this->_M_finish;
 if (__elems_after >= __n) {
   uninitialized_copy((this->_M_finish - __n) + 1, this->_M_finish + 1,
        this->_M_finish + 1);
   this->_M_finish += __n;
   _Traits::move(__position + __n,
   __position, (__elems_after - __n) + 1);
   _M_move(__first, __last, __position);
       }
 else {
   _ForwardIter __mid = __first;
   advance(__mid, __elems_after + 1);
   uninitialized_copy(__mid, __last, this->_M_finish + 1);
   this->_M_finish += __n - __elems_after;
         {
           uninitialized_copy(__position, __old_finish + 1, this->_M_finish);
           this->_M_finish += __elems_after;
         }
         ;

         _M_move(__first, __mid, __position);
 }
      }
      else {
 const size_type __old_size = size();
 const size_type __len
   = __old_size + (max)(__old_size, static_cast<size_type>(__n)) + 1;
       pointer __new_start = this->_M_end_of_storage.allocate(__len);
       pointer __new_finish = __new_start;
       {
         __new_finish = uninitialized_copy(this->_M_start, __position, __new_start);
         __new_finish = uninitialized_copy(__first, __last, __new_finish);
         __new_finish
           = uninitialized_copy(__position, this->_M_finish, __new_finish);
         _M_construct_null(__new_finish);
       }
       ;

       _STL::_Destroy(this->_M_start, this->_M_finish + 1);
       this->_M_deallocate_block();
       this->_M_start = __new_start;
       this->_M_finish = __new_finish;
       this->_M_end_of_storage._M_data = __new_start + __len;
     }
    }
  }

  template <class _Integer> void _M_insert_dispatch(iterator __p, _Integer __n, _Integer __x,
                          const __true_type&) {
    insert(__p, (size_type) __n, (_CharT) __x);
  }

  template <class _InputIter> void _M_insert_dispatch(iterator __p, _InputIter __first, _InputIter __last,
                          const __false_type&) {
    insert(__p, __first, __last, typename iterator_traits< _InputIter >::iterator_category());
  }

  template <class _InputIterator> void
  _M_copy(_InputIterator __first, _InputIterator __last, pointer __result) {
    for ( ; __first != __last; ++__first, ++__result)
      _Traits::assign(*__result, *__first);
  }

  template <class _InputIterator>
  void _M_move(_InputIterator __first, _InputIterator __last, pointer __result) {

    for ( ; __first != __last; ++__first, ++__result)
      _Traits::assign(*__result, *__first);
  }



  pointer _M_insert_aux(pointer, _CharT);

  void
  _M_copy(const _CharT* __first, const _CharT* __last, _CharT* __result) {
    _Traits::copy(__result, __first, __last - __first);
  }
  void _M_move(const _CharT* __first, const _CharT* __last, _CharT* __result) {
    _Traits::move(__result, __first, __last - __first);
  }

public:

  _Self& erase(size_type __pos = 0, size_type __n = npos) {
    if (__pos > size())
      this->_M_throw_out_of_range();
    erase(begin() + __pos, begin() + __pos + (min) (__n, size() - __pos));
    return *this;
  }

  iterator erase(iterator __position) {

    _Traits::move(__position, __position + 1, this->_M_finish - __position);
    _STL::_Destroy(this->_M_finish);
    --this->_M_finish;
    return __position;
  }

  iterator erase(iterator __first, iterator __last) {
    if (__first != __last) {

      traits_type::move(__first, __last, (this->_M_finish - __last) + 1);
      pointer __new_finish = this->_M_finish - (__last - __first);
      _STL::_Destroy(__new_finish + 1, this->_M_finish + 1);
      this->_M_finish = __new_finish;
    }
    return __first;
  }

public:

  _Self& replace(size_type __pos, size_type __n,
                        const _Self& __s) {
    if (__pos > size())
      this->_M_throw_out_of_range();
    const size_type __len = (min) (__n, size() - __pos);
    if (size() - __len >= max_size() - __s.size())
      this->_M_throw_length_error();
    return replace(begin() + __pos, begin() + __pos + __len,
                   __s._M_start, __s._M_finish);
  }

  _Self& replace(size_type __pos1, size_type __n1,
                        const _Self& __s,
                        size_type __pos2, size_type __n2) {
    if (__pos1 > size() || __pos2 > __s.size())
      this->_M_throw_out_of_range();
    const size_type __len1 = (min) (__n1, size() - __pos1);
    const size_type __len2 = (min) (__n2, __s.size() - __pos2);
    if (size() - __len1 >= max_size() - __len2)
      this->_M_throw_length_error();
    return replace(begin() + __pos1, begin() + __pos1 + __len1,
                   __s._M_start + __pos2, __s._M_start + __pos2 + __len2);
  }

  _Self& replace(size_type __pos, size_type __n1,
                        const _CharT* __s, size_type __n2) {
   
    if (__pos > size())
      this->_M_throw_out_of_range();
    const size_type __len = (min) (__n1, size() - __pos);
    if (__n2 > max_size() || size() - __len >= max_size() - __n2)
      this->_M_throw_length_error();
    return replace(begin() + __pos, begin() + __pos + __len,
                   __s, __s + __n2);
  }

  _Self& replace(size_type __pos, size_type __n1,
                        const _CharT* __s) {
   
    if (__pos > size())
      this->_M_throw_out_of_range();
    const size_type __len = (min) (__n1, size() - __pos);
    const size_type __n2 = _Traits::length(__s);
    if (__n2 > max_size() || size() - __len >= max_size() - __n2)
      this->_M_throw_length_error();
    return replace(begin() + __pos, begin() + __pos + __len,
                   __s, __s + _Traits::length(__s));
  }

  _Self& replace(size_type __pos, size_type __n1,
                        size_type __n2, _CharT __c) {
    if (__pos > size())
      this->_M_throw_out_of_range();
    const size_type __len = (min) (__n1, size() - __pos);
    if (__n2 > max_size() || size() - __len >= max_size() - __n2)
      this->_M_throw_length_error();
    return replace(begin() + __pos, begin() + __pos + __len, __n2, __c);
  }

  _Self& replace(iterator __first, iterator __last,
                        const _Self& __s)
    { return replace(__first, __last, __s._M_start, __s._M_finish); }

  _Self& replace(iterator __first, iterator __last,
                        const _CharT* __s, size_type __n)
    { return replace(__first, __last, __s, __s + __n); }

  _Self& replace(iterator __first, iterator __last,
                        const _CharT* __s) {
   
    return replace(__first, __last, __s, __s + _Traits::length(__s));
  }

  _Self& replace(iterator __first, iterator __last,
                        size_type __n, _CharT __c);




  template <class _InputIter> _Self& replace(iterator __first, iterator __last,
                        _InputIter __f, _InputIter __l) {
    typedef typename _Is_integer<_InputIter>::_Integral _Integral;
    return _M_replace_dispatch(__first, __last, __f, __l, _Integral());
  }





private:



  template <class _Integer> _Self& _M_replace_dispatch(iterator __first, iterator __last,
                                    _Integer __n, _Integer __x,
                                    const __true_type&) {
    return replace(__first, __last, (size_type) __n, (_CharT) __x);
  }

  template <class _InputIter> _Self& _M_replace_dispatch(iterator __first, iterator __last,
                                    _InputIter __f, _InputIter __l,
                                    const __false_type&) {
    return replace(__first, __last, __f, __l, typename iterator_traits< _InputIter >::iterator_category());
  }

  template <class _InputIter> _Self& replace(iterator __first, iterator __last,
                        _InputIter __f, _InputIter __l, const input_iterator_tag &) {
   for ( ; __first != __last && __f != __l; ++__first, ++__f)
     _Traits::assign(*__first, *__f);

   if (__f == __l)
     erase(__first, __last);
   else
     insert(__last, __f, __l);
   return *this;
 }

  template <class _InputIter>
  _Self& replace(iterator __first, iterator __last,
                 _InputIter __f, _InputIter __l, const random_access_iterator_tag &) {

    if (_M_inside(__f)) {
      difference_type __n = __l - __f;
      const difference_type __len = __last - __first;
      if (__len >= __n) {
        _M_move(__f, __l, __first);
        erase(__first + __n, __last);
      }
      else {
        _InputIter __m = __f + __len;
        if ((__l <= __first) || (__f >= __last)) {

          _M_copy(__f, __m, __first);
          insert(__last, __m, __l);
        }
        else {

      const difference_type __off_dest = __first - this->begin();
      const difference_type __off_src = __f - this->begin();
      insert(__last, __m, __l);
      _Traits::move(begin() + __off_dest, begin() + __off_src, __n);
        }
      }
      return *this;
    }
   else {
    return replace(__first, __last, __f, __l, forward_iterator_tag());
   }
  }


  template <class _ForwardIter> _Self& replace(iterator __first, iterator __last,
                        _ForwardIter __f, _ForwardIter __l,
                        const forward_iterator_tag &) {
   difference_type __n = distance(__f, __l);
   const difference_type __len = __last - __first;
   if (__len >= __n) {
     _M_copy(__f, __l, __first);
     erase(__first + __n, __last);
   }
   else {
     _ForwardIter __m = __f;
     advance(__m, __len);
     _M_copy(__f, __m, __first);
     insert(__last, __m, __l);
   }
   return *this;
 }



public:

  size_type copy(_CharT* __s, size_type __n, size_type __pos = 0) const {
   
    if (__pos > size())
      this->_M_throw_out_of_range();
    const size_type __len = (min) (__n, size() - __pos);
    _Traits::copy(__s, this->_M_start + __pos, __len);
    return __len;
  }

  void swap(_Self& __s) {
    _STL::swap(this->_M_start, __s._M_start);
    _STL::swap(this->_M_finish, __s._M_finish);
    _STL::swap(this->_M_end_of_storage, __s._M_end_of_storage);
  }

public:

  const _CharT* c_str() const { return this->_M_start; }
  const _CharT* data() const { return this->_M_start; }

public:

  size_type find(const _Self& __s, size_type __pos = 0) const
    { return find(__s._M_start, __pos, __s.size()); }

  size_type find(const _CharT* __s, size_type __pos = 0) const
    { return find(__s, __pos, _Traits::length(__s)); }

  size_type find(const _CharT* __s, size_type __pos, size_type __n) const;


  size_type find(_CharT __c) const
    { return find(__c, 0) ; }
  size_type find(_CharT __c, size_type __pos ) const;

public:

  size_type rfind(const _Self& __s, size_type __pos = npos) const
    { return rfind(__s._M_start, __pos, __s.size()); }

  size_type rfind(const _CharT* __s, size_type __pos = npos) const
    { return rfind(__s, __pos, _Traits::length(__s)); }

  size_type rfind(const _CharT* __s, size_type __pos, size_type __n) const;
  size_type rfind(_CharT __c, size_type __pos = npos) const;

public:

  size_type find_first_of(const _Self& __s, size_type __pos = 0) const
    { return find_first_of(__s._M_start, __pos, __s.size()); }

  size_type find_first_of(const _CharT* __s, size_type __pos = 0) const
    { return find_first_of(__s, __pos, _Traits::length(__s)); }

  size_type find_first_of(const _CharT* __s, size_type __pos,
                          size_type __n) const;

  size_type find_first_of(_CharT __c, size_type __pos = 0) const
    { return find(__c, __pos); }

public:

  size_type find_last_of(const _Self& __s,
                         size_type __pos = npos) const
    { return find_last_of(__s._M_start, __pos, __s.size()); }

  size_type find_last_of(const _CharT* __s, size_type __pos = npos) const
    { return find_last_of(__s, __pos, _Traits::length(__s)); }

  size_type find_last_of(const _CharT* __s, size_type __pos,
                         size_type __n) const;

  size_type find_last_of(_CharT __c, size_type __pos = npos) const {
    return rfind(__c, __pos);
  }

public:

  size_type find_first_not_of(const _Self& __s,
                              size_type __pos = 0) const
    { return find_first_not_of(__s._M_start, __pos, __s.size()); }

  size_type find_first_not_of(const _CharT* __s, size_type __pos = 0) const
    { return find_first_not_of(__s, __pos, _Traits::length(__s)); }

  size_type find_first_not_of(const _CharT* __s, size_type __pos,
                              size_type __n) const;

  size_type find_first_not_of(_CharT __c, size_type __pos = 0) const;

public:

  size_type find_last_not_of(const _Self& __s,
                             size_type __pos = npos) const
    { return find_last_not_of(__s._M_start, __pos, __s.size()); }

  size_type find_last_not_of(const _CharT* __s, size_type __pos = npos) const
    { return find_last_not_of(__s, __pos, _Traits::length(__s)); }

  size_type find_last_not_of(const _CharT* __s, size_type __pos,
                             size_type __n) const;

  size_type find_last_not_of(_CharT __c, size_type __pos = npos) const;

public:

  _Self substr(size_type __pos = 0, size_type __n = npos) const {
    if (__pos > size())
      this->_M_throw_out_of_range();
    return _Self(this->_M_start + __pos,
                        this->_M_start + __pos + (min) (__n, size() - __pos));
  }

public:

  int compare(const _Self& __s) const
    { return _M_compare(this->_M_start, this->_M_finish, __s._M_start, __s._M_finish); }

  int compare(size_type __pos1, size_type __n1,
              const _Self& __s) const {
    if (__pos1 > size())
      this->_M_throw_out_of_range();
    return _M_compare(this->_M_start + __pos1,
                      this->_M_start + __pos1 + (min) (__n1, size() - __pos1),
                      __s._M_start, __s._M_finish);
  }

  int compare(size_type __pos1, size_type __n1,
              const _Self& __s,
              size_type __pos2, size_type __n2) const {
    if (__pos1 > size() || __pos2 > __s.size())
      this->_M_throw_out_of_range();
    return _M_compare(this->_M_start + __pos1,
                      this->_M_start + __pos1 + (min) (__n1, size() - __pos1),
                      __s._M_start + __pos2,
                      __s._M_start + __pos2 + (min) (__n2, __s.size() - __pos2));
  }

  int compare(const _CharT* __s) const {
   
      return _M_compare(this->_M_start, this->_M_finish, __s, __s + _Traits::length(__s));
  }

  int compare(size_type __pos1, size_type __n1, const _CharT* __s) const {
   
    if (__pos1 > size())
      this->_M_throw_out_of_range();
    return _M_compare(this->_M_start + __pos1,
                      this->_M_start + __pos1 + (min) (__n1, size() - __pos1),
                      __s, __s + _Traits::length(__s));
  }

  int compare(size_type __pos1, size_type __n1, const _CharT* __s,
              size_type __n2) const {
   
    if (__pos1 > size())
      this->_M_throw_out_of_range();
    return _M_compare(this->_M_start + __pos1,
                      this->_M_start + __pos1 + (min) (__n1, size() - __pos1),
                      __s, __s + __n2);
  }

public:

  static int _M_compare(const _CharT* __f1, const _CharT* __l1,
                        const _CharT* __f2, const _CharT* __l2) {
    const ptrdiff_t __n1 = __l1 - __f1;
    const ptrdiff_t __n2 = __l2 - __f2;
    const int cmp = _Traits::compare(__f1, __f2, (min) (__n1, __n2));
    return cmp != 0 ? cmp : (__n1 < __n2 ? -1 : (__n1 > __n2 ? 1 : 0));
  }
};
# 1237 "c:/marmalade/5.2/s3e/h/std/c++/stl/_string.h"
template <class _CharT, class _Traits, class _Alloc> inline basic_string<_CharT,_Traits,_Alloc>
operator+(const basic_string<_CharT,_Traits,_Alloc>& __s,
          const basic_string<_CharT,_Traits,_Alloc>& __y)
{
  typedef basic_string<_CharT,_Traits,_Alloc> _Str;
  typedef typename _Str::_Reserve_t _Reserve_t;


  _Str __result = _Str(_Reserve_t(),__s.size() + __y.size());



  __result.append(__s);
  __result.append(__y);
  return __result;
}





template <class _CharT, class _Traits, class _Alloc> inline basic_string<_CharT,_Traits,_Alloc>
operator+(const _CharT* __s,
          const basic_string<_CharT,_Traits,_Alloc>& __y) {
 
  typedef basic_string<_CharT,_Traits,_Alloc> _Str;
  typedef typename _Str::_Reserve_t _Reserve_t;
  const size_t __n = _Traits::length(__s);

  _Str __result = _Str(_Reserve_t(), __n + __y.size());



  __result.append(__s, __s + __n);
  __result.append(__y);
  return __result;
}

template <class _CharT, class _Traits, class _Alloc> inline basic_string<_CharT,_Traits,_Alloc>
operator+(_CharT __c,
          const basic_string<_CharT,_Traits,_Alloc>& __y) {
  typedef basic_string<_CharT,_Traits,_Alloc> _Str;
  typedef typename _Str::_Reserve_t _Reserve_t;

  _Str __result = _Str(_Reserve_t(), 1 + __y.size());



  __result.push_back(__c);
  __result.append(__y);
  return __result;
}

template <class _CharT, class _Traits, class _Alloc> inline basic_string<_CharT,_Traits,_Alloc>
operator+(const basic_string<_CharT,_Traits,_Alloc>& __x,
          const _CharT* __s) {
 
  typedef basic_string<_CharT,_Traits,_Alloc> _Str;
  typedef typename _Str::_Reserve_t _Reserve_t;
  const size_t __n = _Traits::length(__s);

  _Str __result = _Str(_Reserve_t(), __x.size() + __n, __x.get_allocator());



  __result.append(__x);
  __result.append(__s, __s + __n);
  return __result;
}

template <class _CharT, class _Traits, class _Alloc> inline basic_string<_CharT,_Traits,_Alloc>
operator+(const basic_string<_CharT,_Traits,_Alloc>& __x,
          const _CharT __c) {
  typedef basic_string<_CharT,_Traits,_Alloc> _Str;
  typedef typename _Str::_Reserve_t _Reserve_t;

  _Str __result = _Str(_Reserve_t(), __x.size() + 1, __x.get_allocator());



  __result.append(__x);
  __result.push_back(__c);
  return __result;
}





template <class _CharT, class _Traits, class _Alloc> inline bool
operator==(const basic_string<_CharT,_Traits,_Alloc>& __x,
           const basic_string<_CharT,_Traits,_Alloc>& __y) {
  return __x.size() == __y.size() && _Traits::compare(__x.data(), __y.data(), __x.size()) == 0;
}

template <class _CharT, class _Traits, class _Alloc> inline bool
operator==(const _CharT* __s,
           const basic_string<_CharT,_Traits,_Alloc>& __y) {
 
  size_t __n = _Traits::length(__s);
  return __n == __y.size() && _Traits::compare(__s, __y.data(), __n) == 0;
}

template <class _CharT, class _Traits, class _Alloc> inline bool
operator==(const basic_string<_CharT,_Traits,_Alloc>& __x,
           const _CharT* __s) {
 
  size_t __n = _Traits::length(__s);
  return __x.size() == __n && _Traits::compare(__x.data(), __s, __n) == 0;
}



template <class _CharT, class _Traits, class _Alloc> inline bool
operator<(const basic_string<_CharT,_Traits,_Alloc>& __x,
          const basic_string<_CharT,_Traits,_Alloc>& __y) {
  return basic_string<_CharT,_Traits,_Alloc> ::_M_compare(__x.begin(), __x.end(),
   __y.begin(), __y.end()) < 0;
}

template <class _CharT, class _Traits, class _Alloc> inline bool
operator<(const _CharT* __s,
          const basic_string<_CharT,_Traits,_Alloc>& __y) {
 
  size_t __n = _Traits::length(__s);
  return basic_string<_CharT,_Traits,_Alloc> ::_M_compare(__s, __s + __n, __y.begin(), __y.end()) < 0;
}

template <class _CharT, class _Traits, class _Alloc> inline bool
operator<(const basic_string<_CharT,_Traits,_Alloc>& __x,
          const _CharT* __s) {
 
  size_t __n = _Traits::length(__s);
  return basic_string<_CharT,_Traits,_Alloc> ::_M_compare(__x.begin(), __x.end(), __s, __s + __n) < 0;
}



template <class _CharT, class _Traits, class _Alloc> inline bool
operator!=(const basic_string<_CharT,_Traits,_Alloc>& __x,
           const basic_string<_CharT,_Traits,_Alloc>& __y) {
  return !(__x == __y);
}

template <class _CharT, class _Traits, class _Alloc> inline bool
operator>(const basic_string<_CharT,_Traits,_Alloc>& __x,
          const basic_string<_CharT,_Traits,_Alloc>& __y) {
  return __y < __x;
}

template <class _CharT, class _Traits, class _Alloc> inline bool
operator<=(const basic_string<_CharT,_Traits,_Alloc>& __x,
           const basic_string<_CharT,_Traits,_Alloc>& __y) {
  return !(__y < __x);
}

template <class _CharT, class _Traits, class _Alloc> inline bool
operator>=(const basic_string<_CharT,_Traits,_Alloc>& __x,
           const basic_string<_CharT,_Traits,_Alloc>& __y) {
  return !(__x < __y);
}



template <class _CharT, class _Traits, class _Alloc> inline bool
operator!=(const _CharT* __s,
           const basic_string<_CharT,_Traits,_Alloc>& __y) {
 
  return !(__s == __y);
}

template <class _CharT, class _Traits, class _Alloc> inline bool
operator!=(const basic_string<_CharT,_Traits,_Alloc>& __x,
           const _CharT* __s) {
 
  return !(__x == __s);
}

template <class _CharT, class _Traits, class _Alloc> inline bool
operator>(const _CharT* __s,
          const basic_string<_CharT,_Traits,_Alloc>& __y) {
 
  return __y < __s;
}

template <class _CharT, class _Traits, class _Alloc> inline bool
operator>(const basic_string<_CharT,_Traits,_Alloc>& __x,
          const _CharT* __s) {
 
  return __s < __x;
}

template <class _CharT, class _Traits, class _Alloc> inline bool
operator<=(const _CharT* __s,
           const basic_string<_CharT,_Traits,_Alloc>& __y) {
 
  return !(__y < __s);
}

template <class _CharT, class _Traits, class _Alloc> inline bool
operator<=(const basic_string<_CharT,_Traits,_Alloc>& __x,
           const _CharT* __s) {
 
  return !(__s < __x);
}

template <class _CharT, class _Traits, class _Alloc> inline bool
operator>=(const _CharT* __s,
           const basic_string<_CharT,_Traits,_Alloc>& __y) {
 
  return !(__s < __y);
}

template <class _CharT, class _Traits, class _Alloc> inline bool
operator>=(const basic_string<_CharT,_Traits,_Alloc>& __x,
           const _CharT* __s) {
 
  return !(__x < __s);
}






template <class _CharT, class _Traits, class _Alloc> inline void
swap(basic_string<_CharT,_Traits,_Alloc>& __x,
     basic_string<_CharT,_Traits,_Alloc>& __y) {
  __x.swap(__y);
}



template <class _CharT, class _Traits, class _Alloc> void _S_string_copy(const basic_string<_CharT,_Traits,_Alloc>& __s,
                    _CharT* __buf,
                    size_t __n);
# 1483 "c:/marmalade/5.2/s3e/h/std/c++/stl/_string.h"
}






# 1 "c:/marmalade/5.2/s3e/h/std/c++/stl/_string.c" 1
# 47 "c:/marmalade/5.2/s3e/h/std/c++/stl/_string.c"
namespace _STL {
# 57 "c:/marmalade/5.2/s3e/h/std/c++/stl/_string.c"
template <class _CharT, class _Traits, class _Alloc> void basic_string<_CharT,_Traits,_Alloc>::reserve(size_type __res_arg) {

  if (__res_arg >= capacity())
    {
      if (__res_arg > max_size())
 this->_M_throw_length_error();

      size_type __n = __res_arg + 1;
      pointer __new_start = this->_M_end_of_storage.allocate(__n);
      pointer __new_finish = __new_start;

      {
 __new_finish = uninitialized_copy(this->_M_start, this->_M_finish, __new_start);
 _M_construct_null(__new_finish);
      }
      ;


      _STL::_Destroy(this->_M_start, this->_M_finish + 1);
      this->_M_deallocate_block();
      this->_M_start = __new_start;
      this->_M_finish = __new_finish;
      this->_M_end_of_storage._M_data = __new_start + __n;
    }
}

template <class _CharT, class _Traits, class _Alloc> basic_string<_CharT,_Traits,_Alloc>& basic_string<_CharT,_Traits,_Alloc>::append(size_type __n, _CharT __c) {
  if (__n > max_size() || size() > max_size() - __n)
    this->_M_throw_length_error();
  if (size() + __n > capacity())
    reserve(size() + (max)(size(), __n));
  if (__n > 0) {
    uninitialized_fill_n(this->_M_finish + 1, __n - 1, __c);
    {
      _M_construct_null(this->_M_finish + __n);
    }
    ;
    _Traits::assign(*end(), __c);
    this->_M_finish += __n;
  }
  return *this;
}
# 144 "c:/marmalade/5.2/s3e/h/std/c++/stl/_string.c"
template <class _CharT, class _Traits, class _Alloc>
basic_string<_CharT,_Traits,_Alloc>&
basic_string<_CharT,_Traits,_Alloc>::assign(size_type __n, _CharT __c) {
  if (__n <= size()) {
    _Traits::assign(this->_M_start, __n, __c);
    erase(begin() + __n, end());
  }
  else {
    _Traits::assign(this->_M_start, size(), __c);
    append(__n - size(), __c);
  }
  return *this;
}

template <class _CharT, class _Traits, class _Alloc> _CharT*
basic_string<_CharT,_Traits,_Alloc> ::_M_insert_aux(_CharT* __p,
                  _CharT __c)
{
  pointer __new_pos = __p;
  if (this->_M_finish + 1 < this->_M_end_of_storage._M_data) {
    _M_construct_null(this->_M_finish + 1);
    _Traits::move(__p + 1, __p, this->_M_finish - __p);
    _Traits::assign(*__p, __c);
    ++this->_M_finish;
  }
  else {
    const size_type __old_len = size();
    const size_type __len = __old_len +
                            (max)(__old_len, static_cast<size_type>(1)) + 1;
    pointer __new_start = this->_M_end_of_storage.allocate(__len);
    pointer __new_finish = __new_start;
    {
      __new_pos = uninitialized_copy(this->_M_start, __p, __new_start);
      _Construct(__new_pos, __c);
      __new_finish = __new_pos + 1;
      __new_finish = uninitialized_copy(__p, this->_M_finish, __new_finish);
      _M_construct_null(__new_finish);
    }
    ;

    _STL::_Destroy(this->_M_start, this->_M_finish + 1);
    this->_M_deallocate_block();
    this->_M_start = __new_start;
    this->_M_finish = __new_finish;
    this->_M_end_of_storage._M_data = __new_start + __len;
  }
  return __new_pos;
}

template <class _CharT, class _Traits, class _Alloc> void basic_string<_CharT,_Traits,_Alloc>::insert(iterator __position,
           size_t __n, _CharT __c)
{
  if (__n != 0) {
    if (size_type(this->_M_end_of_storage._M_data - this->_M_finish) >= __n + 1) {
      const size_type __elems_after = this->_M_finish - __position;
      pointer __old_finish = this->_M_finish;
      if (__elems_after >= __n) {
        uninitialized_copy((this->_M_finish - __n) + 1, this->_M_finish + 1,
                           this->_M_finish + 1);
        this->_M_finish += __n;
        _Traits::move(__position + __n,
                      __position, (__elems_after - __n) + 1);
        _Traits::assign(__position, __n, __c);
      }
      else {
        uninitialized_fill_n(this->_M_finish + 1, __n - __elems_after - 1, __c);
        this->_M_finish += __n - __elems_after;
        {
          uninitialized_copy(__position, __old_finish + 1, this->_M_finish);
          this->_M_finish += __elems_after;
        }
        ;

        _Traits::assign(__position, __elems_after + 1, __c);
      }
    }
    else {
      const size_type __old_size = size();
      const size_type __len = __old_size + (max)(__old_size, __n) + 1;
      pointer __new_start = this->_M_end_of_storage.allocate(__len);
      pointer __new_finish = __new_start;
      {
        __new_finish = uninitialized_copy(this->_M_start, __position, __new_start);
        __new_finish = uninitialized_fill_n(__new_finish, __n, __c);
        __new_finish = uninitialized_copy(__position, this->_M_finish,
                                          __new_finish);
        _M_construct_null(__new_finish);
      }
      ;

      _STL::_Destroy(this->_M_start, this->_M_finish + 1);
      this->_M_deallocate_block();
      this->_M_start = __new_start;
      this->_M_finish = __new_finish;
      this->_M_end_of_storage._M_data = __new_start + __len;
    }
  }
}
# 303 "c:/marmalade/5.2/s3e/h/std/c++/stl/_string.c"
template <class _CharT, class _Traits, class _Alloc> basic_string<_CharT,_Traits,_Alloc>& basic_string<_CharT,_Traits,_Alloc> ::replace(iterator __first, iterator __last, size_type __n, _CharT __c)
{
  size_type __len = (size_type)(__last - __first);

  if (__len >= __n) {
    _Traits::assign(__first, __n, __c);
    erase(__first + __n, __last);
  }
  else {
    _Traits::assign(__first, __len, __c);
    insert(__last, __n - __len, __c);
  }
  return *this;
}
# 340 "c:/marmalade/5.2/s3e/h/std/c++/stl/_string.c"
template <class _CharT, class _Traits, class _Alloc> typename basic_string<_CharT,_Traits,_Alloc>::size_type
basic_string<_CharT,_Traits,_Alloc> ::find(const _CharT* __s, size_type __pos, size_type __n) const
{
  if (__pos + __n > size())
    return npos;
  else {
    const const_pointer __result =
      _STL::search((const _CharT*)this->_M_start + __pos, (const _CharT*)this->_M_finish,
   __s, __s + __n, _Eq_traits<_Traits>());
    return __result != this->_M_finish ? __result - this->_M_start : npos;
  }
}

template <class _CharT, class _Traits, class _Alloc> typename basic_string<_CharT,_Traits,_Alloc>::size_type
basic_string<_CharT,_Traits,_Alloc> ::find(_CharT __c, size_type __pos) const
{
  if (__pos >= size())
    return npos;
  else {
    const const_pointer __result =
      _STL::find_if((const _CharT*)this->_M_start + __pos, (const _CharT*)this->_M_finish,
    _Eq_char_bound<_Traits>(__c));
    return __result != this->_M_finish ? __result - this->_M_start : npos;
  }
}

template <class _CharT, class _Traits, class _Alloc> typename basic_string<_CharT,_Traits,_Alloc>::size_type
basic_string<_CharT,_Traits,_Alloc> ::rfind(const _CharT* __s, size_type __pos, size_type __n) const
{
  const size_t __len = size();

  if (__n > __len)
    return npos;
  else if (__n == 0)
    return (min) (__len, __pos);
  else {
    const_pointer __last = this->_M_start + (min) (__len - __n, __pos) + __n;
    const_pointer __result = _STL::find_end((const_pointer)this->_M_start, __last,
       __s, __s + __n,
       _Eq_traits<_Traits>());
    return __result != __last ? __result - this->_M_start : npos;
  }
}

template <class _CharT, class _Traits, class _Alloc> typename basic_string<_CharT,_Traits,_Alloc>::size_type
basic_string<_CharT,_Traits,_Alloc> ::rfind(_CharT __c, size_type __pos) const
{
  const size_type __len = size();

  if (__len < 1)
    return npos;
  else {
    const const_iterator __last = begin() + (min) (__len - 1, __pos) + 1;
    const_reverse_iterator __rresult =
      _STL::find_if(const_reverse_iterator(__last), rend(),
              _Eq_char_bound<_Traits>(__c));
    return __rresult != rend() ? (__rresult.base() - 1) - begin() : npos;
  }
}

template <class _CharT, class _Traits, class _Alloc> typename basic_string<_CharT,_Traits,_Alloc>::size_type
basic_string<_CharT,_Traits,_Alloc> ::find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
{
  if (__pos >= size())
    return npos;
  else {
    const_iterator __result = __find_first_of(begin() + __pos, end(),
                                              __s, __s + __n,
                                              _Eq_traits<_Traits>());
    return __result != end() ? __result - begin() : npos;
  }
}


template <class _CharT, class _Traits, class _Alloc> typename basic_string<_CharT,_Traits,_Alloc>::size_type
basic_string<_CharT,_Traits,_Alloc> ::find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
{
  const size_type __len = size();

  if (__len < 1)
    return npos;
  else {
    const const_iterator __last = begin() + (min) (__len - 1, __pos) + 1;
    const const_reverse_iterator __rresult =
      __find_first_of(const_reverse_iterator(__last), rend(),
                      __s, __s + __n,
                      _Eq_traits<_Traits>());
    return __rresult != rend() ? (__rresult.base() - 1) - begin() : npos;
  }
}


template <class _CharT, class _Traits, class _Alloc> typename basic_string<_CharT,_Traits,_Alloc>::size_type
basic_string<_CharT,_Traits,_Alloc> ::find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
{
  typedef typename _Traits::char_type _CharType;
  if (__pos > size())
    return npos;
  else {
    const_pointer __result = _STL::find_if((const _CharT*)this->_M_start + __pos,
          (const _CharT*)this->_M_finish,
                                _Not_within_traits<_Traits>((const _CharType*)__s,
           (const _CharType*)__s + __n));
    return __result != this->_M_finish ? __result - this->_M_start : npos;
  }
}

template <class _CharT, class _Traits, class _Alloc> typename basic_string<_CharT,_Traits,_Alloc>::size_type
basic_string<_CharT,_Traits,_Alloc> ::find_first_not_of(_CharT __c, size_type __pos) const
{
  if (__pos > size())
    return npos;
  else {
    const_pointer __result = _STL::find_if((const _CharT*)this->_M_start + __pos, (const _CharT*)this->_M_finish,
      _Neq_char_bound<_Traits>(__c));
    return __result != this->_M_finish ? __result - this->_M_start : npos;
  }
}

template <class _CharT, class _Traits, class _Alloc> typename basic_string<_CharT,_Traits,_Alloc>::size_type
basic_string<_CharT,_Traits,_Alloc> ::find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
{
  typedef typename _Traits::char_type _CharType;
  const size_type __len = size();

  if (__len < 1)
    return npos;
  else {
    const_iterator __last = begin() + (min) (__len - 1, __pos) + 1;
    const_reverse_iterator __rlast = const_reverse_iterator(__last);
    const_reverse_iterator __rresult =
      _STL::find_if(__rlast, rend(),
    _Not_within_traits<_Traits>((const _CharType*)__s,
           (const _CharType*)__s + __n));
    return __rresult != rend() ? (__rresult.base() - 1) - begin() : npos;
  }
}

template <class _CharT, class _Traits, class _Alloc> typename basic_string<_CharT,_Traits,_Alloc>::size_type
basic_string<_CharT, _Traits, _Alloc> ::find_last_not_of(_CharT __c, size_type __pos) const
{
  const size_type __len = size();

  if (__len < 1)
    return npos;
  else {
    const_iterator __last = begin() + (min) (__len - 1, __pos) + 1;
    const_reverse_iterator __rlast = const_reverse_iterator(__last);
    const_reverse_iterator __rresult =
      _STL::find_if(__rlast, rend(),
    _Neq_char_bound<_Traits>(__c));
    return __rresult != rend() ? (__rresult.base() - 1) - begin() : npos;
  }
}

template <class _CharT, class _Traits, class _Alloc> void _S_string_copy(const basic_string<_CharT,_Traits,_Alloc>& __s,
                    _CharT* __buf,
                    size_t __n)
{
  if (__n > 0) {
    __n = (min) (__n - 1, __s.size());
    _STL::copy(__s.begin(), __s.begin() + __n, __buf);
    __buf[__n] = _CharT();
  }
}
}





# 1 "c:/marmalade/5.2/s3e/h/std/c++/stl/_string_fwd.c" 1
# 512 "c:/marmalade/5.2/s3e/h/std/c++/stl/_string.c" 2






# 1 "c:/marmalade/5.2/s3e/h/std/c++/stl/_range_errors.h" 1
# 36 "c:/marmalade/5.2/s3e/h/std/c++/stl/_range_errors.h"
namespace _STL {
void __stl_throw_range_error(const char* __msg);
void __stl_throw_out_of_range(const char* __msg);
void __stl_throw_length_error(const char* __msg);
void __stl_throw_invalid_argument(const char* __msg);
void __stl_throw_overflow_error(const char* __msg);
}
# 519 "c:/marmalade/5.2/s3e/h/std/c++/stl/_string.c" 2
namespace _STL {


template <class _Tp, class _Alloc> void _String_base<_Tp,_Alloc>::_M_throw_length_error() const {
    __stl_throw_length_error("basic_string");
}

template <class _Tp, class _Alloc> void _String_base<_Tp, _Alloc>::_M_throw_out_of_range() const {
    __stl_throw_out_of_range("basic_string");
}

template <class _Tp, class _Alloc> void _String_base<_Tp, _Alloc>::_M_allocate_block(size_t __n) {
  if ((__n <= (max_size()+1)) && (__n>0)){
    _M_start = _M_end_of_storage.allocate(__n);
    _M_finish = _M_start;
    _M_end_of_storage._M_data = _M_start + __n;
  }
    else
      _M_throw_length_error();
}

template <class _CharT, class _Traits, class _Alloc> basic_string<_CharT, _Traits, _Alloc>::basic_string()
  : _String_base<_CharT,_Alloc>(allocator_type()) {
  this->_M_start = this->_M_end_of_storage.allocate(8);
  this->_M_finish = this->_M_start;
  this->_M_end_of_storage._M_data = this->_M_start + 8;
  _M_terminate_string();
}


template <class _CharT, class _Traits, class _Alloc> basic_string<_CharT, _Traits, _Alloc>::basic_string(const _CharT* __s,
          const allocator_type& __a)
  : _String_base<_CharT,_Alloc>(__a)
{
 
    _M_range_initialize(__s, __s + traits_type::length(__s));
}


template <class _CharT, class _Traits, class _Alloc> basic_string<_CharT, _Traits, _Alloc>::basic_string(const basic_string<_CharT, _Traits, _Alloc> & __s)
  : _String_base<_CharT,_Alloc>(__s.get_allocator())
{
  _M_range_initialize(__s._M_start, __s._M_finish);
}





}
# 1491 "c:/marmalade/5.2/s3e/h/std/c++/stl/_string.h" 2


# 1 "c:/marmalade/5.2/s3e/h/std/c++/stl/_string_io.h" 1
# 36 "c:/marmalade/5.2/s3e/h/std/c++/stl/_string_io.h"
namespace _STL {



template <class _CharT, class _Traits, class _Alloc>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const basic_string<_CharT,_Traits,_Alloc>& __s);

template <class _CharT, class _Traits, class _Alloc>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           basic_string<_CharT,_Traits,_Alloc>& __s);

template <class _CharT, class _Traits, class _Alloc>
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT,_Traits,_Alloc>& __s,
        _CharT __delim);



template <class _CharT, class _Traits, class _Alloc>
inline basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT,_Traits,_Alloc>& __s)
{
  return getline(__is, __s, __is.widen('\n'));
}


template <class _CharT, class _Traits>
bool
__stlp_string_fill(basic_ostream<_CharT, _Traits>& __os,
                  basic_streambuf<_CharT, _Traits>* __buf,
                  size_t __n);
# 114 "c:/marmalade/5.2/s3e/h/std/c++/stl/_string_io.h"
}




# 1 "c:/marmalade/5.2/s3e/h/std/c++/stl/_string_io.c" 1
# 9 "c:/marmalade/5.2/s3e/h/std/c++/stl/_string_io.c"
# 1 "c:/marmalade/5.2/s3e/h/std/c++/stl/_ctype.h" 1
# 26 "c:/marmalade/5.2/s3e/h/std/c++/stl/_ctype.h"
# 1 "c:/marmalade/5.2/s3e/h/std/c++/stl/c_locale.h" 1
# 109 "c:/marmalade/5.2/s3e/h/std/c++/stl/c_locale.h"
struct _Locale_ctype;
struct _Locale_numeric;
struct _Locale_time;
struct _Locale_collate;
struct _Locale_monetary;
struct _Locale_messages;
# 27 "c:/marmalade/5.2/s3e/h/std/c++/stl/_ctype.h" 2


# 1 "c:/marmalade/5.2/s3e/h/std/c++/stl/_locale.h" 1
# 46 "c:/marmalade/5.2/s3e/h/std/c++/stl/_locale.h"
namespace _STL {

class _Locale_impl;
class _Locale;
class locale;
class ios_base;


template <class _CharT>
bool
__locale_do_operator_call (const locale* __that,
                           const basic_string<_CharT, char_traits<_CharT>, allocator<_CharT> >& __x,
                           const basic_string<_CharT, char_traits<_CharT>, allocator<_CharT> >& __y);



class locale {
public:


  class facet : private _Refcount_Base {
  protected:
    explicit facet(size_t __no_del = 0) : _Refcount_Base(1), _M_delete(__no_del == 0) {}
    virtual ~facet();
    friend class locale;
    friend class _Locale_impl;
    friend class _Locale;

  private:
    facet(const facet& __f) : _Refcount_Base(1), _M_delete(__f._M_delete == 0) {};
    void operator=(const facet&);

  private:
    const bool _M_delete;
  };




  class

  id {
    friend class locale;
    friend class _Locale_impl;
  public:
    size_t _M_index;
    static size_t _S_max;
  };

  typedef int category;



  static const category

    none = 0x000,
    collate = 0x010,
    ctype = 0x020,
    monetary = 0x040,
    numeric = 0x100,
    time = 0x200,
    messages = 0x400,
    all = collate | ctype | monetary | numeric | time | messages



  ;


  locale();
  locale(const locale&) ;
  explicit locale(const char *);
  locale(const locale&, const char*, category);


  locale(_Locale_impl*);
  locale(_Locale_impl*, bool);

public:


  template <class _Facet>
  locale(const locale& __loc, _Facet* __f) : _M_impl(0)
    {

      new(this) locale(__loc._M_impl, __f != 0);
      if (__f != 0)
        this->_M_insert(__f, _Facet::id);
    }


  locale(const locale&, const locale&, category);
  ~locale() ;
  const locale& operator=(const locale&) ;


  template <class _Facet> locale combine(const locale& __loc) {
    locale __result(__loc._M_impl, true);
    if (facet* __f = __loc._M_get_facet(_Facet::id)) {
      __result._M_insert(__f, _Facet::id);
      __f->_M_incr();
    }
    else
      _M_throw_runtime_error();
    return __result;
  }


  string name() const;

  bool operator==(const locale&) const;
  bool operator!=(const locale&) const;







  template <class _CharT, class _Traits, class _Alloc>
  bool operator()(const basic_string<_CharT, _Traits, _Alloc>& __x,
                  const basic_string<_CharT, _Traits, _Alloc>& __y) const {
    return __locale_do_operator_call(this, __x, __y);
  }



  static locale global(const locale&);
  static const locale& classic();

public:
  facet* _M_get_facet(const id&) const;

  facet* _M_use_facet(const id&) const;
  static void _M_throw_runtime_error(const char* = 0);
  static void _S_initialize();
  static void _S_uninitialize();

private:

  void _M_insert(facet* __f, id& __id);


  friend class _Locale_impl;
  friend class _Locale;
  friend class ios_base;

private:
  _Locale_impl* _M_impl;
};
# 205 "c:/marmalade/5.2/s3e/h/std/c++/stl/_locale.h"
template <class _Facet> inline const _Facet& use_facet(const locale& __loc)

{
  return *static_cast<const _Facet*>(__loc._M_use_facet(_Facet::id));
}
# 219 "c:/marmalade/5.2/s3e/h/std/c++/stl/_locale.h"
template <class _Facet> inline bool has_facet(const locale& __loc)

{
  return (__loc._M_get_facet(_Facet::id) != 0);
}






}
# 30 "c:/marmalade/5.2/s3e/h/std/c++/stl/_ctype.h" 2





namespace _STL {

class ctype_base {
public:
  enum mask {
    space = 0x8,
    print = ((0x0100|0x1|0x2) | 0x4 | 0x40 | 0x10),
    cntrl = 0x20,
    upper = 0x1,
    lower = 0x2,
    alpha = ( (0x0100|0x1|0x2) & ~ (0x1 | 0x2 )),
    digit = 0x4,
    punct = 0x10,
    xdigit = 0x80,
    alnum = alpha | digit,
    graph = alnum | punct
  };
};



template <class charT> class ctype {};
template <class charT> class ctype_byname {};



template<>
class ctype<char> : public locale::facet, public ctype_base
{






    friend class ctype<wchar_t>;


  friend class _Locale;
public:

  typedef char char_type;

  explicit ctype(const mask* __tab = 0, bool __del = false, size_t __refs = 0);
  bool is(mask __m, char __c) const
    { return ((*(_M_ctype_table+(unsigned char)__c)) & __m) != 0; }

  const char* is(const char* __low, const char* __high, mask* __vec) const {
    for (const char* __p = __low;__p != __high; ++__p, ++__vec) {
      *__vec = _M_ctype_table[(unsigned char)*__p];
    }
    return __high;
  }

  const char* scan_is(mask __m, const char* __low, const char* __high) const;
  const char* scan_not(mask __m, const char* __low, const char* __high) const;

  char (toupper)(char __c) const { return do_toupper(__c); }
  const char* (toupper)(char* __low, const char* __high) const {
    return do_toupper(__low, __high);
  }

  char (tolower)(char __c) const { return do_tolower(__c); }
  const char* (tolower)(char* __low, const char* __high) const {
    return do_tolower(__low, __high);
  }

  char widen(char __c) const { return do_widen(__c); }
  const char* widen(const char* __low, const char* __high, char* __to) const {
    return do_widen(__low, __high, __to);
  }

  char narrow(char __c, char __dfault) const {
    return do_narrow(__c, __dfault);
  }
  const char* narrow(const char* __low, const char* __high,
                     char __dfault, char* __to) const {
    return do_narrow(__low, __high, __dfault, __to);
  }

  static locale::id id;



  static const size_t table_size = 256;


protected:
  const mask* table() const {return _M_ctype_table;}
  static const mask* classic_table() { return & _S_classic_table [1]; }

  ~ctype();

  virtual char do_toupper(char __c) const;
  virtual char do_tolower(char __c) const;
  virtual const char* do_toupper(char* __low, const char* __high) const;
  virtual const char* do_tolower(char* __low, const char* __high) const;
  virtual char do_widen(char __c) const;
  virtual const char* do_widen(const char* __low, const char* __high,
                               char* __to) const;
  virtual char do_narrow(char __c, char ) const;
  virtual const char* do_narrow(const char* __low, const char* __high,
                                char , char* __to) const;
private:
  struct _Is_mask {
    mask __m;
    _Is_mask(mask __x): __m(__x) {}
   bool operator()(char __c) {return (__m & (unsigned char) __c) != 0;}
  };

  static const mask _S_classic_table[257 ];
  const mask* _M_ctype_table;
  bool _M_delete;

  static const unsigned char _S_upper[256 ];
  static const unsigned char _S_lower[256 ];
};

template<>
class ctype_byname<char>: public ctype<char> {
public:
  explicit ctype_byname(const char*, size_t = 0);
  ~ctype_byname();

  virtual char do_toupper(char __c) const;
  virtual char do_tolower(char __c) const;

  virtual const char* do_toupper(char*, const char*) const;
  virtual const char* do_tolower(char*, const char*) const;

private:
  mask _M_byname_table[table_size + 1];
  _Locale_ctype* _M_ctype;
};



template<>
class ctype<wchar_t> : public locale::facet, public ctype_base
{
  friend class _Locale;
public:
  typedef wchar_t char_type;

  explicit ctype(size_t __refs = 0) : locale::facet(__refs) {}

  bool is(mask __m, wchar_t __c) const
    { return do_is(__m, __c); }

  const wchar_t* is(const wchar_t* __low, const wchar_t* __high,
                    mask* __vec) const
    { return do_is(__low, __high, __vec); }

  const wchar_t* scan_is(mask __m,
                         const wchar_t* __low, const wchar_t* __high) const
    { return do_scan_is(__m, __low, __high); }

  const wchar_t* scan_not (mask __m,
                           const wchar_t* __low, const wchar_t* __high) const
    { return do_scan_not(__m, __low, __high); }

  wchar_t (toupper)(wchar_t __c) const { return do_toupper(__c); }
  const wchar_t* (toupper)(wchar_t* __low, const wchar_t* __high) const
    { return do_toupper(__low, __high); }

  wchar_t (tolower)(wchar_t __c) const { return do_tolower(__c); }
  const wchar_t* (tolower)(wchar_t* __low, const wchar_t* __high) const
    { return do_tolower(__low, __high); }

  wchar_t widen(char __c) const { return do_widen(__c); }
  const char* widen(const char* __low, const char* __high,
                    wchar_t* __to) const
    { return do_widen(__low, __high, __to); }

  char narrow(wchar_t __c, char __dfault) const
    { return do_narrow(__c, __dfault); }
  const wchar_t* narrow(const wchar_t* __low, const wchar_t* __high,
                        char __dfault, char* __to) const
    { return do_narrow(__low, __high, __dfault, __to); }

  static locale::id id;

protected:
  ~ctype();

  virtual bool do_is(mask __m, wchar_t __c) const;
  virtual const wchar_t* do_is(const wchar_t*, const wchar_t*, mask*) const;
  virtual const wchar_t* do_scan_is(mask,
                                    const wchar_t*, const wchar_t*) const;
  virtual const wchar_t* do_scan_not(mask,
                                     const wchar_t*, const wchar_t*) const;
  virtual wchar_t do_toupper(wchar_t __c) const;
  virtual const wchar_t* do_toupper(wchar_t*, const wchar_t*) const;
  virtual wchar_t do_tolower(wchar_t c) const;
  virtual const wchar_t* do_tolower(wchar_t*, const wchar_t*) const;
  virtual wchar_t do_widen(char c) const;
  virtual const char* do_widen(const char*, const char*, wchar_t*) const;
  virtual char do_narrow(wchar_t __c, char __dfault) const;
  virtual const wchar_t* do_narrow(const wchar_t*, const wchar_t*,
                                   char, char*) const;
};

template<>
class ctype_byname<wchar_t>: public ctype<wchar_t> {
public:
  explicit ctype_byname(const char* __name, size_t __refs = 0);

protected:
  ~ctype_byname();

  virtual bool do_is(mask __m, wchar_t __c) const;
  virtual const wchar_t* do_is(const wchar_t*, const wchar_t*, mask*) const;
  virtual const wchar_t* do_scan_is(mask,
                                    const wchar_t*, const wchar_t*) const;
  virtual const wchar_t* do_scan_not(mask,
                                     const wchar_t*, const wchar_t*) const;
  virtual wchar_t do_toupper(wchar_t __c) const;
  virtual const wchar_t* do_toupper(wchar_t*, const wchar_t*) const;
  virtual wchar_t do_tolower(wchar_t c) const;
  virtual const wchar_t* do_tolower(wchar_t*, const wchar_t*) const;

private:
  _Locale_ctype* _M_ctype;
};



}
# 10 "c:/marmalade/5.2/s3e/h/std/c++/stl/_string_io.c" 2






namespace _STL {
# 26 "c:/marmalade/5.2/s3e/h/std/c++/stl/_string_io.c"
template <class _CharT, class _Traits>
bool
__stlp_string_fill(basic_ostream<_CharT, _Traits>& __os,
                  basic_streambuf<_CharT, _Traits>* __buf,
                  size_t __n)
{
  _CharT __f = __os.fill();
  size_t __i;
  bool __ok = true;

  for (__i = 0; __i < __n; ++__i)
    __ok = __ok && !_Traits::eq_int_type(__buf->sputc(__f), _Traits::eof());
  return __ok;
}

template <class _CharT, class _Traits, class _Alloc>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const basic_string<_CharT,_Traits,_Alloc>& __s)
{

 
  typedef basic_ostream<_CharT, _Traits> __ostream;
  typename __ostream::sentry __sentry(__os);
  bool __ok = false;

  if (__sentry) {
    __ok = true;
    size_t __n = __s.size();
    size_t __pad_len = 0;
    const bool __left = (__os.flags() & __ostream::left) != 0;
    const size_t __w = __os.width(0);
    basic_streambuf<_CharT, _Traits>* __buf = __os.rdbuf();

    if (__n < __w) {
      __pad_len = __w - __n;
    }

    if (!__left)
      __ok = __stlp_string_fill(__os, __buf, __pad_len);

    __ok = __ok && (__buf->sputn(__s.data(), streamsize(__n)) == streamsize(__n));

    if (__left)
      __ok = __ok && __stlp_string_fill(__os, __buf, __pad_len);
  }

  if (!__ok)
    __os.setstate(__ostream::failbit);

  return __os;
}

template <class _CharT, class _Traits, class _Alloc>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           basic_string<_CharT,_Traits, _Alloc>& __s)
{
 
  typedef basic_istream<_CharT, _Traits> __istream;
  typename __istream::sentry __sentry(__is);

  if (__sentry) {
    basic_streambuf<_CharT, _Traits>* __buf = __is.rdbuf();
    typedef ctype<_CharT> _C_type;



    const _C_type& _Ctype = *(const _C_type*)__is._M_ctype_facet();
# 107 "c:/marmalade/5.2/s3e/h/std/c++/stl/_string_io.c"
    __s.clear();
    size_t __n = __is.width(0);
    if (__n == 0)
      __n = static_cast<size_t>(-1);
    else
      __s.reserve(__n);


    while (__n-- > 0) {
      typename _Traits::int_type __c1 = __buf->sbumpc();
      if (_Traits::eq_int_type(__c1, _Traits::eof())) {
        __is.setstate(__istream::eofbit);
        break;
      }
      else {
        _CharT __c = _Traits::to_char_type(__c1);

        if (_Ctype.is(_C_type::space, __c)) {
          if (_Traits::eq_int_type(__buf->sputbackc(__c), _Traits::eof()))
            __is.setstate(__istream::failbit);
          break;
        }
        else
          __s.push_back(__c);
      }
    }


    if (__s.size() == 0)
      __is.setstate(__istream::failbit);
  }
  else
    __is.setstate(__istream::failbit);

  return __is;
}

template <class _CharT, class _Traits, class _Alloc>
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT,_Traits,_Alloc>& __s,
        _CharT __delim)
{
 
  typedef basic_istream<_CharT, _Traits> __istream;
  size_t __nread = 0;
  typename basic_istream<_CharT, _Traits>::sentry __sentry(__is, true);
  if (__sentry) {
    basic_streambuf<_CharT, _Traits>* __buf = __is.rdbuf();
    __s.clear();

    while (__nread < __s.max_size()) {
      int __c1 = __buf->sbumpc();
      if (_Traits::eq_int_type(__c1, _Traits::eof())) {
        __is.setstate(__istream::eofbit);
        break;
      }
      else {
        ++__nread;
        _CharT __c = _Traits::to_char_type(__c1);
        if (!_Traits::eq(__c, __delim))
          __s.push_back(__c);
        else
          break;
      }
    }
  }
  if (__nread == 0 || __nread >= __s.max_size())
    __is.setstate(__istream::failbit);

  return __is;
}
# 329 "c:/marmalade/5.2/s3e/h/std/c++/stl/_string_io.c"
}
# 120 "c:/marmalade/5.2/s3e/h/std/c++/stl/_string_io.h" 2
# 1494 "c:/marmalade/5.2/s3e/h/std/c++/stl/_string.h" 2
# 1 "c:/marmalade/5.2/s3e/h/std/c++/stl/_string_hash.h" 1
# 23 "c:/marmalade/5.2/s3e/h/std/c++/stl/_string_hash.h"
# 1 "c:/marmalade/5.2/s3e/h/std/c++/stl/_hash_fun.h" 1
# 38 "c:/marmalade/5.2/s3e/h/std/c++/stl/_hash_fun.h"
namespace _STL {

template <class _Key> struct hash { };

inline size_t __stl_hash_string(const char* __s)
{
 
  unsigned long __h = 0;
  for ( ; *__s; ++__s)
    __h = 5*__h + *__s;

  return size_t(__h);
}

template<> struct hash<char*>
{
  size_t operator()(const char* __s) const { return __stl_hash_string(__s); }
};

template<> struct hash<const char*>
{
  size_t operator()(const char* __s) const { return __stl_hash_string(__s); }
};

template<> struct hash<char> {
  size_t operator()(char __x) const { return __x; }
};
template<> struct hash<unsigned char> {
  size_t operator()(unsigned char __x) const { return __x; }
};

template<> struct hash<signed char> {
  size_t operator()(unsigned char __x) const { return __x; }
};

template<> struct hash<short> {
  size_t operator()(short __x) const { return __x; }
};
template<> struct hash<unsigned short> {
  size_t operator()(unsigned short __x) const { return __x; }
};
template<> struct hash<int> {
  size_t operator()(int __x) const { return __x; }
};
template<> struct hash<unsigned int> {
  size_t operator()(unsigned int __x) const { return __x; }
};
template<> struct hash<long> {
  size_t operator()(long __x) const { return __x; }
};
template<> struct hash<unsigned long> {
  size_t operator()(unsigned long __x) const { return __x; }
};


template<> struct hash<long long> {
  size_t operator()(long x) const { return x; }
};
template<> struct hash<unsigned long long> {
  size_t operator()(unsigned long x) const { return x; }
};


}
# 24 "c:/marmalade/5.2/s3e/h/std/c++/stl/_string_hash.h" 2






namespace _STL {

template <class _CharT, class _Traits, class _Alloc>
inline size_t
__stl_string_hash(const basic_string<_CharT,_Traits,_Alloc>& __s) {
  unsigned long __h = 0;
  typedef typename basic_string<_CharT,_Traits,_Alloc>::const_pointer const_ptr;
  size_t __len = __s.size();
  const _CharT* __data = __s.data();
  for ( size_t __i = 0; __i < __len; ++__i)
    __h = 5*__h + __data[__i];
  return size_t(__h);
}



template <class _CharT, class _Traits, class _Alloc>
struct hash<basic_string<_CharT,_Traits,_Alloc> > {
  size_t operator()(const basic_string<_CharT,_Traits,_Alloc>& __s) const
    { return __stl_string_hash(__s); }
};
# 68 "c:/marmalade/5.2/s3e/h/std/c++/stl/_string_hash.h"
}
# 1495 "c:/marmalade/5.2/s3e/h/std/c++/stl/_string.h" 2
# 46 "c:/marmalade/5.2/s3e/h/std/c++/string" 2







# 1 "c:/marmalade/5.2/s3e/h/std/c++/stl/_epilog.h" 1
# 10 "c:/marmalade/5.2/s3e/h/std/c++/stl/_epilog.h"
# 1 "c:/marmalade/5.2/s3e/h/std/c++/config/_epilog.h" 1
# 11 "c:/marmalade/5.2/s3e/h/std/c++/stl/_epilog.h" 2



# 1 "c:/marmalade/5.2/s3e/h/std/c++/stl/_config_compat_post.h" 1
# 15 "c:/marmalade/5.2/s3e/h/std/c++/stl/_epilog.h" 2
# 54 "c:/marmalade/5.2/s3e/h/std/c++/string" 2
# 40 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/std_string.h" 2
# 31 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/stringpiece.h" 2



extern "C++" { namespace icu_48 {
# 52 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/stringpiece.h"
class StringPiece : public UMemory {
 private:
  const char* ptr_;
  int32_t length_;

 public:




  StringPiece() : ptr_(__null), length_(0) { }





  StringPiece(const char* str);





  StringPiece(const _STL:: string& str)
    : ptr_(str.data()), length_(static_cast<int32_t>(str.size())) { }







  StringPiece(const char* offset, int32_t len) : ptr_(offset), length_(len) { }






  StringPiece(const StringPiece& x, int32_t pos);
# 99 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/stringpiece.h"
  StringPiece(const StringPiece& x, int32_t pos, int32_t len);
# 111 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/stringpiece.h"
  const char* data() const { return ptr_; }





  int32_t size() const { return length_; }





  int32_t length() const { return length_; }





  UBool empty() const { return length_ == 0; }





  void clear() { ptr_ = __null; length_ = 0; }







  void set(const char* xdata, int32_t len) { ptr_ = xdata; length_ = len; }






  void set(const char* str);






  void remove_prefix(int32_t n) {
    if (n >= 0) {
      if (n > length_) {
        n = length_;
      }
      ptr_ += n;
      length_ -= n;
    }
  }






  void remove_suffix(int32_t n) {
    if (n >= 0) {
      if (n <= length_) {
        length_ -= n;
      } else {
        length_ = 0;
      }
    }
  }





  static const int32_t npos = 0x7fffffff;
# 196 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/stringpiece.h"
  StringPiece substr(int32_t pos, int32_t len = npos) const {
    return StringPiece(*this, pos, len);
  }
};
# 208 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/stringpiece.h"
 UBool
operator==(const StringPiece& x, const StringPiece& y);
# 218 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/stringpiece.h"
inline UBool operator!=(const StringPiece& x, const StringPiece& y) {
  return !(x == y);
}

} }
# 25 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/bytestrie.h" 2

# 1 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/ustringtrie.h" 1
# 32 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/ustringtrie.h"
enum UStringTrieResult {







    USTRINGTRIE_NO_MATCH,






    USTRINGTRIE_NO_VALUE,







    USTRINGTRIE_FINAL_VALUE,







    USTRINGTRIE_INTERMEDIATE_VALUE
};
# 27 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/bytestrie.h" 2

extern "C++" { namespace icu_48 {

class ByteSink;
class BytesTrieBuilder;
class CharString;
class UVector32;
# 48 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/bytestrie.h"
class BytesTrie : public UMemory {
public:
# 64 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/bytestrie.h"
    BytesTrie(const void *trieBytes)
            : ownedArray_(__null), bytes_(reinterpret_cast<const uint8_t *>(trieBytes)),
              pos_(bytes_), remainingMatchLength_(-1) {}





    ~BytesTrie();







    BytesTrie(const BytesTrie &other)
            : ownedArray_(__null), bytes_(other.bytes_),
              pos_(other.pos_), remainingMatchLength_(other.remainingMatchLength_) {}






    BytesTrie &reset() {
        pos_=bytes_;
        remainingMatchLength_=-1;
        return *this;
    }






    class State : public UMemory {
    public:




        State() { bytes=__null; }
    private:
        friend class BytesTrie;

        const uint8_t *bytes;
        const uint8_t *pos;
        int32_t remainingMatchLength;
    };
# 122 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/bytestrie.h"
    const BytesTrie &saveState(State &state) const {
        state.bytes=bytes_;
        state.pos=pos_;
        state.remainingMatchLength=remainingMatchLength_;
        return *this;
    }
# 139 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/bytestrie.h"
    BytesTrie &resetToState(const State &state) {
        if(bytes_==state.bytes && bytes_!=__null) {
            pos_=state.pos;
            remainingMatchLength_=state.remainingMatchLength;
        }
        return *this;
    }







    UStringTrieResult current() const;
# 163 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/bytestrie.h"
    inline UStringTrieResult first(int32_t inByte) {
        remainingMatchLength_=-1;
        if(inByte<0) {
            inByte+=0x100;
        }
        return nextImpl(bytes_, inByte);
    }
# 178 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/bytestrie.h"
    UStringTrieResult next(int32_t inByte);
# 195 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/bytestrie.h"
    UStringTrieResult next(const char *s, int32_t length);
# 206 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/bytestrie.h"
    inline int32_t getValue() const {
        const uint8_t *pos=pos_;
        int32_t leadByte=*pos++;

        return readValue(pos, leadByte>>1);
    }
# 222 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/bytestrie.h"
    inline UBool hasUniqueValue(int32_t &uniqueValue) const {
        const uint8_t *pos=pos_;

        return pos!=__null && findUniqueValue(pos+remainingMatchLength_+1, 0, uniqueValue);
    }
# 236 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/bytestrie.h"
    int32_t getNextBytes(ByteSink &out) const;





    class Iterator : public UMemory {
    public:
# 255 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/bytestrie.h"
        Iterator(const void *trieBytes, int32_t maxStringLength, UErrorCode &errorCode);
# 268 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/bytestrie.h"
        Iterator(const BytesTrie &trie, int32_t maxStringLength, UErrorCode &errorCode);





        ~Iterator();






        Iterator &reset();





        UBool hasNext() const;
# 303 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/bytestrie.h"
        UBool next(UErrorCode &errorCode);





        const StringPiece &getString() const { return sp_; }




        int32_t getValue() const { return value_; }

    private:
        UBool truncateAndStop();

        const uint8_t *branchNext(const uint8_t *pos, int32_t length, UErrorCode &errorCode);

        const uint8_t *bytes_;
        const uint8_t *pos_;
        const uint8_t *initialPos_;
        int32_t remainingMatchLength_;
        int32_t initialRemainingMatchLength_;

        CharString *str_;
        StringPiece sp_;
        int32_t maxLength_;
        int32_t value_;
# 339 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/bytestrie.h"
        UVector32 *stack_;
    };

private:
    friend class BytesTrieBuilder;







    BytesTrie(void *adoptBytes, const void *trieBytes)
            : ownedArray_(reinterpret_cast<uint8_t *>(adoptBytes)),
              bytes_(reinterpret_cast<const uint8_t *>(trieBytes)),
              pos_(bytes_), remainingMatchLength_(-1) {}


    BytesTrie &operator=(const BytesTrie &other);

    inline void stop() {
        pos_=__null;
    }



    static int32_t readValue(const uint8_t *pos, int32_t leadByte);
    static inline const uint8_t *skipValue(const uint8_t *pos, int32_t leadByte) {

        if(leadByte>=(kMinTwoByteValueLead<<1)) {
            if(leadByte<(kMinThreeByteValueLead<<1)) {
                ++pos;
            } else if(leadByte<(kFourByteValueLead<<1)) {
                pos+=2;
            } else {
                pos+=3+((leadByte>>1)&1);
            }
        }
        return pos;
    }
    static inline const uint8_t *skipValue(const uint8_t *pos) {
        int32_t leadByte=*pos++;
        return skipValue(pos, leadByte);
    }


    static const uint8_t *jumpByDelta(const uint8_t *pos);

    static inline const uint8_t *skipDelta(const uint8_t *pos) {
        int32_t delta=*pos++;
        if(delta>=kMinTwoByteDeltaLead) {
            if(delta<kMinThreeByteDeltaLead) {
                ++pos;
            } else if(delta<kFourByteDeltaLead) {
                pos+=2;
            } else {
                pos+=3+(delta&1);
            }
        }
        return pos;
    }

    static inline UStringTrieResult valueResult(int32_t node) {
        return (UStringTrieResult)(USTRINGTRIE_INTERMEDIATE_VALUE-(node&kValueIsFinal));
    }


    UStringTrieResult branchNext(const uint8_t *pos, int32_t length, int32_t inByte);


    UStringTrieResult nextImpl(const uint8_t *pos, int32_t inByte);




    static const uint8_t *findUniqueValueFromBranch(const uint8_t *pos, int32_t length,
                                                    UBool haveUniqueValue, int32_t &uniqueValue);


    static UBool findUniqueValue(const uint8_t *pos, UBool haveUniqueValue, int32_t &uniqueValue);



    static void getNextBranchBytes(const uint8_t *pos, int32_t length, ByteSink &out);
    static void append(ByteSink &out, int c);
# 464 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/bytestrie.h"
    static const int32_t kMaxBranchLinearSubNodeLength=5;


    static const int32_t kMinLinearMatch=0x10;
    static const int32_t kMaxLinearMatchLength=0x10;






    static const int32_t kMinValueLead=kMinLinearMatch+kMaxLinearMatchLength;

    static const int32_t kValueIsFinal=1;


    static const int32_t kMinOneByteValueLead=kMinValueLead/2;
    static const int32_t kMaxOneByteValue=0x40;

    static const int32_t kMinTwoByteValueLead=kMinOneByteValueLead+kMaxOneByteValue+1;
    static const int32_t kMaxTwoByteValue=0x1aff;

    static const int32_t kMinThreeByteValueLead=kMinTwoByteValueLead+(kMaxTwoByteValue>>8)+1;
    static const int32_t kFourByteValueLead=0x7e;


    static const int32_t kMaxThreeByteValue=((kFourByteValueLead-kMinThreeByteValueLead)<<16)-1;

    static const int32_t kFiveByteValueLead=0x7f;


    static const int32_t kMaxOneByteDelta=0xbf;
    static const int32_t kMinTwoByteDeltaLead=kMaxOneByteDelta+1;
    static const int32_t kMinThreeByteDeltaLead=0xf0;
    static const int32_t kFourByteDeltaLead=0xfe;
    static const int32_t kFiveByteDeltaLead=0xff;

    static const int32_t kMaxTwoByteDelta=((kMinThreeByteDeltaLead-kMinTwoByteDeltaLead)<<8)-1;
    static const int32_t kMaxThreeByteDelta=((kFourByteDeltaLead-kMinThreeByteDeltaLead)<<16)-1;

    uint8_t *ownedArray_;


    const uint8_t *bytes_;




    const uint8_t *pos_;

    int32_t remainingMatchLength_;
};

} }
# 17 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/propname.h" 2
# 1 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h" 1
# 28 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" {
# 174 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
typedef enum UProperty {
# 186 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
    UCHAR_ALPHABETIC=0,

    UCHAR_BINARY_START=UCHAR_ALPHABETIC,

    UCHAR_ASCII_HEX_DIGIT=1,



    UCHAR_BIDI_CONTROL=2,




    UCHAR_BIDI_MIRRORED=3,

    UCHAR_DASH=4,



    UCHAR_DEFAULT_IGNORABLE_CODE_POINT=5,


    UCHAR_DEPRECATED=6,


    UCHAR_DIACRITIC=7,



    UCHAR_EXTENDER=8,



    UCHAR_FULL_COMPOSITION_EXCLUSION=9,



    UCHAR_GRAPHEME_BASE=10,



    UCHAR_GRAPHEME_EXTEND=11,


    UCHAR_GRAPHEME_LINK=12,


    UCHAR_HEX_DIGIT=13,


    UCHAR_HYPHEN=14,




    UCHAR_ID_CONTINUE=15,



    UCHAR_ID_START=16,


    UCHAR_IDEOGRAPHIC=17,



    UCHAR_IDS_BINARY_OPERATOR=18,



    UCHAR_IDS_TRINARY_OPERATOR=19,


    UCHAR_JOIN_CONTROL=20,



    UCHAR_LOGICAL_ORDER_EXCEPTION=21,


    UCHAR_LOWERCASE=22,

    UCHAR_MATH=23,



    UCHAR_NONCHARACTER_CODE_POINT=24,

    UCHAR_QUOTATION_MARK=25,



    UCHAR_RADICAL=26,




    UCHAR_SOFT_DOTTED=27,



    UCHAR_TERMINAL_PUNCTUATION=28,



    UCHAR_UNIFIED_IDEOGRAPH=29,


    UCHAR_UPPERCASE=30,



    UCHAR_WHITE_SPACE=31,



    UCHAR_XID_CONTINUE=32,


    UCHAR_XID_START=33,



   UCHAR_CASE_SENSITIVE=34,




    UCHAR_S_TERM=35,





    UCHAR_VARIATION_SELECTOR=36,






    UCHAR_NFD_INERT=37,






    UCHAR_NFKD_INERT=38,






    UCHAR_NFC_INERT=39,






    UCHAR_NFKC_INERT=40,
# 359 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
    UCHAR_SEGMENT_STARTER=41,




    UCHAR_PATTERN_SYNTAX=42,




    UCHAR_PATTERN_WHITE_SPACE=43,




    UCHAR_POSIX_ALNUM=44,




    UCHAR_POSIX_BLANK=45,




    UCHAR_POSIX_GRAPH=46,




    UCHAR_POSIX_PRINT=47,




    UCHAR_POSIX_XDIGIT=48,

    UCHAR_CASED=49,

    UCHAR_CASE_IGNORABLE=50,

    UCHAR_CHANGES_WHEN_LOWERCASED=51,

    UCHAR_CHANGES_WHEN_UPPERCASED=52,

    UCHAR_CHANGES_WHEN_TITLECASED=53,

    UCHAR_CHANGES_WHEN_CASEFOLDED=54,

    UCHAR_CHANGES_WHEN_CASEMAPPED=55,

    UCHAR_CHANGES_WHEN_NFKC_CASEFOLDED=56,

    UCHAR_BINARY_LIMIT=57,



    UCHAR_BIDI_CLASS=0x1000,

    UCHAR_INT_START=UCHAR_BIDI_CLASS,


    UCHAR_BLOCK=0x1001,


    UCHAR_CANONICAL_COMBINING_CLASS=0x1002,


    UCHAR_DECOMPOSITION_TYPE=0x1003,



    UCHAR_EAST_ASIAN_WIDTH=0x1004,


    UCHAR_GENERAL_CATEGORY=0x1005,


    UCHAR_JOINING_GROUP=0x1006,


    UCHAR_JOINING_TYPE=0x1007,


    UCHAR_LINE_BREAK=0x1008,


    UCHAR_NUMERIC_TYPE=0x1009,


    UCHAR_SCRIPT=0x100A,


    UCHAR_HANGUL_SYLLABLE_TYPE=0x100B,


    UCHAR_NFD_QUICK_CHECK=0x100C,


    UCHAR_NFKD_QUICK_CHECK=0x100D,


    UCHAR_NFC_QUICK_CHECK=0x100E,


    UCHAR_NFKC_QUICK_CHECK=0x100F,






    UCHAR_LEAD_CANONICAL_COMBINING_CLASS=0x1010,






    UCHAR_TRAIL_CANONICAL_COMBINING_CLASS=0x1011,




    UCHAR_GRAPHEME_CLUSTER_BREAK=0x1012,




    UCHAR_SENTENCE_BREAK=0x1013,




    UCHAR_WORD_BREAK=0x1014,

    UCHAR_INT_LIMIT=0x1015,
# 505 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
    UCHAR_GENERAL_CATEGORY_MASK=0x2000,

    UCHAR_MASK_START=UCHAR_GENERAL_CATEGORY_MASK,

    UCHAR_MASK_LIMIT=0x2001,



    UCHAR_NUMERIC_VALUE=0x3000,

    UCHAR_DOUBLE_START=UCHAR_NUMERIC_VALUE,

    UCHAR_DOUBLE_LIMIT=0x3001,



    UCHAR_AGE=0x4000,

    UCHAR_STRING_START=UCHAR_AGE,


    UCHAR_BIDI_MIRRORING_GLYPH=0x4001,


    UCHAR_CASE_FOLDING=0x4002,


    UCHAR_ISO_COMMENT=0x4003,


    UCHAR_LOWERCASE_MAPPING=0x4004,


    UCHAR_NAME=0x4005,


    UCHAR_SIMPLE_CASE_FOLDING=0x4006,


    UCHAR_SIMPLE_LOWERCASE_MAPPING=0x4007,


    UCHAR_SIMPLE_TITLECASE_MAPPING=0x4008,


    UCHAR_SIMPLE_UPPERCASE_MAPPING=0x4009,


    UCHAR_TITLECASE_MAPPING=0x400A,


    UCHAR_UNICODE_1_NAME=0x400B,


    UCHAR_UPPERCASE_MAPPING=0x400C,

    UCHAR_STRING_LIMIT=0x400D,
# 570 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
    UCHAR_SCRIPT_EXTENSIONS=0x7000,

    UCHAR_OTHER_PROPERTY_START=UCHAR_SCRIPT_EXTENSIONS,


    UCHAR_OTHER_PROPERTY_LIMIT=0x7001,


    UCHAR_INVALID_CODE = -1
} UProperty;






typedef enum UCharCategory
{



    U_UNASSIGNED = 0,

    U_GENERAL_OTHER_TYPES = 0,

    U_UPPERCASE_LETTER = 1,

    U_LOWERCASE_LETTER = 2,

    U_TITLECASE_LETTER = 3,

    U_MODIFIER_LETTER = 4,

    U_OTHER_LETTER = 5,

    U_NON_SPACING_MARK = 6,

    U_ENCLOSING_MARK = 7,

    U_COMBINING_SPACING_MARK = 8,

    U_DECIMAL_DIGIT_NUMBER = 9,

    U_LETTER_NUMBER = 10,

    U_OTHER_NUMBER = 11,

    U_SPACE_SEPARATOR = 12,

    U_LINE_SEPARATOR = 13,

    U_PARAGRAPH_SEPARATOR = 14,

    U_CONTROL_CHAR = 15,

    U_FORMAT_CHAR = 16,

    U_PRIVATE_USE_CHAR = 17,

    U_SURROGATE = 18,

    U_DASH_PUNCTUATION = 19,

    U_START_PUNCTUATION = 20,

    U_END_PUNCTUATION = 21,

    U_CONNECTOR_PUNCTUATION = 22,

    U_OTHER_PUNCTUATION = 23,

    U_MATH_SYMBOL = 24,

    U_CURRENCY_SYMBOL = 25,

    U_MODIFIER_SYMBOL = 26,

    U_OTHER_SYMBOL = 27,

    U_INITIAL_PUNCTUATION = 28,

    U_FINAL_PUNCTUATION = 29,

    U_CHAR_CATEGORY_COUNT
} UCharCategory;
# 772 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
typedef enum UCharDirection {



    U_LEFT_TO_RIGHT = 0,

    U_RIGHT_TO_LEFT = 1,

    U_EUROPEAN_NUMBER = 2,

    U_EUROPEAN_NUMBER_SEPARATOR = 3,

    U_EUROPEAN_NUMBER_TERMINATOR = 4,

    U_ARABIC_NUMBER = 5,

    U_COMMON_NUMBER_SEPARATOR = 6,

    U_BLOCK_SEPARATOR = 7,

    U_SEGMENT_SEPARATOR = 8,

    U_WHITE_SPACE_NEUTRAL = 9,

    U_OTHER_NEUTRAL = 10,

    U_LEFT_TO_RIGHT_EMBEDDING = 11,

    U_LEFT_TO_RIGHT_OVERRIDE = 12,

    U_RIGHT_TO_LEFT_ARABIC = 13,

    U_RIGHT_TO_LEFT_EMBEDDING = 14,

    U_RIGHT_TO_LEFT_OVERRIDE = 15,

    U_POP_DIRECTIONAL_FORMAT = 16,

    U_DIR_NON_SPACING_MARK = 17,

    U_BOUNDARY_NEUTRAL = 18,

    U_CHAR_DIRECTION_COUNT
} UCharDirection;





enum UBlockCode {


    UBLOCK_NO_BLOCK = 0,


    UBLOCK_BASIC_LATIN = 1,


    UBLOCK_LATIN_1_SUPPLEMENT=2,


    UBLOCK_LATIN_EXTENDED_A =3,


    UBLOCK_LATIN_EXTENDED_B =4,


    UBLOCK_IPA_EXTENSIONS =5,


    UBLOCK_SPACING_MODIFIER_LETTERS =6,


    UBLOCK_COMBINING_DIACRITICAL_MARKS =7,





    UBLOCK_GREEK =8,


    UBLOCK_CYRILLIC =9,


    UBLOCK_ARMENIAN =10,


    UBLOCK_HEBREW =11,


    UBLOCK_ARABIC =12,


    UBLOCK_SYRIAC =13,


    UBLOCK_THAANA =14,


    UBLOCK_DEVANAGARI =15,


    UBLOCK_BENGALI =16,


    UBLOCK_GURMUKHI =17,


    UBLOCK_GUJARATI =18,


    UBLOCK_ORIYA =19,


    UBLOCK_TAMIL =20,


    UBLOCK_TELUGU =21,


    UBLOCK_KANNADA =22,


    UBLOCK_MALAYALAM =23,


    UBLOCK_SINHALA =24,


    UBLOCK_THAI =25,


    UBLOCK_LAO =26,


    UBLOCK_TIBETAN =27,


    UBLOCK_MYANMAR =28,


    UBLOCK_GEORGIAN =29,


    UBLOCK_HANGUL_JAMO =30,


    UBLOCK_ETHIOPIC =31,


    UBLOCK_CHEROKEE =32,


    UBLOCK_UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS =33,


    UBLOCK_OGHAM =34,


    UBLOCK_RUNIC =35,


    UBLOCK_KHMER =36,


    UBLOCK_MONGOLIAN =37,


    UBLOCK_LATIN_EXTENDED_ADDITIONAL =38,


    UBLOCK_GREEK_EXTENDED =39,


    UBLOCK_GENERAL_PUNCTUATION =40,


    UBLOCK_SUPERSCRIPTS_AND_SUBSCRIPTS =41,


    UBLOCK_CURRENCY_SYMBOLS =42,





    UBLOCK_COMBINING_MARKS_FOR_SYMBOLS =43,


    UBLOCK_LETTERLIKE_SYMBOLS =44,


    UBLOCK_NUMBER_FORMS =45,


    UBLOCK_ARROWS =46,


    UBLOCK_MATHEMATICAL_OPERATORS =47,


    UBLOCK_MISCELLANEOUS_TECHNICAL =48,


    UBLOCK_CONTROL_PICTURES =49,


    UBLOCK_OPTICAL_CHARACTER_RECOGNITION =50,


    UBLOCK_ENCLOSED_ALPHANUMERICS =51,


    UBLOCK_BOX_DRAWING =52,


    UBLOCK_BLOCK_ELEMENTS =53,


    UBLOCK_GEOMETRIC_SHAPES =54,


    UBLOCK_MISCELLANEOUS_SYMBOLS =55,


    UBLOCK_DINGBATS =56,


    UBLOCK_BRAILLE_PATTERNS =57,


    UBLOCK_CJK_RADICALS_SUPPLEMENT =58,


    UBLOCK_KANGXI_RADICALS =59,


    UBLOCK_IDEOGRAPHIC_DESCRIPTION_CHARACTERS =60,


    UBLOCK_CJK_SYMBOLS_AND_PUNCTUATION =61,


    UBLOCK_HIRAGANA =62,


    UBLOCK_KATAKANA =63,


    UBLOCK_BOPOMOFO =64,


    UBLOCK_HANGUL_COMPATIBILITY_JAMO =65,


    UBLOCK_KANBUN =66,


    UBLOCK_BOPOMOFO_EXTENDED =67,


    UBLOCK_ENCLOSED_CJK_LETTERS_AND_MONTHS =68,


    UBLOCK_CJK_COMPATIBILITY =69,


    UBLOCK_CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A =70,


    UBLOCK_CJK_UNIFIED_IDEOGRAPHS =71,


    UBLOCK_YI_SYLLABLES =72,


    UBLOCK_YI_RADICALS =73,


    UBLOCK_HANGUL_SYLLABLES =74,


    UBLOCK_HIGH_SURROGATES =75,


    UBLOCK_HIGH_PRIVATE_USE_SURROGATES =76,


    UBLOCK_LOW_SURROGATES =77,
# 1072 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
    UBLOCK_PRIVATE_USE = 78,
# 1082 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
    UBLOCK_PRIVATE_USE_AREA =UBLOCK_PRIVATE_USE,


    UBLOCK_CJK_COMPATIBILITY_IDEOGRAPHS =79,


    UBLOCK_ALPHABETIC_PRESENTATION_FORMS =80,


    UBLOCK_ARABIC_PRESENTATION_FORMS_A =81,


    UBLOCK_COMBINING_HALF_MARKS =82,


    UBLOCK_CJK_COMPATIBILITY_FORMS =83,


    UBLOCK_SMALL_FORM_VARIANTS =84,


    UBLOCK_ARABIC_PRESENTATION_FORMS_B =85,


    UBLOCK_SPECIALS =86,


    UBLOCK_HALFWIDTH_AND_FULLWIDTH_FORMS =87,




    UBLOCK_OLD_ITALIC = 88 ,

    UBLOCK_GOTHIC = 89 ,

    UBLOCK_DESERET = 90 ,

    UBLOCK_BYZANTINE_MUSICAL_SYMBOLS = 91 ,

    UBLOCK_MUSICAL_SYMBOLS = 92 ,

    UBLOCK_MATHEMATICAL_ALPHANUMERIC_SYMBOLS = 93 ,

    UBLOCK_CJK_UNIFIED_IDEOGRAPHS_EXTENSION_B = 94 ,

    UBLOCK_CJK_COMPATIBILITY_IDEOGRAPHS_SUPPLEMENT = 95 ,

    UBLOCK_TAGS = 96,







    UBLOCK_CYRILLIC_SUPPLEMENTARY = 97,

    UBLOCK_CYRILLIC_SUPPLEMENT = UBLOCK_CYRILLIC_SUPPLEMENTARY,

    UBLOCK_TAGALOG = 98,

    UBLOCK_HANUNOO = 99,

    UBLOCK_BUHID = 100,

    UBLOCK_TAGBANWA = 101,

    UBLOCK_MISCELLANEOUS_MATHEMATICAL_SYMBOLS_A = 102,

    UBLOCK_SUPPLEMENTAL_ARROWS_A = 103,

    UBLOCK_SUPPLEMENTAL_ARROWS_B = 104,

    UBLOCK_MISCELLANEOUS_MATHEMATICAL_SYMBOLS_B = 105,

    UBLOCK_SUPPLEMENTAL_MATHEMATICAL_OPERATORS = 106,

    UBLOCK_KATAKANA_PHONETIC_EXTENSIONS = 107,

    UBLOCK_VARIATION_SELECTORS = 108,

    UBLOCK_SUPPLEMENTARY_PRIVATE_USE_AREA_A = 109,

    UBLOCK_SUPPLEMENTARY_PRIVATE_USE_AREA_B = 110,




    UBLOCK_LIMBU = 111,

    UBLOCK_TAI_LE = 112,

    UBLOCK_KHMER_SYMBOLS = 113,

    UBLOCK_PHONETIC_EXTENSIONS = 114,

    UBLOCK_MISCELLANEOUS_SYMBOLS_AND_ARROWS = 115,

    UBLOCK_YIJING_HEXAGRAM_SYMBOLS = 116,

    UBLOCK_LINEAR_B_SYLLABARY = 117,

    UBLOCK_LINEAR_B_IDEOGRAMS = 118,

    UBLOCK_AEGEAN_NUMBERS = 119,

    UBLOCK_UGARITIC = 120,

    UBLOCK_SHAVIAN = 121,

    UBLOCK_OSMANYA = 122,

    UBLOCK_CYPRIOT_SYLLABARY = 123,

    UBLOCK_TAI_XUAN_JING_SYMBOLS = 124,

    UBLOCK_VARIATION_SELECTORS_SUPPLEMENT = 125,




    UBLOCK_ANCIENT_GREEK_MUSICAL_NOTATION = 126,

    UBLOCK_ANCIENT_GREEK_NUMBERS = 127,

    UBLOCK_ARABIC_SUPPLEMENT = 128,

    UBLOCK_BUGINESE = 129,

    UBLOCK_CJK_STROKES = 130,

    UBLOCK_COMBINING_DIACRITICAL_MARKS_SUPPLEMENT = 131,

    UBLOCK_COPTIC = 132,

    UBLOCK_ETHIOPIC_EXTENDED = 133,

    UBLOCK_ETHIOPIC_SUPPLEMENT = 134,

    UBLOCK_GEORGIAN_SUPPLEMENT = 135,

    UBLOCK_GLAGOLITIC = 136,

    UBLOCK_KHAROSHTHI = 137,

    UBLOCK_MODIFIER_TONE_LETTERS = 138,

    UBLOCK_NEW_TAI_LUE = 139,

    UBLOCK_OLD_PERSIAN = 140,

    UBLOCK_PHONETIC_EXTENSIONS_SUPPLEMENT = 141,

    UBLOCK_SUPPLEMENTAL_PUNCTUATION = 142,

    UBLOCK_SYLOTI_NAGRI = 143,

    UBLOCK_TIFINAGH = 144,

    UBLOCK_VERTICAL_FORMS = 145,




    UBLOCK_NKO = 146,

    UBLOCK_BALINESE = 147,

    UBLOCK_LATIN_EXTENDED_C = 148,

    UBLOCK_LATIN_EXTENDED_D = 149,

    UBLOCK_PHAGS_PA = 150,

    UBLOCK_PHOENICIAN = 151,

    UBLOCK_CUNEIFORM = 152,

    UBLOCK_CUNEIFORM_NUMBERS_AND_PUNCTUATION = 153,

    UBLOCK_COUNTING_ROD_NUMERALS = 154,




    UBLOCK_SUNDANESE = 155,

    UBLOCK_LEPCHA = 156,

    UBLOCK_OL_CHIKI = 157,

    UBLOCK_CYRILLIC_EXTENDED_A = 158,

    UBLOCK_VAI = 159,

    UBLOCK_CYRILLIC_EXTENDED_B = 160,

    UBLOCK_SAURASHTRA = 161,

    UBLOCK_KAYAH_LI = 162,

    UBLOCK_REJANG = 163,

    UBLOCK_CHAM = 164,

    UBLOCK_ANCIENT_SYMBOLS = 165,

    UBLOCK_PHAISTOS_DISC = 166,

    UBLOCK_LYCIAN = 167,

    UBLOCK_CARIAN = 168,

    UBLOCK_LYDIAN = 169,

    UBLOCK_MAHJONG_TILES = 170,

    UBLOCK_DOMINO_TILES = 171,




    UBLOCK_SAMARITAN = 172,

    UBLOCK_UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS_EXTENDED = 173,

    UBLOCK_TAI_THAM = 174,

    UBLOCK_VEDIC_EXTENSIONS = 175,

    UBLOCK_LISU = 176,

    UBLOCK_BAMUM = 177,

    UBLOCK_COMMON_INDIC_NUMBER_FORMS = 178,

    UBLOCK_DEVANAGARI_EXTENDED = 179,

    UBLOCK_HANGUL_JAMO_EXTENDED_A = 180,

    UBLOCK_JAVANESE = 181,

    UBLOCK_MYANMAR_EXTENDED_A = 182,

    UBLOCK_TAI_VIET = 183,

    UBLOCK_MEETEI_MAYEK = 184,

    UBLOCK_HANGUL_JAMO_EXTENDED_B = 185,

    UBLOCK_IMPERIAL_ARAMAIC = 186,

    UBLOCK_OLD_SOUTH_ARABIAN = 187,

    UBLOCK_AVESTAN = 188,

    UBLOCK_INSCRIPTIONAL_PARTHIAN = 189,

    UBLOCK_INSCRIPTIONAL_PAHLAVI = 190,

    UBLOCK_OLD_TURKIC = 191,

    UBLOCK_RUMI_NUMERAL_SYMBOLS = 192,

    UBLOCK_KAITHI = 193,

    UBLOCK_EGYPTIAN_HIEROGLYPHS = 194,

    UBLOCK_ENCLOSED_ALPHANUMERIC_SUPPLEMENT = 195,

    UBLOCK_ENCLOSED_IDEOGRAPHIC_SUPPLEMENT = 196,

    UBLOCK_CJK_UNIFIED_IDEOGRAPHS_EXTENSION_C = 197,




    UBLOCK_MANDAIC = 198,

    UBLOCK_BATAK = 199,

    UBLOCK_ETHIOPIC_EXTENDED_A = 200,

    UBLOCK_BRAHMI = 201,

    UBLOCK_BAMUM_SUPPLEMENT = 202,

    UBLOCK_KANA_SUPPLEMENT = 203,

    UBLOCK_PLAYING_CARDS = 204,

    UBLOCK_MISCELLANEOUS_SYMBOLS_AND_PICTOGRAPHS = 205,

    UBLOCK_EMOTICONS = 206,

    UBLOCK_TRANSPORT_AND_MAP_SYMBOLS = 207,

    UBLOCK_ALCHEMICAL_SYMBOLS = 208,

    UBLOCK_CJK_UNIFIED_IDEOGRAPHS_EXTENSION_D = 209,


    UBLOCK_COUNT = 210,


    UBLOCK_INVALID_CODE=-1
};


typedef enum UBlockCode UBlockCode;
# 1401 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
typedef enum UEastAsianWidth {
    U_EA_NEUTRAL,
    U_EA_AMBIGUOUS,
    U_EA_HALFWIDTH,
    U_EA_FULLWIDTH,
    U_EA_NARROW,
    U_EA_WIDE,
    U_EA_COUNT
} UEastAsianWidth;
# 1426 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
typedef enum UCharNameChoice {
    U_UNICODE_CHAR_NAME,
    U_UNICODE_10_CHAR_NAME,
    U_EXTENDED_CHAR_NAME,
    U_CHAR_NAME_ALIAS,
    U_CHAR_NAME_CHOICE_COUNT
} UCharNameChoice;
# 1447 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
typedef enum UPropertyNameChoice {
    U_SHORT_PROPERTY_NAME,
    U_LONG_PROPERTY_NAME,
    U_PROPERTY_NAME_CHOICE_COUNT
} UPropertyNameChoice;







typedef enum UDecompositionType {
    U_DT_NONE,
    U_DT_CANONICAL,
    U_DT_COMPAT,
    U_DT_CIRCLE,
    U_DT_FINAL,
    U_DT_FONT,
    U_DT_FRACTION,
    U_DT_INITIAL,
    U_DT_ISOLATED,
    U_DT_MEDIAL,
    U_DT_NARROW,
    U_DT_NOBREAK,
    U_DT_SMALL,
    U_DT_SQUARE,
    U_DT_SUB,
    U_DT_SUPER,
    U_DT_VERTICAL,
    U_DT_WIDE,
    U_DT_COUNT
} UDecompositionType;







typedef enum UJoiningType {
    U_JT_NON_JOINING,
    U_JT_JOIN_CAUSING,
    U_JT_DUAL_JOINING,
    U_JT_LEFT_JOINING,
    U_JT_RIGHT_JOINING,
    U_JT_TRANSPARENT,
    U_JT_COUNT
} UJoiningType;







typedef enum UJoiningGroup {
    U_JG_NO_JOINING_GROUP,
    U_JG_AIN,
    U_JG_ALAPH,
    U_JG_ALEF,
    U_JG_BEH,
    U_JG_BETH,
    U_JG_DAL,
    U_JG_DALATH_RISH,
    U_JG_E,
    U_JG_FEH,
    U_JG_FINAL_SEMKATH,
    U_JG_GAF,
    U_JG_GAMAL,
    U_JG_HAH,
    U_JG_TEH_MARBUTA_GOAL,
    U_JG_HAMZA_ON_HEH_GOAL=U_JG_TEH_MARBUTA_GOAL,
    U_JG_HE,
    U_JG_HEH,
    U_JG_HEH_GOAL,
    U_JG_HETH,
    U_JG_KAF,
    U_JG_KAPH,
    U_JG_KNOTTED_HEH,
    U_JG_LAM,
    U_JG_LAMADH,
    U_JG_MEEM,
    U_JG_MIM,
    U_JG_NOON,
    U_JG_NUN,
    U_JG_PE,
    U_JG_QAF,
    U_JG_QAPH,
    U_JG_REH,
    U_JG_REVERSED_PE,
    U_JG_SAD,
    U_JG_SADHE,
    U_JG_SEEN,
    U_JG_SEMKATH,
    U_JG_SHIN,
    U_JG_SWASH_KAF,
    U_JG_SYRIAC_WAW,
    U_JG_TAH,
    U_JG_TAW,
    U_JG_TEH_MARBUTA,
    U_JG_TETH,
    U_JG_WAW,
    U_JG_YEH,
    U_JG_YEH_BARREE,
    U_JG_YEH_WITH_TAIL,
    U_JG_YUDH,
    U_JG_YUDH_HE,
    U_JG_ZAIN,
    U_JG_FE,
    U_JG_KHAPH,
    U_JG_ZHAIN,
    U_JG_BURUSHASKI_YEH_BARREE,
    U_JG_FARSI_YEH,
    U_JG_NYA,
    U_JG_COUNT
} UJoiningGroup;







typedef enum UGraphemeClusterBreak {
    U_GCB_OTHER = 0,
    U_GCB_CONTROL = 1,
    U_GCB_CR = 2,
    U_GCB_EXTEND = 3,
    U_GCB_L = 4,
    U_GCB_LF = 5,
    U_GCB_LV = 6,
    U_GCB_LVT = 7,
    U_GCB_T = 8,
    U_GCB_V = 9,
    U_GCB_SPACING_MARK = 10,
    U_GCB_PREPEND = 11,
    U_GCB_COUNT = 12
} UGraphemeClusterBreak;
# 1594 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
typedef enum UWordBreakValues {
    U_WB_OTHER = 0,
    U_WB_ALETTER = 1,
    U_WB_FORMAT = 2,
    U_WB_KATAKANA = 3,
    U_WB_MIDLETTER = 4,
    U_WB_MIDNUM = 5,
    U_WB_NUMERIC = 6,
    U_WB_EXTENDNUMLET = 7,
    U_WB_CR = 8,
    U_WB_EXTEND = 9,
    U_WB_LF = 10,
    U_WB_MIDNUMLET =11,
    U_WB_NEWLINE =12,
    U_WB_COUNT = 13
} UWordBreakValues;







typedef enum USentenceBreak {
    U_SB_OTHER = 0,
    U_SB_ATERM = 1,
    U_SB_CLOSE = 2,
    U_SB_FORMAT = 3,
    U_SB_LOWER = 4,
    U_SB_NUMERIC = 5,
    U_SB_OLETTER = 6,
    U_SB_SEP = 7,
    U_SB_SP = 8,
    U_SB_STERM = 9,
    U_SB_UPPER = 10,
    U_SB_CR = 11,
    U_SB_EXTEND = 12,
    U_SB_LF = 13,
    U_SB_SCONTINUE = 14,
    U_SB_COUNT = 15
} USentenceBreak;







typedef enum ULineBreak {
    U_LB_UNKNOWN = 0,
    U_LB_AMBIGUOUS = 1,
    U_LB_ALPHABETIC = 2,
    U_LB_BREAK_BOTH = 3,
    U_LB_BREAK_AFTER = 4,
    U_LB_BREAK_BEFORE = 5,
    U_LB_MANDATORY_BREAK = 6,
    U_LB_CONTINGENT_BREAK = 7,
    U_LB_CLOSE_PUNCTUATION = 8,
    U_LB_COMBINING_MARK = 9,
    U_LB_CARRIAGE_RETURN = 10,
    U_LB_EXCLAMATION = 11,
    U_LB_GLUE = 12,
    U_LB_HYPHEN = 13,
    U_LB_IDEOGRAPHIC = 14,
    U_LB_INSEPERABLE = 15,

    U_LB_INSEPARABLE=U_LB_INSEPERABLE,
    U_LB_INFIX_NUMERIC = 16,
    U_LB_LINE_FEED = 17,
    U_LB_NONSTARTER = 18,
    U_LB_NUMERIC = 19,
    U_LB_OPEN_PUNCTUATION = 20,
    U_LB_POSTFIX_NUMERIC = 21,
    U_LB_PREFIX_NUMERIC = 22,
    U_LB_QUOTATION = 23,
    U_LB_COMPLEX_CONTEXT = 24,
    U_LB_SURROGATE = 25,
    U_LB_SPACE = 26,
    U_LB_BREAK_SYMBOLS = 27,
    U_LB_ZWSPACE = 28,
    U_LB_NEXT_LINE = 29,
    U_LB_WORD_JOINER = 30,
    U_LB_H2 = 31,
    U_LB_H3 = 32,
    U_LB_JL = 33,
    U_LB_JT = 34,
    U_LB_JV = 35,
    U_LB_CLOSE_PARENTHESIS = 36,
    U_LB_COUNT = 37
} ULineBreak;







typedef enum UNumericType {
    U_NT_NONE,
    U_NT_DECIMAL,
    U_NT_DIGIT,
    U_NT_NUMERIC,
    U_NT_COUNT
} UNumericType;







typedef enum UHangulSyllableType {
    U_HST_NOT_APPLICABLE,
    U_HST_LEADING_JAMO,
    U_HST_VOWEL_JAMO,
    U_HST_TRAILING_JAMO,
    U_HST_LV_SYLLABLE,
    U_HST_LVT_SYLLABLE,
    U_HST_COUNT
} UHangulSyllableType;
# 1741 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" UBool
u_hasBinaryProperty_48(UChar32 c, UProperty which);
# 1756 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" UBool
u_isUAlphabetic_48(UChar32 c);
# 1771 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" UBool
u_isULowercase_48(UChar32 c);
# 1786 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" UBool
u_isUUppercase_48(UChar32 c);
# 1807 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" UBool
u_isUWhiteSpace_48(UChar32 c);
# 1847 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" int32_t
u_getIntPropertyValue_48(UChar32 c, UProperty which);
# 1868 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" int32_t
u_getIntPropertyMinValue_48(UProperty which);
# 1897 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" int32_t
u_getIntPropertyMaxValue_48(UProperty which);
# 1920 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" double
u_getNumericValue_48(UChar32 c);
# 1955 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" UBool
u_islower_48(UChar32 c);
# 1982 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" UBool
u_isupper_48(UChar32 c);
# 1999 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" UBool
u_istitle_48(UChar32 c);
# 2020 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" UBool
u_isdigit_48(UChar32 c);
# 2041 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" UBool
u_isalpha_48(UChar32 c);
# 2062 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" UBool
u_isalnum_48(UChar32 c);
# 2085 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" UBool
u_isxdigit_48(UChar32 c);
# 2101 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" UBool
u_ispunct_48(UChar32 c);
# 2120 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" UBool
u_isgraph_48(UChar32 c);
# 2149 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" UBool
u_isblank_48(UChar32 c);
# 2174 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" UBool
u_isdefined_48(UChar32 c);
# 2195 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" UBool
u_isspace_48(UChar32 c);
# 2216 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" UBool
u_isJavaSpaceChar_48(UChar32 c);
# 2256 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" UBool
u_isWhitespace_48(UChar32 c);
# 2280 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" UBool
u_iscntrl_48(UChar32 c);
# 2295 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" UBool
u_isISOControl_48(UChar32 c);
# 2313 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" UBool
u_isprint_48(UChar32 c);
# 2334 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" UBool
u_isbase_48(UChar32 c);
# 2353 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" UCharDirection
u_charDirection_48(UChar32 c);
# 2371 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" UBool
u_isMirrored_48(UChar32 c);
# 2393 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" UChar32
u_charMirror_48(UChar32 c);
# 2407 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" int8_t
u_charType_48(UChar32 c);
# 2442 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
typedef UBool
UCharEnumTypeRange(const void *context, UChar32 start, UChar32 limit, UCharCategory type);
# 2464 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" void
u_enumCharTypes_48(UCharEnumTypeRange *enumRange, const void *context);
# 2476 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" uint8_t
u_getCombiningClass_48(UChar32 c);
# 2504 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" int32_t
u_charDigitValue_48(UChar32 c);
# 2516 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" UBlockCode
ublock_getCode_48(UChar32 c);
# 2551 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" int32_t
u_charName_48(UChar32 code, UCharNameChoice nameChoice,
           char *buffer, int32_t bufferLength,
           UErrorCode *pErrorCode);
# 2581 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" int32_t
u_getISOComment_48(UChar32 c,
                char *dest, int32_t destCapacity,
                UErrorCode *pErrorCode);
# 2606 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" UChar32
u_charFromName_48(UCharNameChoice nameChoice,
               const char *name,
               UErrorCode *pErrorCode);
# 2628 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
typedef UBool UEnumCharNamesFn(void *context,
                               UChar32 code,
                               UCharNameChoice nameChoice,
                               const char *name,
                               int32_t length);
# 2655 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" void
u_enumCharNames_48(UChar32 start, UChar32 limit,
                UEnumCharNamesFn *fn,
                void *context,
                UCharNameChoice nameChoice,
                UErrorCode *pErrorCode);
# 2693 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" const char*
u_getPropertyName_48(UProperty property,
                  UPropertyNameChoice nameChoice);
# 2716 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" UProperty
u_getPropertyEnum_48(const char* alias);
# 2766 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" const char*
u_getPropertyValueName_48(UProperty property,
                       int32_t value,
                       UPropertyNameChoice nameChoice);
# 2802 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" int32_t
u_getPropertyValueEnum_48(UProperty property,
                       const char* alias);
# 2823 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" UBool
u_isIDStart_48(UChar32 c);
# 2847 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" UBool
u_isIDPart_48(UChar32 c);
# 2870 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" UBool
u_isIDIgnorable_48(UChar32 c);
# 2889 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" UBool
u_isJavaIDStart_48(UChar32 c);
# 2910 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" UBool
u_isJavaIDPart_48(UChar32 c);
# 2935 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" UChar32
u_tolower_48(UChar32 c);
# 2960 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" UChar32
u_toupper_48(UChar32 c);
# 2985 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" UChar32
u_totitle_48(UChar32 c);
# 3031 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" UChar32
u_foldCase_48(UChar32 c, uint32_t options);
# 3072 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" int32_t
u_digit_48(UChar32 ch, int8_t radix);
# 3103 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" UChar32
u_forDigit_48(int32_t digit, int8_t radix);
# 3120 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" void
u_charAge_48(UChar32 c, UVersionInfo versionArray);
# 3134 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" void
u_getUnicodeVersion_48(UVersionInfo versionArray);
# 3159 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h"
extern "C" int32_t
u_getFC_NFKC_Closure_48(UChar32 c, UChar *dest, int32_t destCapacity, UErrorCode *pErrorCode);




}
# 18 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/propname.h" 2
# 1 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/udataswp.h" 1
# 29 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/udataswp.h"
extern "C" {

struct UDataSwapper;
typedef struct UDataSwapper UDataSwapper;
# 87 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/udataswp.h"
typedef int32_t
UDataSwapFn(const UDataSwapper *ds,
            const void *inData, int32_t length, void *outData,
            UErrorCode *pErrorCode);





typedef uint16_t
UDataReadUInt16(uint16_t x);





typedef uint32_t
UDataReadUInt32(uint32_t x);





typedef void
UDataWriteUInt16(uint16_t *p, uint16_t x);





typedef void
UDataWriteUInt32(uint32_t *p, uint32_t x);
# 130 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/udataswp.h"
typedef int32_t
UDataCompareInvChars(const UDataSwapper *ds,
                     const char *outString, int32_t outLength,
                     const UChar *localString, int32_t localLength);
# 146 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/udataswp.h"
typedef void
UDataPrintError(void *context, const char *fmt, va_list args);

struct UDataSwapper {

    UBool inIsBigEndian;

    uint8_t inCharset;

    UBool outIsBigEndian;

    uint8_t outCharset;




    UDataReadUInt16 *readUInt16;

    UDataReadUInt32 *readUInt32;

    UDataCompareInvChars *compareInvChars;




    UDataWriteUInt16 *writeUInt16;

    UDataWriteUInt32 *writeUInt32;




    UDataSwapFn *swapArray16;

    UDataSwapFn *swapArray32;

    UDataSwapFn *swapInvChars;






    UDataPrintError *printError;

    void *printErrorContext;
};

}

extern "C" UDataSwapper *
udata_openSwapper_48(UBool inIsBigEndian, uint8_t inCharset,
                  UBool outIsBigEndian, uint8_t outCharset,
                  UErrorCode *pErrorCode);
# 210 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/udataswp.h"
extern "C" UDataSwapper *
udata_openSwapperForInputData_48(const void *data, int32_t length,
                              UBool outIsBigEndian, uint8_t outCharset,
                              UErrorCode *pErrorCode);

extern "C" void
udata_closeSwapper_48(UDataSwapper *ds);
# 227 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/udataswp.h"
extern "C" int32_t
udata_swapDataHeader_48(const UDataSwapper *ds,
                     const void *inData, int32_t length, void *outData,
                     UErrorCode *pErrorCode);





extern "C" int16_t
udata_readInt16_48(const UDataSwapper *ds, int16_t x);





extern "C" int32_t
udata_readInt32_48(const UDataSwapper *ds, int32_t x);






extern "C" int32_t
udata_swapInvStringBlock_48(const UDataSwapper *ds,
                         const void *inData, int32_t length, void *outData,
                         UErrorCode *pErrorCode);

extern "C" void
udata_printError_48(const UDataSwapper *ds,
                 const char *fmt,
                 ...);
# 269 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/udataswp.h"
extern "C" int32_t
uprv_ebcdicFromAscii_48(const UDataSwapper *ds,
                     const void *inData, int32_t length, void *outData,
                     UErrorCode *pErrorCode);





extern "C" int32_t
uprv_copyAscii_48(const UDataSwapper *ds,
               const void *inData, int32_t length, void *outData,
               UErrorCode *pErrorCode);





extern "C" int32_t
uprv_asciiFromEbcdic_48(const UDataSwapper *ds,
                     const void *inData, int32_t length, void *outData,
                     UErrorCode *pErrorCode);





extern "C" int32_t
uprv_copyEbcdic_48(const UDataSwapper *ds,
                const void *inData, int32_t length, void *outData,
                UErrorCode *pErrorCode);





extern "C" int32_t
uprv_compareInvAscii_48(const UDataSwapper *ds,
                     const char *outString, int32_t outLength,
                     const UChar *localString, int32_t localLength);





extern "C" int32_t
uprv_compareInvEbcdic_48(const UDataSwapper *ds,
                      const char *outString, int32_t outLength,
                      const UChar *localString, int32_t localLength);
# 19 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/propname.h" 2
# 1 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/uprops.h" 1
# 24 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/uprops.h"
# 1 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h" 1
# 31 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
# 1 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uchar.h" 1
# 32 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h" 2
# 1 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/localpointer.h" 1
# 43 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/localpointer.h"
extern "C++" { namespace icu_48 {
# 63 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/localpointer.h"
template<typename T>
class LocalPointerBase {
public:





    explicit LocalPointerBase(T *p=__null) : ptr(p) {}





    ~LocalPointerBase() { }





    UBool isNull() const { return ptr==__null; }





    UBool isValid() const { return ptr!=__null; }







    bool operator==(const T *other) const { return ptr==other; }







    bool operator!=(const T *other) const { return ptr!=other; }





    T *getAlias() const { return ptr; }





    T &operator*() const { return *ptr; }





    T *operator->() const { return ptr; }






    T *orphan() {
        T *p=ptr;
        ptr=__null;
        return p;
    }







    void adoptInstead(T *p) {

        ptr=p;
    }
protected:
    T *ptr;
private:

    bool operator==(const LocalPointerBase &other);
    bool operator!=(const LocalPointerBase &other);

    LocalPointerBase(const LocalPointerBase &other);
    void operator=(const LocalPointerBase &other);

    static void * operator new(size_t size);
    static void * operator new[](size_t size);

    static void * operator new(size_t, void *ptr);

};
# 181 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/localpointer.h"
template<typename T>
class LocalPointer : public LocalPointerBase<T> {
public:





    explicit LocalPointer(T *p=__null) : LocalPointerBase<T>(p) {}




    ~LocalPointer() {
        delete LocalPointerBase<T>::ptr;
    }






    void adoptInstead(T *p) {
        delete LocalPointerBase<T>::ptr;
        LocalPointerBase<T>::ptr=p;
    }
};
# 227 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/localpointer.h"
template<typename T>
class LocalArray : public LocalPointerBase<T> {
public:





    explicit LocalArray(T *p=__null) : LocalPointerBase<T>(p) {}




    ~LocalArray() {
        delete[] LocalPointerBase<T>::ptr;
    }






    void adoptInstead(T *p) {
        delete[] LocalPointerBase<T>::ptr;
        LocalPointerBase<T>::ptr=p;
    }







    T &operator[](ptrdiff_t i) const { return LocalPointerBase<T>::ptr[i]; }
};
# 297 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/localpointer.h"
} }
# 33 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h" 2


struct USet;





typedef struct USet USet;







enum {




    USET_IGNORE_SPACE = 1,
# 82 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
    USET_CASE_INSENSITIVE = 2,
# 92 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
    USET_ADD_CASE_MAPPINGS = 4,





    USET_SERIALIZED_STATIC_ARRAY_CAPACITY=8
};
# 156 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
typedef enum USetSpanCondition {
# 168 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
    USET_SPAN_NOT_CONTAINED = 0,
# 183 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
    USET_SPAN_CONTAINED = 1,
# 202 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
    USET_SPAN_SIMPLE = 2,




    USET_SPAN_CONDITION_COUNT
} USetSpanCondition;






typedef struct USerializedSet {




    const uint16_t *array;




    int32_t bmpLength;




    int32_t length;




    uint16_t staticArray[USET_SERIALIZED_STATIC_ARRAY_CAPACITY];
} USerializedSet;
# 249 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" USet*
uset_openEmpty_48();
# 262 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" USet*
uset_open_48(UChar32 start, UChar32 end);
# 274 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" USet*
uset_openPattern_48(const UChar* pattern, int32_t patternLength,
                 UErrorCode* ec);
# 289 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" USet*
uset_openPatternOptions_48(const UChar* pattern, int32_t patternLength,
                 uint32_t options,
                 UErrorCode* ec);







extern "C" void
uset_close_48(USet* set);



extern "C++" { namespace icu_48 {
# 316 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
class LocalUSetPointer : public LocalPointerBase<USet> { public: explicit LocalUSetPointer(USet *p=__null) : LocalPointerBase<USet>(p) {} ~LocalUSetPointer() { uset_close_48(ptr); } void adoptInstead(USet *p) { uset_close_48(ptr); ptr=p; } };

} }
# 331 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" USet *
uset_clone_48(const USet *set);
# 343 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" UBool
uset_isFrozen_48(const USet *set);
# 360 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" void
uset_freeze_48(USet *set);
# 373 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" USet *
uset_cloneAsThawed_48(const USet *set);
# 385 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" void
uset_set_48(USet* set,
         UChar32 start, UChar32 end);
# 410 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" int32_t
uset_applyPattern_48(USet *set,
                  const UChar *pattern, int32_t patternLength,
                  uint32_t options,
                  UErrorCode *status);
# 438 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" void
uset_applyIntPropertyValue_48(USet* set,
                           UProperty prop, int32_t value, UErrorCode* ec);
# 477 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" void
uset_applyPropertyAlias_48(USet* set,
                        const UChar *prop, int32_t propLength,
                        const UChar *value, int32_t valueLength,
                        UErrorCode* ec);
# 492 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" UBool
uset_resemblesPattern_48(const UChar *pattern, int32_t patternLength,
                      int32_t pos);
# 511 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" int32_t
uset_toPattern_48(const USet* set,
               UChar* result, int32_t resultCapacity,
               UBool escapeUnprintable,
               UErrorCode* ec);
# 525 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" void
uset_add_48(USet* set, UChar32 c);
# 540 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" void
uset_addAll_48(USet* set, const USet *additionalSet);
# 552 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" void
uset_addRange_48(USet* set, UChar32 start, UChar32 end);
# 564 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" void
uset_addString_48(USet* set, const UChar* str, int32_t strLen);
# 576 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" void
uset_addAllCodePoints_48(USet* set, const UChar *str, int32_t strLen);
# 587 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" void
uset_remove_48(USet* set, UChar32 c);
# 599 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" void
uset_removeRange_48(USet* set, UChar32 start, UChar32 end);
# 611 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" void
uset_removeString_48(USet* set, const UChar* str, int32_t strLen);
# 625 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" void
uset_removeAll_48(USet* set, const USet* removeSet);
# 642 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" void
uset_retain_48(USet* set, UChar32 start, UChar32 end);
# 657 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" void
uset_retainAll_48(USet* set, const USet* retain);
# 668 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" void
uset_compact_48(USet* set);
# 679 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" void
uset_complement_48(USet* set);
# 693 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" void
uset_complementAll_48(USet* set, const USet* complement);
# 703 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" void
uset_clear_48(USet* set);
# 732 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" void
uset_closeOver_48(USet* set, int32_t attributes);







extern "C" void
uset_removeAllStrings_48(USet* set);
# 751 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" UBool
uset_isEmpty_48(const USet* set);
# 762 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" UBool
uset_contains_48(const USet* set, UChar32 c);
# 774 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" UBool
uset_containsRange_48(const USet* set, UChar32 start, UChar32 end);
# 785 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" UBool
uset_containsString_48(const USet* set, const UChar* str, int32_t strLen);
# 798 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" int32_t
uset_indexOf_48(const USet* set, UChar32 c);
# 811 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" UChar32
uset_charAt_48(const USet* set, int32_t charIndex);
# 822 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" int32_t
uset_size_48(const USet* set);
# 833 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" int32_t
uset_getItemCount_48(const USet* set);
# 854 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" int32_t
uset_getItem_48(const USet* set, int32_t itemIndex,
             UChar32* start, UChar32* end,
             UChar* str, int32_t strCapacity,
             UErrorCode* ec);
# 868 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" UBool
uset_containsAll_48(const USet* set1, const USet* set2);
# 881 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" UBool
uset_containsAllCodePoints_48(const USet* set, const UChar *str, int32_t strLen);
# 892 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" UBool
uset_containsNone_48(const USet* set1, const USet* set2);
# 903 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" UBool
uset_containsSome_48(const USet* set1, const USet* set2);
# 925 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" int32_t
uset_span_48(const USet *set, const UChar *s, int32_t length, USetSpanCondition spanCondition);
# 946 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" int32_t
uset_spanBack_48(const USet *set, const UChar *s, int32_t length, USetSpanCondition spanCondition);
# 968 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" int32_t
uset_spanUTF8_48(const USet *set, const char *s, int32_t length, USetSpanCondition spanCondition);
# 989 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" int32_t
uset_spanBackUTF8_48(const USet *set, const char *s, int32_t length, USetSpanCondition spanCondition);
# 1000 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" UBool
uset_equals_48(const USet* set1, const USet* set2);
# 1056 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" int32_t
uset_serialize_48(const USet* set, uint16_t* dest, int32_t destCapacity, UErrorCode* pErrorCode);
# 1067 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" UBool
uset_getSerializedSet_48(USerializedSet* fillSet, const uint16_t* src, int32_t srcLength);
# 1077 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" void
uset_setSerializedToOne_48(USerializedSet* fillSet, UChar32 c);
# 1088 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" UBool
uset_serializedContains_48(const USerializedSet* set, UChar32 c);
# 1100 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" int32_t
uset_getSerializedRangeCount_48(const USerializedSet* set);
# 1116 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uset.h"
extern "C" UBool
uset_getSerializedRange_48(const USerializedSet* set, int32_t rangeIndex,
                        UChar32* pStart, UChar32* pEnd);
# 25 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/uprops.h" 2
# 1 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/uset_imp.h" 1
# 25 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/uset_imp.h"
extern "C" {

typedef void
USetAdd(USet *set, UChar32 c);

typedef void
USetAddRange(USet *set, UChar32 start, UChar32 end);

typedef void
USetAddString(USet *set, const UChar *str, int32_t length);

typedef void
USetRemove(USet *set, UChar32 c);

typedef void
USetRemoveRange(USet *set, UChar32 start, UChar32 end);






struct USetAdder {
    USet *set;
    USetAdd *add;
    USetAddRange *addRange;
    USetAddString *addString;
    USetRemove *remove;
    USetRemoveRange *removeRange;
};
typedef struct USetAdder USetAdder;

}
# 26 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/uprops.h" 2



enum {
    UPROPS_PROPS32_INDEX,
    UPROPS_EXCEPTIONS_INDEX,
    UPROPS_EXCEPTIONS_TOP_INDEX,

    UPROPS_ADDITIONAL_TRIE_INDEX,
    UPROPS_ADDITIONAL_VECTORS_INDEX,
    UPROPS_ADDITIONAL_VECTORS_COLUMNS_INDEX,

    UPROPS_SCRIPT_EXTENSIONS_INDEX,

    UPROPS_RESERVED_INDEX_7,
    UPROPS_RESERVED_INDEX_8,


    UPROPS_DATA_TOP_INDEX,


    UPROPS_MAX_VALUES_INDEX=10,

    UPROPS_MAX_VALUES_2_INDEX,

    UPROPS_INDEX_COUNT=16
};


enum {


    UPROPS_NUMERIC_TYPE_VALUE_SHIFT=6
};







enum {
    UPROPS_NTV_NONE=0,
    UPROPS_NTV_DECIMAL_START=1,
    UPROPS_NTV_DIGIT_START=11,
    UPROPS_NTV_NUMERIC_START=21,
    UPROPS_NTV_FRACTION_START=0xb0,
    UPROPS_NTV_LARGE_START=0x1e0,
    UPROPS_NTV_RESERVED_START=0x300,

    UPROPS_NTV_MAX_SMALL_INT=UPROPS_NTV_FRACTION_START-UPROPS_NTV_NUMERIC_START-1
};
# 135 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/uprops.h"
enum {
    UPROPS_WHITE_SPACE,
    UPROPS_DASH,
    UPROPS_HYPHEN,
    UPROPS_QUOTATION_MARK,
    UPROPS_TERMINAL_PUNCTUATION,
    UPROPS_MATH,
    UPROPS_HEX_DIGIT,
    UPROPS_ASCII_HEX_DIGIT,
    UPROPS_ALPHABETIC,
    UPROPS_IDEOGRAPHIC,
    UPROPS_DIACRITIC,
    UPROPS_EXTENDER,
    UPROPS_NONCHARACTER_CODE_POINT,
    UPROPS_GRAPHEME_EXTEND,
    UPROPS_GRAPHEME_LINK,
    UPROPS_IDS_BINARY_OPERATOR,
    UPROPS_IDS_TRINARY_OPERATOR,
    UPROPS_RADICAL,
    UPROPS_UNIFIED_IDEOGRAPH,
    UPROPS_DEFAULT_IGNORABLE_CODE_POINT,
    UPROPS_DEPRECATED,
    UPROPS_LOGICAL_ORDER_EXCEPTION,
    UPROPS_XID_START,
    UPROPS_XID_CONTINUE,
    UPROPS_ID_START,
    UPROPS_ID_CONTINUE,
    UPROPS_GRAPHEME_BASE,
    UPROPS_S_TERM,
    UPROPS_VARIATION_SELECTOR,
    UPROPS_PATTERN_SYNTAX,
    UPROPS_PATTERN_WHITE_SPACE,
    UPROPS_RESERVED,
    UPROPS_BINARY_1_TOP
};
# 201 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/uprops.h"
extern "C" uint32_t
u_getUnicodeProperties_48(UChar32 c, int32_t column);
# 217 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/uprops.h"
extern "C" int32_t
uprv_getMaxValues_48(int32_t column);





extern "C" UBool
u_isalnumPOSIX_48(UChar32 c);
# 234 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/uprops.h"
extern "C" UBool
u_isgraphPOSIX_48(UChar32 c);






extern "C" UBool
u_isprintPOSIX_48(UChar32 c);
# 281 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/uprops.h"
enum {
    TAB =0x0009,
    LF =0x000a,
    FF =0x000c,
    CR =0x000d,
    U_A =0x0041,
    U_F =0x0046,
    U_Z =0x005a,
    U_a =0x0061,
    U_f =0x0066,
    U_z =0x007a,
    DEL =0x007f,
    NL =0x0085,
    NBSP =0x00a0,
    CGJ =0x034f,
    FIGURESP=0x2007,
    HAIRSP =0x200a,
    ZWNJ =0x200c,
    ZWJ =0x200d,
    RLM =0x200f,
    NNBSP =0x202f,
    WJ =0x2060,
    INHSWAP =0x206a,
    NOMDIG =0x206f,
    U_FW_A =0xff21,
    U_FW_F =0xff26,
    U_FW_Z =0xff3a,
    U_FW_a =0xff41,
    U_FW_f =0xff46,
    U_FW_z =0xff5a,
    ZWNBSP =0xfeff
};





extern "C" int32_t
uprv_getMaxCharNameLength_48(void);







extern "C" void
uprv_getCharNameCharacters_48(const USetAdder *sa);






enum UPropertySource {

    UPROPS_SRC_NONE,

    UPROPS_SRC_CHAR,

    UPROPS_SRC_PROPSVEC,

    UPROPS_SRC_NAMES,

    UPROPS_SRC_CASE,

    UPROPS_SRC_BIDI,

    UPROPS_SRC_CHAR_AND_PROPSVEC,

    UPROPS_SRC_CASE_AND_NORM,

    UPROPS_SRC_NFC,

    UPROPS_SRC_NFKC,

    UPROPS_SRC_NFKC_CF,

    UPROPS_SRC_NFC_CANON_ITER,

    UPROPS_SRC_COUNT
};
typedef enum UPropertySource UPropertySource;





extern "C" UPropertySource
uprops_getSource_48(UProperty which);






extern "C" void
uchar_addPropertyStarts_48(const USetAdder *sa, UErrorCode *pErrorCode);






extern "C" void
upropsvec_addPropertyStarts_48(const USetAdder *sa, UErrorCode *pErrorCode);
# 404 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/uprops.h"
extern "C" int32_t
uchar_swapNames_48(const UDataSwapper *ds,
                const void *inData, int32_t length, void *outData,
                UErrorCode *pErrorCode);



extern "C++" { namespace icu_48 {

class UnicodeSet;


extern "C" UnicodeSet *
uniset_getUnicode32Instance_48(UErrorCode &errorCode);

} }
# 20 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/propname.h" 2
# 31 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/propname.h"
extern "C" {
# 51 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/propname.h"
extern "C" int32_t
uprv_compareASCIIPropertyNames_48(const char *name1, const char *name2);

extern "C" int32_t
uprv_compareEBCDICPropertyNames_48(const char *name1, const char *name2);
# 65 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/propname.h"
}
# 80 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/propname.h"
extern "C++" { namespace icu_48 {

class PropNameData {
public:
    enum {

        IX_VALUE_MAPS_OFFSET,
        IX_BYTE_TRIES_OFFSET,
        IX_NAME_GROUPS_OFFSET,
        IX_RESERVED3_OFFSET,
        IX_RESERVED4_OFFSET,
        IX_TOTAL_SIZE,


        IX_MAX_NAME_LENGTH,
        IX_RESERVED7,
        IX_COUNT
    };

    static const char *getPropertyName(int32_t property, int32_t nameChoice);
    static const char *getPropertyValueName(int32_t property, int32_t value, int32_t nameChoice);

    static int32_t getPropertyEnum(const char *alias);
    static int32_t getPropertyValueEnum(int32_t property, const char *alias);

private:
    static int32_t findProperty(int32_t property);
    static int32_t findPropertyValueNameGroup(int32_t valueMapIndex, int32_t value);
    static const char *getName(const char *nameGroup, int32_t nameIndex);
    static UBool containsName(BytesTrie &trie, const char *name);

    static int32_t getPropertyOrValueEnum(int32_t bytesTrieOffset, const char *alias);

    static const int32_t indexes[];
    static const int32_t valueMaps[];
    static const uint8_t bytesTries[];
    static const char nameGroups[];
};
# 208 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/propname.h"
} }
# 13 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/propname.cpp" 2

# 1 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/udata.h" 1
# 23 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/udata.h"
extern "C" {
# 106 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/udata.h"
typedef struct {


    uint16_t size;



    uint16_t reservedWord;




    uint8_t isBigEndian;



    uint8_t charsetFamily;



    uint8_t sizeofUChar;



    uint8_t reservedByte;



    uint8_t dataFormat[4];



    uint8_t formatVersion[4];



    uint8_t dataVersion[4];
} UDataInfo;







typedef struct UDataMemory UDataMemory;
# 166 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/udata.h"
typedef UBool
UDataMemoryIsAcceptable(void *context,
                        const char *type, const char *name,
                        const UDataInfo *pInfo);
# 193 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/udata.h"
extern "C" UDataMemory *
udata_open_48(const char *path, const char *type, const char *name,
           UErrorCode *pErrorCode);
# 245 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/udata.h"
extern "C" UDataMemory *
udata_openChoice_48(const char *path, const char *type, const char *name,
                 UDataMemoryIsAcceptable *isAcceptable, void *context,
                 UErrorCode *pErrorCode);
# 257 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/udata.h"
extern "C" void
udata_close_48(UDataMemory *pData);



extern "C++" { namespace icu_48 {
# 273 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/udata.h"
class LocalUDataMemoryPointer : public LocalPointerBase<UDataMemory> { public: explicit LocalUDataMemoryPointer(UDataMemory *p=__null) : LocalPointerBase<UDataMemory>(p) {} ~LocalUDataMemoryPointer() { udata_close_48(ptr); } void adoptInstead(UDataMemory *p) { udata_close_48(ptr); ptr=p; } };

} }
# 285 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/udata.h"
extern "C" const void *
udata_getMemory_48(UDataMemory *pData);
# 306 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/udata.h"
extern "C" void
udata_getInfo_48(UDataMemory *pData, UDataInfo *pInfo);
# 349 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/udata.h"
extern "C" void
udata_setCommonData_48(const void *data, UErrorCode *err);
# 377 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/udata.h"
extern "C" void
udata_setAppData_48(const char *packageName, const void *data, UErrorCode *err);






typedef enum UDataFileAccess {

    UDATA_FILES_FIRST,

    UDATA_ONLY_PACKAGES,


    UDATA_PACKAGES_FIRST,

    UDATA_NO_FILES,

    UDATA_DEFAULT_ACCESS = UDATA_FILES_FIRST,
    UDATA_FILE_ACCESS_COUNT
} UDataFileAccess;
# 410 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/udata.h"
extern "C" void
udata_setFileAccess_48(UDataFileAccess access, UErrorCode *status);

}
# 15 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/propname.cpp" 2
# 1 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/umutex.h" 1
# 22 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/umutex.h"
# 1 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uclean.h" 1
# 52 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uclean.h"
extern "C" void
u_init_48(UErrorCode *status);
# 100 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uclean.h"
extern "C" void
u_cleanup_48(void);
# 113 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uclean.h"
typedef void *UMTX;
# 131 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uclean.h"
typedef void UMtxInitFn (const void *context, UMTX *mutex, UErrorCode* status);
# 143 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uclean.h"
typedef void UMtxFn (const void *context, UMTX *mutex);
# 165 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uclean.h"
extern "C" void
u_setMutexFunctions_48(const void *context, UMtxInitFn *init, UMtxFn *destroy, UMtxFn *lock, UMtxFn *unlock,
                    UErrorCode *status);
# 178 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uclean.h"
typedef int32_t UMtxAtomicFn(const void *context, int32_t *p);
# 195 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uclean.h"
extern "C" void
u_setAtomicIncDecFunctions_48(const void *context, UMtxAtomicFn *inc, UMtxAtomicFn *dec,
                    UErrorCode *status);
# 209 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uclean.h"
typedef void * UMemAllocFn(const void *context, size_t size);
# 218 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uclean.h"
typedef void * UMemReallocFn(const void *context, void *mem, size_t size);
# 229 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uclean.h"
typedef void UMemFreeFn (const void *context, void *mem);
# 247 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/uclean.h"
extern "C" void
u_setMemoryFunctions_48(const void *context, UMemAllocFn *a, UMemReallocFn *r, UMemFreeFn *f,
                    UErrorCode *status);
# 23 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/umutex.h" 2
# 141 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/umutex.h"
extern "C" void umtx_lock_48 ( UMTX* mutex );






extern "C" void umtx_unlock_48 ( UMTX* mutex );
# 159 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/umutex.h"
extern "C" void umtx_init_48 ( UMTX* mutex );
# 169 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/umutex.h"
extern "C" void umtx_destroy_48( UMTX *mutex );
# 180 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/umutex.h"
extern "C" int32_t umtx_atomic_inc_48(int32_t *);
extern "C" int32_t umtx_atomic_dec_48(int32_t *);
# 16 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/propname.cpp" 2
# 1 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/cmemory.h" 1
# 28 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/cmemory.h"
# 1 "c:/marmalade/5.2/s3e/h/std/string.h" 1
# 29 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/cmemory.h" 2

# 1 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/unicode/localpointer.h" 1
# 31 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/cmemory.h" 2






extern "C" void *
uprv_malloc_48(size_t s);

extern "C" void *
uprv_realloc_48(void *mem, size_t size);

extern "C" void
uprv_free_48(void *mem);





typedef union {
    long t1;
    double t2;
    void *t3;
} UAlignedMemory;
# 83 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/cmemory.h"
extern "C" UBool
cmemory_inUse_48(void);






extern "C" UBool
cmemory_cleanup_48(void);



extern "C++" { namespace icu_48 {
# 105 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/cmemory.h"
template<typename T>
class LocalMemory : public LocalPointerBase<T> {
public:




    explicit LocalMemory(T *p=__null) : LocalPointerBase<T>(p) {}



    ~LocalMemory() {
        uprv_free_48(LocalPointerBase<T>::ptr);
    }





    void adoptInstead(T *p) {
        uprv_free_48(LocalPointerBase<T>::ptr);
        LocalPointerBase<T>::ptr=p;
    }
# 136 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/cmemory.h"
    inline T *allocateInsteadAndReset(int32_t newCapacity=1);
# 148 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/cmemory.h"
    inline T *allocateInsteadAndCopy(int32_t newCapacity=1, int32_t length=0);






    T &operator[](ptrdiff_t i) const { return LocalPointerBase<T>::ptr[i]; }
};

template<typename T>
inline T *LocalMemory<T>::allocateInsteadAndReset(int32_t newCapacity) {
    if(newCapacity>0) {
        T *p=(T *)uprv_malloc_48(newCapacity*sizeof(T));
        if(p!=__null) {
            :: memset(p, 0, newCapacity*sizeof(T));
            uprv_free_48(LocalPointerBase<T>::ptr);
            LocalPointerBase<T>::ptr=p;
        }
        return p;
    } else {
        return __null;
    }
}


template<typename T>
inline T *LocalMemory<T>::allocateInsteadAndCopy(int32_t newCapacity, int32_t length) {
    if(newCapacity>0) {
        T *p=(T *)uprv_malloc_48(newCapacity*sizeof(T));
        if(p!=__null) {
            if(length>0) {
                if(length>newCapacity) {
                    length=newCapacity;
                }
                :: memcpy(p, LocalPointerBase<T>::ptr, length*sizeof(T));
            }
            uprv_free_48(LocalPointerBase<T>::ptr);
            LocalPointerBase<T>::ptr=p;
        }
        return p;
    } else {
        return __null;
    }
}
# 205 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/cmemory.h"
template<typename T, int32_t stackCapacity>
class MaybeStackArray {
public:



    MaybeStackArray() : ptr(stackArray), capacity(stackCapacity), needToRelease(0) {}



    ~MaybeStackArray() { releaseArray(); }




    int32_t getCapacity() const { return capacity; }




    T *getAlias() const { return ptr; }




    T *getArrayLimit() const { return getAlias()+capacity; }





    operator T *() const { return ptr; }






    T &operator[](ptrdiff_t i) { return ptr[i]; }






    void aliasInstead(T *otherArray, int32_t otherCapacity) {
        if(otherArray!=__null && otherCapacity>0) {
            releaseArray();
            ptr=otherArray;
            capacity=otherCapacity;
            needToRelease=0;
        }
    }
# 268 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/cmemory.h"
    inline T *resize(int32_t newCapacity, int32_t length=0);
# 279 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/cmemory.h"
    inline T *orphanOrClone(int32_t length, int32_t &resultCapacity);
private:
    T *ptr;
    int32_t capacity;
    UBool needToRelease;
    T stackArray[stackCapacity];
    void releaseArray() {
        if(needToRelease) {
            uprv_free_48(ptr);
        }
    }

    bool operator==(const MaybeStackArray & ) {return 0;}
    bool operator!=(const MaybeStackArray & ) {return 1;}

    MaybeStackArray(const MaybeStackArray & ) {}
    void operator=(const MaybeStackArray & ) {}
# 310 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/cmemory.h"
};

template<typename T, int32_t stackCapacity>
inline T *MaybeStackArray<T, stackCapacity>::resize(int32_t newCapacity, int32_t length) {
    if(newCapacity>0) {
        T *p=(T *)uprv_malloc_48(newCapacity*sizeof(T));
        if(p!=__null) {
            if(length>0) {
                if(length>capacity) {
                    length=capacity;
                }
                if(length>newCapacity) {
                    length=newCapacity;
                }
                :: memcpy(p, ptr, length*sizeof(T));
            }
            releaseArray();
            ptr=p;
            capacity=newCapacity;
            needToRelease=1;
        }
        return p;
    } else {
        return __null;
    }
}

template<typename T, int32_t stackCapacity>
inline T *MaybeStackArray<T, stackCapacity>::orphanOrClone(int32_t length, int32_t &resultCapacity) {
    T *p;
    if(needToRelease) {
        p=ptr;
    } else if(length<=0) {
        return __null;
    } else {
        if(length>capacity) {
            length=capacity;
        }
        p=(T *)uprv_malloc_48(length*sizeof(T));
        if(p==__null) {
            return __null;
        }
        :: memcpy(p, ptr, length*sizeof(T));
    }
    resultCapacity=length;
    ptr=stackArray;
    capacity=stackCapacity;
    needToRelease=0;
    return p;
}
# 371 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/cmemory.h"
template<typename H, typename T, int32_t stackCapacity>
class MaybeStackHeaderAndArray {
public:



    MaybeStackHeaderAndArray() : ptr(&stackHeader), capacity(stackCapacity), needToRelease(0) {}



    ~MaybeStackHeaderAndArray() { releaseMemory(); }




    int32_t getCapacity() const { return capacity; }




    H *getAlias() const { return ptr; }




    T *getArrayStart() const { return reinterpret_cast<T *>(getAlias()+1); }




    T *getArrayLimit() const { return getArrayStart()+capacity; }





    operator H *() const { return ptr; }






    T &operator[](ptrdiff_t i) { return getArrayStart()[i]; }






    void aliasInstead(H *otherMemory, int32_t otherCapacity) {
        if(otherMemory!=__null && otherCapacity>0) {
            releaseMemory();
            ptr=otherMemory;
            capacity=otherCapacity;
            needToRelease=0;
        }
    }
# 440 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/cmemory.h"
    inline H *resize(int32_t newCapacity, int32_t length=0);
# 451 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/cmemory.h"
    inline H *orphanOrClone(int32_t length, int32_t &resultCapacity);
private:
    H *ptr;
    int32_t capacity;
    UBool needToRelease;

    H stackHeader;
    T stackArray[stackCapacity];
    void releaseMemory() {
        if(needToRelease) {
            uprv_free_48(ptr);
        }
    }

    bool operator==(const MaybeStackHeaderAndArray & ) {return 0;}
    bool operator!=(const MaybeStackHeaderAndArray & ) {return 1;}

    MaybeStackHeaderAndArray(const MaybeStackHeaderAndArray & ) {}
    void operator=(const MaybeStackHeaderAndArray & ) {}
# 479 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/cmemory.h"
};

template<typename H, typename T, int32_t stackCapacity>
inline H *MaybeStackHeaderAndArray<H, T, stackCapacity>::resize(int32_t newCapacity,
                                                                int32_t length) {
    if(newCapacity>=0) {
        H *p=(H *)uprv_malloc_48(sizeof(H)+newCapacity*sizeof(T));
        if(p!=__null) {
            if(length<0) {
                length=0;
            } else if(length>0) {
                if(length>capacity) {
                    length=capacity;
                }
                if(length>newCapacity) {
                    length=newCapacity;
                }
            }
            :: memcpy(p, ptr, sizeof(H)+length*sizeof(T));
            releaseMemory();
            ptr=p;
            capacity=newCapacity;
            needToRelease=1;
        }
        return p;
    } else {
        return __null;
    }
}

template<typename H, typename T, int32_t stackCapacity>
inline H *MaybeStackHeaderAndArray<H, T, stackCapacity>::orphanOrClone(int32_t length,
                                                                       int32_t &resultCapacity) {
    H *p;
    if(needToRelease) {
        p=ptr;
    } else {
        if(length<0) {
            length=0;
        } else if(length>capacity) {
            length=capacity;
        }
        p=(H *)uprv_malloc_48(sizeof(H)+length*sizeof(T));
        if(p==__null) {
            return __null;
        }
        :: memcpy(p, ptr, sizeof(H)+length*sizeof(T));
    }
    resultCapacity=length;
    ptr=&stackHeader;
    capacity=stackCapacity;
    needToRelease=0;
    return p;
}

} }
# 17 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/propname.cpp" 2
# 1 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/cstring.h" 1
# 30 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/cstring.h"
# 1 "c:/marmalade/5.2/s3e/h/std/stdlib.h" 1
# 31 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/cstring.h" 2
# 44 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/cstring.h"
extern "C" char
uprv_toupper_48(char c);


extern "C" char
uprv_asciitolower_48(char c);

extern "C" char
uprv_ebcdictolower_48(char c);
# 85 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/cstring.h"
extern "C" char*
uprv_strdup_48(const char *src);
# 96 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/cstring.h"
extern "C" char*
uprv_strndup_48(const char *src, int32_t n);

extern "C" char*
T_CString_toLowerCase_48(char* str);

extern "C" char*
T_CString_toUpperCase_48(char* str);

extern "C" int32_t
T_CString_integerToString_48(char *buffer, int32_t n, int32_t radix);

extern "C" int32_t
T_CString_int64ToString_48(char *buffer, int64_t n, uint32_t radix);

extern "C" int32_t
T_CString_stringToInteger_48(const char *integerString, int32_t radix);

extern "C" int
T_CString_stricmp_48(const char *str1, const char *str2);

extern "C" int
T_CString_strnicmp_48(const char *str1, const char *str2, uint32_t n);
# 18 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/propname.cpp" 2
# 1 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/ucln_cmn.h" 1
# 21 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/ucln_cmn.h"
# 1 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/ucln.h" 1
# 53 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/ucln.h"
typedef enum ECleanupLibraryType {
    UCLN_START = -1,
    UCLN_UPLUG,
    UCLN_CUSTOM,
    UCLN_CTESTFW,
    UCLN_TOOLUTIL,
    UCLN_LAYOUTEX,
    UCLN_LAYOUT,
    UCLN_IO,
    UCLN_I18N,
    UCLN_COMMON
} ECleanupLibraryType;




extern "C" {
typedef UBool cleanupFunc(void);
}






extern "C" void ucln_registerCleanup_48(ECleanupLibraryType type,
                                           cleanupFunc *func);







extern "C" void ucln_cleanupOne_48(ECleanupLibraryType type);
# 22 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/ucln_cmn.h" 2



extern "C" UBool umtx_cleanup_48(void);

extern "C" UBool utrace_cleanup_48(void);

extern "C" UBool ucln_lib_cleanup_48(void);




typedef enum ECleanupCommonType {
    UCLN_COMMON_START = -1,
    UCLN_COMMON_USPREP,
    UCLN_COMMON_BREAKITERATOR,
    UCLN_COMMON_BREAKITERATOR_DICT,
    UCLN_COMMON_SERVICE,
    UCLN_COMMON_URES,
    UCLN_COMMON_LOCALE,
    UCLN_COMMON_LOCALE_AVAILABLE,
    UCLN_COMMON_ULOC,
    UCLN_COMMON_NORMALIZER2,
    UCLN_COMMON_USET,
    UCLN_COMMON_UNAMES,
    UCLN_COMMON_UPROPS,
    UCLN_COMMON_UCNV,
    UCLN_COMMON_UCNV_IO,
    UCLN_COMMON_UDATA,
    UCLN_COMMON_PUTIL,
    UCLN_COMMON_COUNT
} ECleanupCommonType;



extern "C" void ucln_common_registerCleanup_48(ECleanupCommonType type,
                                                   cleanupFunc *func);
# 19 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/propname.cpp" 2
# 1 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/uarrsort.h" 1
# 24 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/uarrsort.h"
extern "C" {
# 39 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/uarrsort.h"
typedef int32_t
UComparator(const void *context, const void *left, const void *right);
}
# 58 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/uarrsort.h"
extern "C" void
uprv_sortArray_48(void *array, int32_t length, int32_t itemSize,
               UComparator *cmp, const void *context,
               UBool sortStable, UErrorCode *pErrorCode);





extern "C" int32_t
uprv_uint16Comparator_48(const void *context, const void *left, const void *right);





extern "C" int32_t
uprv_int32Comparator_48(const void *context, const void *left, const void *right);





extern "C" int32_t
uprv_uint32Comparator_48(const void *context, const void *left, const void *right);
# 20 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/propname.cpp" 2
# 1 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/uinvchar.h" 1
# 35 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/uinvchar.h"
extern "C" UBool
uprv_isInvariantString_48(const char *s, int32_t length);
# 48 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/uinvchar.h"
extern "C" UBool
uprv_isInvariantUString_48(const UChar *s, int32_t length);
# 70 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/uinvchar.h"
extern "C" int32_t
uprv_compareInvEbcdicAsAscii_48(const char *s1, const char *s2);
# 90 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/uinvchar.h"
extern "C" char
uprv_ebcdicToLowercaseAscii_48(char c);
# 111 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/uinvchar.h"
extern "C" uint8_t*
uprv_aestrncpy_48(uint8_t *dst, const uint8_t *src, int32_t n);







extern "C" uint8_t*
uprv_eastrncpy_48(uint8_t *dst, const uint8_t *src, int32_t n);
# 21 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/propname.cpp" 2


# 1 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/propname_data.h" 1
# 14 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/propname_data.h"
extern "C++" { namespace icu_48 {

const int32_t PropNameData::indexes[8]={0x20,0xfb8,0x37ed,0x6850,0x6850,0x6850,0x2f,0};

const int32_t PropNameData::valueMaps[998]={
6,0,0x39,0,0xc9,0x165,0xc9,0x17b,0xc9,0x190,0xc9,0x297,0xc9,0x2a2,0xc9,0x2c3,
0xc9,0x2d3,0xc9,0x2e2,0xc9,0x2f0,0xc9,0x314,0xc9,0x32b,0xc9,0x343,0xc9,0x35a,0xc9,0x369,
0xc9,0x3bf,0xc9,0x3d0,0xc9,0x378,0xc9,0x38a,0xc9,0x3a4,0xc9,0x3de,0xc9,0x3f3,0xc9,0x410,
0xc9,0x421,0xc9,0x480,0xc9,0x4fc,0xc9,0x512,0xc9,0x53d,0xc9,0x55a,0xc9,0x575,0xc9,0x58e,
0xc9,0x5b6,0xc9,0x5d0,0xc9,0x5e3,0xc9,0x1c6,0xc9,0x54d,0xc9,0x59f,0xc9,0x440,0xc9,0x46a,
0xc9,0x42c,0xc9,0x454,0xc9,0x523,0xc9,0x49f,0xc9,0x4b7,0xc9,0x4d3,0xc9,0x4db,0xc9,0x4e3,
0xc9,0x4eb,0xc9,0x4f3,0xc9,0x1a6,0xc9,0x1b3,0xc9,0x21c,0xc9,0x27a,0xc9,0x25d,0xc9,0x1e0,
0xc9,0x1fe,0xc9,0x239,0xc9,0x1000,0x1015,0x5f3,0xf9,0x7a6,0x110,0x17c1,0xcf,0x17e0,0x1e6,0x190b,
0x1fc,0x1965,0x206,0x1cc6,0x242,0x1edb,0x27f,0x1f70,0x289,0x225e,0x2cc,0x229c,0x2d4,0x1c48,0x238,0x21e2,
0x2b9,0x2237,0x2c6,0x21b4,0x2b2,0x2207,0x2bf,0x1f4b,0xcf,0x2b8a,0xcf,0x1bc2,0x228,0x2ae2,0x374,0x2bb0,
0x387,0x2000,0x2001,0x2d87,0x398,0x3000,0x3001,0x2d75,0,0x4000,0x400d,0x2c5a,0,0x2c63,0,0x2c7d,
0,0x2c8e,0,0x2c9f,0,0x2cb5,0,0x2cbe,0,0x2cdb,0,0x2cf9,0,0x2d17,0,0x2d35,
0,0x2d4b,0,0x2d5f,0,0x7000,0x7001,0x304c,0,0x6a8,0x12,0,1,0x12,0x20,0x6c6,
0x24,0,1,7,8,9,0xc8,0xca,0xd6,0xd8,0xda,0xdc,0xde,0xe0,0xe2,0xe4,
0xe6,0xe8,0xe9,0xea,0xf0,0x2e,0x40,0x13f,0x149,0x15a,0x4c,0x66,0x7a,0x8e,0xa9,0xb8,
0xc1,0xd1,0xd9,0xe2,0xf1,0xfa,0x10a,0x11b,0x12c,0x7de,1,0,0x13,0x6ad,0x725,0x66a,
0x67e,0x695,0x602,0x640,0x614,0x781,0x796,0x6f7,0x6be,0x6db,0x736,0x748,0x765,0x709,0x655,0x62b,
0x93e,1,0,0xd2,0x135a,0x8fb,0x10b5,0x10d2,0x1101,0xff9,0x14ee,0xb2f,0xe73,0xc7a,0x8b7,0xf4c,
0x842,0x1604,0x1671,0xce8,0x917,0xea8,0xe9d,0x13e3,0x1660,0x1668,0x104b,0x11c4,0x14ce,0x167a,0x10af,0x1681,
0x1327,0xe3c,0xeef,0xdc8,0x9ba,0x16bd,0x1374,0x14a3,0x1097,0x1309,0x10e5,0xe8c,0xe13,0x1520,0xc53,0xb8d,
0x1143,0x1365,0x8c2,0x11fe,0x12d7,0xbef,0x13c3,0xd48,0x951,0x921,0xe29,0x1274,0xd0b,0x968,0xa3c,0x1039,
0xf90,0xa64,0xf85,0x1055,0x932,0xed3,0x1030,0x93d,0xd84,0x9c5,0xa9b,0xa82,0x17b2,0x17a4,0xf2f,0xf73,
0xf55,0x1191,0x1464,0x9f3,0x7d7,0x84b,0xb76,0x9d9,0x14d8,0x885,0x1509,0xeb3,0x137c,0xe6a,0xcde,0x98e,
0x1315,0x11da,0xac0,0xa12,0x1622,0xcb1,0x160d,0xf42,0x986,0x1617,0x1226,0x153e,0x1556,0x124d,0x156e,0x1060,
0x172f,0x15af,0x15d2,0x1158,0x1629,0x109f,0x141d,0x128c,0x178a,0x1175,0x1160,0x7b1,0x16b2,0x14c4,0x13eb,0xc66,
0x1648,0x1745,0x7f7,0x818,0x8a3,0x97b,0xa56,0xb4d,0xc02,0xdd3,0xdfd,0xe47,0xe5d,0x108a,0x12f1,0x1346,
0x1389,0x1433,0x1594,0x15f5,0x168b,0x1779,0x1354,0x8d5,0x1114,0x1127,0x13f5,0x1410,0xc23,0xc2f,0xc0b,0x1514,
0x113a,0x13b8,0xc85,0x1729,0xc9b,0x14b7,0x107f,0x1483,0x9b3,0x830,0x1400,0x11a2,0x9aa,0x11ab,0x11b4,0xd16,
0x14ab,0x16f8,0x1632,0x1766,0x118a,0x8e0,0xbd3,0xcf5,0xefd,0x100a,0x1331,0x163d,0x1217,0xf16,0xfb5,0x1397,
0x8cb,0xfe0,0xfc8,0x13ab,0x148c,0x1015,0xd25,0xd61,0xda6,0xae5,0x11d0,0x90f,0xde7,0x95f,0x8e8,0x101e,
0x1454,0x12af,0xd3c,0x1696,0x7c2,0xb0a,0x1511,1,0,0x12,0x18aa,0x17f7,0x181a,0x180a,0x182a,0x1839,
0x1844,0x1856,0x1869,0x187b,0x188b,0x189b,0x18b5,0x18c4,0x18d4,0x18dd,0x18ec,0x1900,0x15cf,1,0,6,
0x1952,0x1920,0x193a,0x192d,0x1947,0x195d,0x1613,1,0,0x1e,0x1a43,0x1bad,0x1a8f,0x1b98,0x1ab4,0x1af0,
0x1adc,0x19f9,0x197a,0x19e0,0x1a6a,0x1b01,0x1b61,0x1a7c,0x1b39,0x19a5,0x1a38,0x1b51,0x1b8a,0x19cb,0x1b75,0x1a0c,
0x198b,0x1b12,0x1aa4,0x19b7,0x1ac8,0x1b28,0x1a52,0x1a22,0x183e,1,0,0xc,0x1c18,0x1bde,0x1bea,0x1bf1,
0x1bfc,0x1c01,0x1c08,0x1c0f,0x1c3e,0x1c43,0x1c2e,0x1c22,0x1894,1,0,6,0x1c94,0x1c62,0x1cb8,0x1ca7,
0x1c84,0x1c72,0x18f0,1,0,0x39,0x1dc8,0x1cd8,0x1cde,0x1ce6,0x1ced,0x1cf3,0x1d12,0x1d18,0x1d26,0x1d3b,
0x1d41,0x1d51,0x1d57,0x1d5f,0x1e66,0x1d65,0x1d6a,0x1d70,0x1d7b,0x1d82,0x1d88,0x1d97,0x1da5,0x1dab,0x1db4,0x1dbb,
0x1dc1,0x1ddb,0x1de7,0x1dec,0x1df2,0x1df9,0x1dff,0x1e0d,0x1e13,0x1e1b,0x1e22,0x1e2c,0x1e33,0x1e3f,0x1e4c,0x1e52,
0x1e58,0x1e8b,0x1e92,0x1e98,0x1e9e,0x1eab,0x1ebb,0x1ec2,0x1ecc,0x1d36,0x1d8f,0x1ed3,0x1cfa,0x1d2a,0x1de1,0x1a9b,
1,0,6,0x1f1c,0x1efc,0x1eec,0x1f0c,0x1f2b,0x1f3c,0x1af9,1,0,0x25,0x218c,0x1f8e,0x1f7f,
0x1fbd,0x1f9c,0x1fac,0x20ed,0x2045,0x2008,0x201e,0x1fde,0x205a,0x206a,0x2081,0x208c,0x20ae,0x209c,0x20df,0x210f,
0x211e,0x212a,0x213f,0x2153,0x2166,0x2031,0x217e,0x2174,0x1fcc,0x21a8,0x2101,0x2198,0x2073,0x207a,0x20ca,0x20d1,
0x20d8,0x1ff2,0x1cf2,1,0,3,0x21d5,0x21db,0x21cc,0x1d08,0x12,0,1,0x21fa,0x2200,0x1d15,
1,0,3,0x222a,0x2230,0x2221,0x1d2b,0x12,0,1,0x2251,0x2257,0x1d38,1,0,4,
0x2285,0x226f,0x227b,0x2290,0x1d5e,1,0,0x9c,0x23ce,0x256a,0x22b2,0x22bf,0x230e,0x2332,0x23b4,0x23db,
0x240b,0x2425,0x2433,0x248b,0x249a,0x24ba,0x24d2,0x24de,0x24ed,0x24fc,0x2506,0x252c,0x2544,0x25ea,0x25f8,0x2642,
0x267e,0x2688,0x270d,0x2780,0x27a6,0x27f1,0x2813,0x2873,0x2902,0x2974,0x29bb,0x2a0c,0x2a23,0x2a3b,0x2a48,0x2a53,
0x2377,0x2ad9,0x29c8,0x2513,0x236b,0x29d6,0x234e,0x23fd,0x26b7,0x26ce,0x2890,0x2945,0x29e5,0x2a7b,0x2607,0x235c,
0x24a9,0x2631,0x299d,0x27ca,0x2a61,0x283a,0x22dc,0x2302,0x231c,0x2341,0x23a9,0x23c3,0x27fd,0x241a,0x2539,0x245a,
0x264e,0x295e,0x2a70,0x289e,0x2808,0x2521,0x25c3,0x2622,0x2694,0x269f,0x26aa,0x26c3,0x271d,0x2741,0x2775,0x27dc,
0x287f,0x282f,0x28b4,0x28c3,0x28d4,0x28f7,0x291e,0x2480,0x2ac3,0x244f,0x2a30,0x2aa3,0x2aad,0x23ed,0x2a98,0x2a8a,
0x2391,0x25b8,0x266f,0x26f3,0x2700,0x2864,0x28ea,0x2929,0x2953,0x298d,0x2790,0x274c,0x2553,0x22ce,0x239e,0x2659,
0x25dd,0x272b,0x257f,0x28df,0x2327,0x259b,0x290e,0x29f2,0x2736,0x29b0,0x22eb,0x26dd,0x27bf,0x284c,0x22f7,0x2444,
0x2475,0x24c7,0x2664,0x26e8,0x275f,0x276a,0x2824,0x27b4,0x28a9,0x2969,0x2ab8,0x22a7,0x25d2,0x279b,0x27e6,0x293a,
0x2982,0x2a01,0x2a18,0x2ace,0x241f,1,0,0xf,0x2b4f,0x2af5,0x2aff,0x2b1b,0x2b2d,0x2b37,0x2b43,0x2b67,
0x2b6f,0x2b76,0x2b80,0x2b09,0x2b10,0x2b26,0x2b59,0x24a6,1,0,0xd,0x2c50,0x2bbf,0x2bf2,0x2bfd,0x2c11,
0x2c1f,0x2c44,0x2be1,0x2bcb,0x2bd2,0x2c0a,0x2c2a,0x2c38,0x252d,0x36,1,2,4,8,0xe,0x10,
0x20,0x3e,0x40,0x80,0x100,0x1c0,0x200,0x400,0x800,0xe00,0x1000,0x2000,0x4000,0x7000,0x8000,0x10000,
0x20000,0x40000,0x78001,0x80000,0x100000,0x200000,0x400000,0x800000,0x1000000,0x2000000,0x4000000,0x8000000,0xf000000,0x10000000,0x20000000,0x30f80000,
0x2dbf,0x2e55,0x2e06,0x2e40,0x2df5,0x2e1b,0x2e2f,0x2e6a,0x2e98,0x2e85,0x2e74,0x2eac,0x2eb4,0x2ecd,0x2edf,0x2ef0,
0x302b,0x3000,0x3013,0x303f,0x2da2,0x2db4,0x2dce,0x2dde,0x2dec,0x2f14,0x2f83,0x2f29,0x2efa,0x2f6d,0x2fd5,0x2fad,
0x2fc1,0x2fe5,0x2ff6,0x2f55,0x2f3f,0x2f98
};

const uint8_t PropNameData::bytesTries[10293]={
0,0x15,0x6d,0xc3,0x16,0x73,0xc1,0xea,0x76,0x5f,0x76,0x68,0x77,0x90,0x78,1,
0x64,0x50,0x69,0x10,0x64,1,0x63,0x30,0x73,0x62,0x13,0x74,0x61,0x72,0x74,0x63,
0x60,0x16,0x6f,0x6e,0x74,0x69,0x6e,0x75,0x65,0x61,0x13,0x69,0x67,0x69,0x74,0x81,
1,0x61,0x24,0x73,0x69,0x1e,0x72,0x69,0x61,0x74,0x69,0x6f,0x6e,0x73,0x65,0x6c,
0x65,0x63,0x74,0x6f,0x72,0x69,3,0x62,0xc3,0x14,0x68,0x32,0x6f,0x42,0x73,0x13,
0x70,0x61,0x63,0x65,0x5f,0x17,0x69,0x74,0x65,0x73,0x70,0x61,0x63,0x65,0x5f,0x16,
0x72,0x64,0x62,0x72,0x65,0x61,0x6b,0xc3,0x14,0x73,0xa2,0x49,0x74,0xa4,0x2e,0x75,
3,0x63,0xd9,0x40,0xc,0x69,0x52,0x6e,0x58,0x70,0x12,0x70,0x65,0x72,0x5c,0x13,
0x63,0x61,0x73,0x65,0x5c,0x16,0x6d,0x61,0x70,0x70,0x69,0x6e,0x67,0xd9,0x40,0xc,
0x12,0x64,0x65,0x6f,0x5b,0x10,0x69,1,0x63,0x3e,0x66,0x1b,0x69,0x65,0x64,0x69,
0x64,0x65,0x6f,0x67,0x72,0x61,0x70,0x68,0x5b,0x17,0x6f,0x64,0x65,0x31,0x6e,0x61,
0x6d,0x65,0xd9,0x40,0xb,0xa,0x69,0x84,0x70,0x19,0x70,0x30,0x74,0x36,0x75,0x10,
0x63,0xd9,0x40,9,0x12,0x61,0x63,0x65,0x5f,1,0x63,0xd9,0x40,8,0x65,0x11,
0x72,0x6d,0x67,0x69,0x3c,0x6c,0xa2,0x5f,0x6f,0x17,0x66,0x74,0x64,0x6f,0x74,0x74,
0x65,0x64,0x57,0x13,0x6d,0x70,0x6c,0x65,3,0x63,0x50,0x6c,0x68,0x74,0x8a,0x75,
0x1e,0x70,0x70,0x65,0x72,0x63,0x61,0x73,0x65,0x6d,0x61,0x70,0x70,0x69,0x6e,0x67,
0xd9,0x40,9,0x19,0x61,0x73,0x65,0x66,0x6f,0x6c,0x64,0x69,0x6e,0x67,0xd9,0x40,
6,0x1e,0x6f,0x77,0x65,0x72,0x63,0x61,0x73,0x65,0x6d,0x61,0x70,0x70,0x69,0x6e,
0x67,0xd9,0x40,7,0x1e,0x69,0x74,0x6c,0x65,0x63,0x61,0x73,0x65,0x6d,0x61,0x70,
0x70,0x69,0x6e,0x67,0xd9,0x40,8,0x10,0x63,0xd9,0x40,7,0x62,0xc3,0x13,0x63,
0x34,0x64,0x57,0x65,0x6e,0x66,0x10,0x63,0xd9,0x40,6,0xc2,0xa,2,0x66,0xd9,
0x40,6,0x72,0x28,0x78,0xd9,0x70,0,0x12,0x69,0x70,0x74,0xc2,0xa,0x19,0x65,
0x78,0x74,0x65,0x6e,0x73,0x69,0x6f,0x6e,0x73,0xd9,0x70,0,1,0x67,0x50,0x6e,
1,0x73,0x3a,0x74,0x18,0x65,0x6e,0x63,0x65,0x62,0x72,0x65,0x61,0x6b,0xc3,0x13,
0x14,0x69,0x74,0x69,0x76,0x65,0x65,1,0x6d,0x2e,0x73,0x13,0x74,0x61,0x72,0x74,
0x73,0x19,0x65,0x6e,0x74,0x73,0x74,0x61,0x72,0x74,0x65,0x72,0x73,3,0x63,0x66,
0x65,0x72,0x69,0x98,0x72,0x19,0x61,0x69,0x6c,0x63,0x61,0x6e,0x6f,0x6e,0x69,0x63,
0x1f,0x61,0x6c,0x63,0x6f,0x6d,0x62,0x69,0x6e,0x69,0x6e,0x67,0x63,0x6c,0x61,0x73,
0x73,0xc3,0x11,0xd8,0x40,0xa,0x11,0x63,0x63,0xc3,0x11,0x11,0x72,0x6d,0x58,0x1e,
0x69,0x6e,0x61,0x6c,0x70,0x75,0x6e,0x63,0x74,0x75,0x61,0x74,0x69,0x6f,0x6e,0x59,
0x1d,0x74,0x6c,0x65,0x63,0x61,0x73,0x65,0x6d,0x61,0x70,0x70,0x69,0x6e,0x67,0xd9,
0x40,0xa,0x6d,0x42,0x6e,0x48,0x70,0xa2,0xda,0x71,0xa4,9,0x72,0x15,0x61,0x64,
0x69,0x63,0x61,0x6c,0x55,0x12,0x61,0x74,0x68,0x4f,6,0x6f,0x39,0x6f,0x32,0x74,
0xc3,9,0x75,0x54,0x76,0xd9,0x30,0,0x12,0x6e,0x63,0x68,0x1f,0x61,0x72,0x61,
0x63,0x74,0x65,0x72,0x63,0x6f,0x64,0x65,0x70,0x6f,0x69,0x6e,0x74,0x51,0x14,0x6d,
0x65,0x72,0x69,0x63,1,0x74,0x32,0x76,0x13,0x61,0x6c,0x75,0x65,0xd9,0x30,0,
0x12,0x79,0x70,0x65,0xc3,9,0x61,0xa2,0x77,0x63,0xa2,0x82,0x66,2,0x63,0x98,
0x64,0xa2,0x53,0x6b,1,0x63,0x56,0x64,1,0x69,0x42,0x71,1,0x63,0xc3,0xd,
0x75,0x17,0x69,0x63,0x6b,0x63,0x68,0x65,0x63,0x6b,0xc3,0xd,0x13,0x6e,0x65,0x72,
0x74,0x6d,1,0x69,0x42,0x71,1,0x63,0xc3,0xf,0x75,0x17,0x69,0x63,0x6b,0x63,
0x68,0x65,0x63,0x6b,0xc3,0xf,0x13,0x6e,0x65,0x72,0x74,0x71,1,0x69,0x42,0x71,
1,0x63,0xc3,0xe,0x75,0x17,0x69,0x63,0x6b,0x63,0x68,0x65,0x63,0x6b,0xc3,0xe,
0x13,0x6e,0x65,0x72,0x74,0x6f,1,0x69,0x42,0x71,1,0x63,0xc3,0xc,0x75,0x17,
0x69,0x63,0x6b,0x63,0x68,0x65,0x63,0x6b,0xc3,0xc,0x13,0x6e,0x65,0x72,0x74,0x6b,
0xd8,0x40,5,1,0x31,0xd9,0x40,0xb,0x6d,0x10,0x65,0xd9,0x40,5,0x12,0x68,
0x61,0x72,0x51,1,0x61,0x2c,0x72,0x12,0x69,0x6e,0x74,0x7f,0x10,0x74,2,0x73,
0x2c,0x74,0x30,0x77,0x10,0x73,0x77,0x11,0x79,0x6e,0x75,0x12,0x65,0x72,0x6e,1,
0x73,0x38,0x77,0x18,0x68,0x69,0x74,0x65,0x73,0x70,0x61,0x63,0x65,0x77,0x14,0x79,
0x6e,0x74,0x61,0x78,0x75,1,0x6d,0x3c,0x75,0x1a,0x6f,0x74,0x61,0x74,0x69,0x6f,
0x6e,0x6d,0x61,0x72,0x6b,0x53,0x12,0x61,0x72,0x6b,0x53,0x66,0xc1,0xb9,0x69,0xc0,
0xfd,0x69,0xa2,0x6f,0x6a,0xa2,0xca,0x6c,4,0x62,0xc3,8,0x63,0x8c,0x65,0x98,
0x69,0xa2,0x56,0x6f,2,0x65,0x4b,0x67,0x4c,0x77,0x11,0x65,0x72,0x4c,0x13,0x63,
0x61,0x73,0x65,0x4c,0x16,0x6d,0x61,0x70,0x70,0x69,0x6e,0x67,0xd9,0x40,4,0x11,
0x69,0x63,0x1f,0x61,0x6c,0x6f,0x72,0x64,0x65,0x72,0x65,0x78,0x63,0x65,0x70,0x74,
0x69,0x6f,0x6e,0x4b,0xd8,0x40,4,0x11,0x63,0x63,0xc3,0x10,0x18,0x61,0x64,0x63,
0x61,0x6e,0x6f,0x6e,0x69,0x63,0x1f,0x61,0x6c,0x63,0x6f,0x6d,0x62,0x69,0x6e,0x69,
0x6e,0x67,0x63,0x6c,0x61,0x73,0x73,0xc3,0x10,0x16,0x6e,0x65,0x62,0x72,0x65,0x61,
0x6b,0xc3,8,1,0x64,0x44,0x73,1,0x63,0xd9,0x40,3,0x6f,0x16,0x63,0x6f,
0x6d,0x6d,0x65,0x6e,0x74,0xd9,0x40,3,2,0x63,0x80,0x65,0x90,0x73,0x40,1,
0x62,0x52,0x74,0x46,1,0x61,0x40,0x72,0x1c,0x69,0x6e,0x61,0x72,0x79,0x6f,0x70,
0x65,0x72,0x61,0x74,0x6f,0x72,0x47,0x11,0x72,0x74,0x41,0x44,0x1c,0x69,0x6e,0x61,
0x72,0x79,0x6f,0x70,0x65,0x72,0x61,0x74,0x6f,0x72,0x45,0x3e,0x16,0x6f,0x6e,0x74,
0x69,0x6e,0x75,0x65,0x3f,0x10,0x6f,0x42,0x16,0x67,0x72,0x61,0x70,0x68,0x69,0x63,
0x43,2,0x67,0xc3,6,0x6f,0x26,0x74,0xc3,7,0x11,0x69,0x6e,1,0x63,0x4a,
0x69,0x11,0x6e,0x67,1,0x67,0x2e,0x74,0x12,0x79,0x70,0x65,0xc3,7,0x13,0x72,
0x6f,0x75,0x70,0xc3,6,0x48,0x15,0x6f,0x6e,0x74,0x72,0x6f,0x6c,0x49,0x66,0x86,
0x67,0xa2,0x4a,0x68,3,0x61,0x36,0x65,0x58,0x73,0x68,0x79,0x13,0x70,0x68,0x65,
0x6e,0x3d,0x1f,0x6e,0x67,0x75,0x6c,0x73,0x79,0x6c,0x6c,0x61,0x62,0x6c,0x65,0x74,
0x79,0x70,0x65,0xc3,0xb,0x10,0x78,0x3a,0x14,0x64,0x69,0x67,0x69,0x74,0x3b,0x10,
0x74,0xc3,0xb,0x16,0x75,0x6c,0x6c,0x63,0x6f,0x6d,0x70,0x1f,0x6f,0x73,0x69,0x74,
0x69,0x6f,0x6e,0x65,0x78,0x63,0x6c,0x75,0x73,0x69,0x6f,0x6e,0x33,2,0x63,0xa2,
0x44,0x65,0xa2,0x4b,0x72,3,0x61,0x34,0x62,0x84,0x65,0x8a,0x6c,0x12,0x69,0x6e,
0x6b,0x39,0x11,0x70,0x68,0x7c,0x12,0x65,0x6d,0x65,3,0x62,0x5e,0x63,0x30,0x65,
0x48,0x6c,0x12,0x69,0x6e,0x6b,0x39,0x1a,0x6c,0x75,0x73,0x74,0x65,0x72,0x62,0x72,
0x65,0x61,0x6b,0xc3,0x12,0x14,0x78,0x74,0x65,0x6e,0x64,0x37,0x12,0x61,0x73,0x65,
0x35,0x11,0x78,0x74,0x37,0xc2,5,1,0x62,0xc3,0x12,0x6d,0xd9,0x20,0,0x1c,
0x6e,0x65,0x72,0x61,0x6c,0x63,0x61,0x74,0x65,0x67,0x6f,0x72,0x79,0xc2,5,0x13,
0x6d,0x61,0x73,0x6b,0xd9,0x20,0,0x61,0x72,0x62,0xa2,0x57,0x63,0xa2,0xa4,0x64,
0xa4,0x71,0x65,1,0x61,0x36,0x78,0x10,0x74,0x30,0x14,0x65,0x6e,0x64,0x65,0x72,
0x31,0xc2,4,0x1b,0x73,0x74,0x61,0x73,0x69,0x61,0x6e,0x77,0x69,0x64,0x74,0x68,
0xc3,4,3,0x67,0x44,0x68,0x4a,0x6c,0x4e,0x73,0x1a,0x63,0x69,0x69,0x68,0x65,
0x78,0x64,0x69,0x67,0x69,0x74,0x23,0x10,0x65,0xd9,0x40,0,0x11,0x65,0x78,0x23,
1,0x6e,0x38,0x70,0x11,0x68,0x61,0x20,0x14,0x62,0x65,0x74,0x69,0x63,0x21,0x11,
0x75,0x6d,0x79,3,0x63,0xc3,0,0x69,0x30,0x6c,0x90,0x6d,0x10,0x67,0xd9,0x40,
1,0x11,0x64,0x69,1,0x63,0x54,0x6d,0x26,0x14,0x69,0x72,0x72,0x6f,0x72,1,
0x65,0x38,0x69,0x16,0x6e,0x67,0x67,0x6c,0x79,0x70,0x68,0xd9,0x40,1,0x10,0x64,
0x27,0x24,1,0x6c,0x30,0x6f,0x14,0x6e,0x74,0x72,0x6f,0x6c,0x25,0x12,0x61,0x73,
0x73,0xc3,0,2,0x61,0x32,0x6b,0xc3,1,0x6f,0x11,0x63,0x6b,0xc3,1,0x11,
0x6e,0x6b,0x7b,6,0x68,0x7c,0x68,0x54,0x69,0x85,0x6f,0xa2,0x6f,0x77,4,0x63,
0x30,0x6b,0x36,0x6c,0x87,0x74,0x8b,0x75,0x89,1,0x66,0x8d,0x6d,0x8f,0x11,0x63,
0x66,0x91,0x18,0x61,0x6e,0x67,0x65,0x73,0x77,0x68,0x65,0x6e,4,0x63,0x44,0x6c,
0x6c,0x6e,0x7e,0x74,0x98,0x75,0x18,0x70,0x70,0x65,0x72,0x63,0x61,0x73,0x65,0x64,
0x89,0x12,0x61,0x73,0x65,1,0x66,0x30,0x6d,0x14,0x61,0x70,0x70,0x65,0x64,0x8f,
0x14,0x6f,0x6c,0x64,0x65,0x64,0x8d,0x18,0x6f,0x77,0x65,0x72,0x63,0x61,0x73,0x65,
0x64,0x87,0x1c,0x66,0x6b,0x63,0x63,0x61,0x73,0x65,0x66,0x6f,0x6c,0x64,0x65,0x64,
0x91,0x18,0x69,0x74,0x6c,0x65,0x63,0x61,0x73,0x65,0x64,0x8b,0x13,0x6d,0x70,0x65,
0x78,0x33,0x61,0x2e,0x63,0xa2,0x48,0x66,0xd9,0x40,2,1,0x6e,0x72,0x73,0x10,
0x65,3,0x64,0x83,0x66,0x3a,0x69,0x4a,0x73,0x17,0x65,0x6e,0x73,0x69,0x74,0x69,
0x76,0x65,0x65,0x15,0x6f,0x6c,0x64,0x69,0x6e,0x67,0xd9,0x40,2,0x17,0x67,0x6e,
0x6f,0x72,0x61,0x62,0x6c,0x65,0x85,0x13,0x6f,0x6e,0x69,0x63,0x1f,0x61,0x6c,0x63,
0x6f,0x6d,0x62,0x69,0x6e,0x69,0x6e,0x67,0x63,0x6c,0x61,0x73,0x73,0xc3,2,0x10,
0x63,0xc3,2,3,0x61,0x30,0x65,0x34,0x69,0xa2,0x41,0x74,0xc3,3,0x11,0x73,
0x68,0x29,2,0x63,0x3a,0x66,0x58,0x70,0x2c,0x16,0x72,0x65,0x63,0x61,0x74,0x65,
0x64,0x2d,0x1d,0x6f,0x6d,0x70,0x6f,0x73,0x69,0x74,0x69,0x6f,0x6e,0x74,0x79,0x70,
0x65,0xc3,3,0x15,0x61,0x75,0x6c,0x74,0x69,0x67,0x1f,0x6e,0x6f,0x72,0x61,0x62,
0x6c,0x65,0x63,0x6f,0x64,0x65,0x70,0x6f,0x69,0x6e,0x74,0x2b,0x2a,0x10,0x61,0x2e,
0x15,0x63,0x72,0x69,0x74,0x69,0x63,0x2f,3,0x66,0x34,0x6e,0x3e,0x74,0x42,0x79,
0x22,0x11,0x65,0x73,0x23,0x20,0x13,0x61,0x6c,0x73,0x65,0x21,0x20,0x10,0x6f,0x21,
0x22,0x12,0x72,0x75,0x65,0x23,9,0x6c,0x48,0x6c,0x44,0x6e,0x50,0x6f,0x7e,0x72,
0x8e,0x76,1,0x69,0x24,0x72,0x33,0x13,0x72,0x61,0x6d,0x61,0x33,0xa2,0xe0,0x12,
0x65,0x66,0x74,0xa3,0xe0,3,0x6b,0x2f,0x6f,0x30,0x72,0x21,0x75,0x12,0x6b,0x74,
0x61,0x2f,0x19,0x74,0x72,0x65,0x6f,0x72,0x64,0x65,0x72,0x65,0x64,0x21,0x10,0x76,
0x22,0x14,0x65,0x72,0x6c,0x61,0x79,0x23,0xa2,0xe2,0x13,0x69,0x67,0x68,0x74,0xa3,
0xe2,0x61,0x54,0x62,0xa2,0x73,0x64,0xa2,0x92,0x69,0xa2,0xae,0x6b,1,0x61,0x24,
0x76,0x31,0x18,0x6e,0x61,0x76,0x6f,0x69,0x63,0x69,0x6e,0x67,0x31,0xa2,0xe6,3,
0x62,0xa0,0x6c,0xa3,0xe4,0x72,0xa3,0xe8,0x74,2,0x61,0x74,0x62,0x7c,0x74,0x14,
0x61,0x63,0x68,0x65,0x64,1,0x61,0x3e,0x62,0x13,0x65,0x6c,0x6f,0x77,0xa2,0xca,
0x13,0x6c,0x65,0x66,0x74,0xa3,0xc8,0x13,0x62,0x6f,0x76,0x65,0xa2,0xd6,0x14,0x72,
0x69,0x67,0x68,0x74,0xa3,0xd8,0xa2,0xd6,0x10,0x72,0xa3,0xd8,0xa2,0xca,0x10,0x6c,
0xa3,0xc8,0x12,0x6f,0x76,0x65,0xa2,0xe6,1,0x6c,0x30,0x72,0x13,0x69,0x67,0x68,
0x74,0xa3,0xe8,0x12,0x65,0x66,0x74,0xa3,0xe4,0xa2,0xdc,2,0x65,0x2c,0x6c,0xa3,
0xda,0x72,0xa3,0xde,0x12,0x6c,0x6f,0x77,0xa2,0xdc,1,0x6c,0x30,0x72,0x13,0x69,
0x67,0x68,0x74,0xa3,0xde,0x12,0x65,0x66,0x74,0xa3,0xda,2,0x61,0xa3,0xea,0x62,
0xa3,0xe9,0x6f,0x13,0x75,0x62,0x6c,0x65,1,0x61,0x30,0x62,0x13,0x65,0x6c,0x6f,
0x77,0xa3,0xe9,0x13,0x62,0x6f,0x76,0x65,0xa3,0xea,1,0x6f,0x26,0x73,0xa3,0xf0,
0x1a,0x74,0x61,0x73,0x75,0x62,0x73,0x63,0x72,0x69,0x70,0x74,0xa3,0xf0,0xa,0x6e,
0xaf,0x72,0x52,0x72,0x44,0x73,0x98,0x77,1,0x68,0x24,0x73,0x33,0x17,0x69,0x74,
0x65,0x73,0x70,0x61,0x63,0x65,0x33,0x22,1,0x69,0x2c,0x6c,1,0x65,0x3d,0x6f,
0x3f,0x18,0x67,0x68,0x74,0x74,0x6f,0x6c,0x65,0x66,0x74,0x22,1,0x65,0x34,0x6f,
0x16,0x76,0x65,0x72,0x72,0x69,0x64,0x65,0x3f,0x17,0x6d,0x62,0x65,0x64,0x64,0x69,
0x6e,0x67,0x3d,0x30,0x1e,0x65,0x67,0x6d,0x65,0x6e,0x74,0x73,0x65,0x70,0x61,0x72,
0x61,0x74,0x6f,0x72,0x31,0x6e,0x88,0x6f,0xa2,0x46,0x70,2,0x61,0x50,0x64,0x70,
0x6f,0x11,0x70,0x64,0x1f,0x69,0x72,0x65,0x63,0x74,0x69,0x6f,0x6e,0x61,0x6c,0x66,
0x6f,0x72,0x6d,0x61,0x74,0x41,0x1f,0x72,0x61,0x67,0x72,0x61,0x70,0x68,0x73,0x65,
0x70,0x61,0x72,0x61,0x74,0x6f,0x72,0x2f,0x10,0x66,0x41,1,0x6f,0x28,0x73,0x10,
0x6d,0x43,0x1b,0x6e,0x73,0x70,0x61,0x63,0x69,0x6e,0x67,0x6d,0x61,0x72,0x6b,0x43,
1,0x6e,0x35,0x74,0x19,0x68,0x65,0x72,0x6e,0x65,0x75,0x74,0x72,0x61,0x6c,0x35,
0x61,0x8c,0x62,0xa2,0x50,0x63,0xa2,0x61,0x65,0xa2,0x72,0x6c,0x20,1,0x65,0x2c,
0x72,1,0x65,0x37,0x6f,0x39,0x18,0x66,0x74,0x74,0x6f,0x72,0x69,0x67,0x68,0x74,
0x20,1,0x65,0x34,0x6f,0x16,0x76,0x65,0x72,0x72,0x69,0x64,0x65,0x39,0x17,0x6d,
0x62,0x65,0x64,0x64,0x69,0x6e,0x67,0x37,2,0x6c,0x3b,0x6e,0x2b,0x72,0x13,0x61,
0x62,0x69,0x63,1,0x6c,0x30,0x6e,0x14,0x75,0x6d,0x62,0x65,0x72,0x2b,0x14,0x65,
0x74,0x74,0x65,0x72,0x3b,0x2e,1,0x6e,0x45,0x6f,0x1c,0x75,0x6e,0x64,0x61,0x72,
0x79,0x6e,0x65,0x75,0x74,0x72,0x61,0x6c,0x45,1,0x6f,0x24,0x73,0x2d,0x1c,0x6d,
0x6d,0x6f,0x6e,0x73,0x65,0x70,0x61,0x72,0x61,0x74,0x6f,0x72,0x2d,3,0x6e,0x25,
0x73,0x27,0x74,0x29,0x75,0x15,0x72,0x6f,0x70,0x65,0x61,0x6e,2,0x6e,0x3c,0x73,
0x46,0x74,0x18,0x65,0x72,0x6d,0x69,0x6e,0x61,0x74,0x6f,0x72,0x29,0x14,0x75,0x6d,
0x62,0x65,0x72,0x25,0x17,0x65,0x70,0x61,0x72,0x61,0x74,0x6f,0x72,0x27,0,0x14,
0x6c,0xc5,0x49,0x72,0xc2,0x7f,0x75,0xbc,0x75,0x8e,0x76,0xa2,0x6f,0x79,0x10,0x69,
2,0x6a,0x3c,0x72,0x64,0x73,0x17,0x79,0x6c,0x6c,0x61,0x62,0x6c,0x65,0x73,0xa3,
0x48,0x11,0x69,0x6e,0x1f,0x67,0x68,0x65,0x78,0x61,0x67,0x72,0x61,0x6d,0x73,0x79,
0x6d,0x62,0x6f,0x6c,0x73,0xa3,0x74,0x16,0x61,0x64,0x69,0x63,0x61,0x6c,0x73,0xa3,
0x49,1,0x67,0x7e,0x6e,0x1f,0x69,0x66,0x69,0x65,0x64,0x63,0x61,0x6e,0x61,0x64,
0x69,0x61,0x6e,0x61,0x62,0x6f,0x1f,0x72,0x69,0x67,0x69,0x6e,0x61,0x6c,0x73,0x79,
0x6c,0x6c,0x61,0x62,0x69,0x63,0x73,0x62,0x17,0x65,0x78,0x74,0x65,0x6e,0x64,0x65,
0x64,0xa3,0xad,0x15,0x61,0x72,0x69,0x74,0x69,0x63,0xa3,0x78,1,0x61,0x62,0x65,
1,0x64,0x3c,0x72,0x19,0x74,0x69,0x63,0x61,0x6c,0x66,0x6f,0x72,0x6d,0x73,0xa3,
0x91,0x1b,0x69,0x63,0x65,0x78,0x74,0x65,0x6e,0x73,0x69,0x6f,0x6e,0x73,0xa3,0xaf,
1,0x69,0xa3,0x9f,0x72,0x1e,0x69,0x61,0x74,0x69,0x6f,0x6e,0x73,0x65,0x6c,0x65,
0x63,0x74,0x6f,0x72,0x73,0xa2,0x6c,0x19,0x73,0x75,0x70,0x70,0x6c,0x65,0x6d,0x65,
0x6e,0x74,0xa3,0x7d,0x72,0xa2,0x94,0x73,0xa2,0xb6,0x74,4,0x61,0x64,0x65,0xa2,
0x67,0x68,0xa2,0x6a,0x69,0xa2,0x72,0x72,0x13,0x61,0x6e,0x73,0x70,0x1f,0x6f,0x72,
0x74,0x61,0x6e,0x64,0x6d,0x61,0x70,0x73,0x79,0x6d,0x62,0x6f,0x6c,0x73,0xa3,0xcf,
2,0x67,0x2e,0x69,0x54,0x6d,0x11,0x69,0x6c,0x49,2,0x61,0x2a,0x62,0x32,0x73,
0xa3,0x60,0x12,0x6c,0x6f,0x67,0xa3,0x62,0x13,0x61,0x6e,0x77,0x61,0xa3,0x65,3,
0x6c,0x4c,0x74,0x50,0x76,0x58,0x78,0x1d,0x75,0x61,0x6e,0x6a,0x69,0x6e,0x67,0x73,
0x79,0x6d,0x62,0x6f,0x6c,0x73,0xa3,0x7c,0x10,0x65,0xa3,0x70,0x12,0x68,0x61,0x6d,
0xa3,0xae,0x12,0x69,0x65,0x74,0xa3,0xb7,0x13,0x6c,0x75,0x67,0x75,0x4b,0x10,0x61,
1,0x61,0x24,0x69,0x53,0x11,0x6e,0x61,0x3d,1,0x62,0x32,0x66,0x14,0x69,0x6e,
0x61,0x67,0x68,0xa3,0x90,0x13,0x65,0x74,0x61,0x6e,0x57,1,0x65,0x56,0x75,1,
0x6d,0x2a,0x6e,0x11,0x69,0x63,0x67,0x1e,0x69,0x6e,0x75,0x6d,0x65,0x72,0x61,0x6c,
0x73,0x79,0x6d,0x62,0x6f,0x6c,0x73,0xa3,0xc0,0x13,0x6a,0x61,0x6e,0x67,0xa3,0xa3,
6,0x6d,0xc0,0xd6,0x6d,0x54,0x70,0x74,0x75,0xa2,0x49,0x79,1,0x6c,0x2c,0x72,
0x12,0x69,0x61,0x63,0x3b,0x17,0x6f,0x74,0x69,0x6e,0x61,0x67,0x72,0x69,0xa3,0x8f,
0x1e,0x61,0x6c,0x6c,0x66,0x6f,0x72,0x6d,0x76,0x61,0x72,0x69,0x61,0x6e,0x74,0x73,
0xa3,0x54,1,0x61,0x32,0x65,0x14,0x63,0x69,0x61,0x6c,0x73,0xa3,0x56,0x12,0x63,
0x69,0x6e,0x1f,0x67,0x6d,0x6f,0x64,0x69,0x66,0x69,0x65,0x72,0x6c,0x65,0x74,0x74,
0x65,0x72,0x73,0x2d,1,0x6e,0xa2,0x79,0x70,1,0x65,0xa2,0x5c,0x70,0x16,0x6c,
0x65,0x6d,0x65,0x6e,0x74,0x61,1,0x6c,0x50,0x72,0x1e,0x79,0x70,0x72,0x69,0x76,
0x61,0x74,0x65,0x75,0x73,0x65,0x61,0x72,0x65,0x61,1,0x61,0xa3,0x6d,0x62,0xa3,
0x6e,2,0x61,0x40,0x6d,0x56,0x70,0x19,0x75,0x6e,0x63,0x74,0x75,0x61,0x74,0x69,
0x6f,0x6e,0xa3,0x8e,0x14,0x72,0x72,0x6f,0x77,0x73,1,0x61,0xa3,0x67,0x62,0xa3,
0x68,0x13,0x61,0x74,0x68,0x65,0x1f,0x6d,0x61,0x74,0x69,0x63,0x61,0x6c,0x6f,0x70,
0x65,0x72,0x61,0x74,0x6f,0x72,0x73,0xa3,0x6a,0x14,0x72,0x73,0x63,0x72,0x69,0x1f,
0x70,0x74,0x73,0x61,0x6e,0x64,0x73,0x75,0x62,0x73,0x63,0x72,0x69,0x70,0x74,0x73,
0x73,0x15,0x64,0x61,0x6e,0x65,0x73,0x65,0xa3,0x9b,0x61,0x34,0x68,0x5e,0x69,0x14,
0x6e,0x68,0x61,0x6c,0x61,0x51,1,0x6d,0x36,0x75,0x16,0x72,0x61,0x73,0x68,0x74,
0x72,0x61,0xa3,0xa1,0x15,0x61,0x72,0x69,0x74,0x61,0x6e,0xa3,0xac,0x14,0x61,0x76,
0x69,0x61,0x6e,0xa3,0x79,0x6c,0xa2,0x74,0x6d,0xa4,0x1b,0x6e,0xa6,0x22,0x6f,0xa6,
0x47,0x70,2,0x68,0x4c,0x6c,0xa2,0x57,0x72,0x17,0x69,0x76,0x61,0x74,0x65,0x75,
0x73,0x65,0xa2,0x4e,0x13,0x61,0x72,0x65,0x61,0xa3,0x4e,1,0x61,0x78,0x6f,1,
0x65,0x5e,0x6e,0x1d,0x65,0x74,0x69,0x63,0x65,0x78,0x74,0x65,0x6e,0x73,0x69,0x6f,
0x6e,0x73,0xa2,0x72,0x19,0x73,0x75,0x70,0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,0xa3,
0x8d,0x15,0x6e,0x69,0x63,0x69,0x61,0x6e,0xa3,0x97,1,0x67,0x38,0x69,0x17,0x73,
0x74,0x6f,0x73,0x64,0x69,0x73,0x63,0xa3,0xa6,0x12,0x73,0x70,0x61,0xa3,0x96,0x19,
0x61,0x79,0x69,0x6e,0x67,0x63,0x61,0x72,0x64,0x73,0xa3,0xcc,4,0x61,0x54,0x65,
0xa2,0x4e,0x69,0xa2,0x65,0x6f,0xa2,0x90,0x79,1,0x63,0x2e,0x64,0x12,0x69,0x61,
0x6e,0xa3,0xa9,0x12,0x69,0x61,0x6e,0xa3,0xa7,1,0x6f,0x55,0x74,0x11,0x69,0x6e,
1,0x31,0x60,0x65,0x16,0x78,0x74,0x65,0x6e,0x64,0x65,0x64,3,0x61,0x30,0x62,
0x29,0x63,0xa3,0x94,0x64,0xa3,0x95,0x26,0x18,0x64,0x64,0x69,0x74,0x69,0x6f,0x6e,
0x61,0x6c,0x6d,0x24,0x19,0x73,0x75,0x70,0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,0x25,
1,0x70,0x42,0x74,0x1d,0x74,0x65,0x72,0x6c,0x69,0x6b,0x65,0x73,0x79,0x6d,0x62,
0x6f,0x6c,0x73,0x79,0x12,0x63,0x68,0x61,0xa3,0x9c,2,0x6d,0x2e,0x6e,0x34,0x73,
0x10,0x75,0xa3,0xb0,0x11,0x62,0x75,0xa3,0x6f,0x13,0x65,0x61,0x72,0x62,1,0x69,
0x38,0x73,0x17,0x79,0x6c,0x6c,0x61,0x62,0x61,0x72,0x79,0xa3,0x75,0x17,0x64,0x65,
0x6f,0x67,0x72,0x61,0x6d,0x73,0xa3,0x76,0x1a,0x77,0x73,0x75,0x72,0x72,0x6f,0x67,
0x61,0x74,0x65,0x73,0xa3,0x4d,5,0x6f,0x46,0x6f,0x4c,0x75,0x86,0x79,0x14,0x61,
0x6e,0x6d,0x61,0x72,0x58,0x18,0x65,0x78,0x74,0x65,0x6e,0x64,0x65,0x64,0x61,0xa3,
0xb6,1,0x64,0x32,0x6e,0x15,0x67,0x6f,0x6c,0x69,0x61,0x6e,0x6b,0x1f,0x69,0x66,
0x69,0x65,0x72,0x74,0x6f,0x6e,0x65,0x6c,0x65,0x74,0x74,0x65,0x72,0x73,0xa3,0x8a,
0x1b,0x73,0x69,0x63,0x61,0x6c,0x73,0x79,0x6d,0x62,0x6f,0x6c,0x73,0xa3,0x5c,0x61,
0xa2,0x60,0x65,0xa2,0xaf,0x69,0x1a,0x73,0x63,0x65,0x6c,0x6c,0x61,0x6e,0x65,0x6f,
0x75,0x73,2,0x6d,0x3a,0x73,0x6c,0x74,0x17,0x65,0x63,0x68,0x6e,0x69,0x63,0x61,
0x6c,0x81,0x11,0x61,0x74,0x1f,0x68,0x65,0x6d,0x61,0x74,0x69,0x63,0x61,0x6c,0x73,
0x79,0x6d,0x62,0x6f,0x6c,0x73,1,0x61,0xa3,0x66,0x62,0xa3,0x69,0x15,0x79,0x6d,
0x62,0x6f,0x6c,0x73,0x8e,0x12,0x61,0x6e,0x64,1,0x61,0x3c,0x70,0x19,0x69,0x63,
0x74,0x6f,0x67,0x72,0x61,0x70,0x68,0x73,0xa3,0xcd,0x14,0x72,0x72,0x6f,0x77,0x73,
0xa3,0x73,3,0x68,0x88,0x6c,0x9c,0x6e,0xa2,0x43,0x74,0x18,0x68,0x65,0x6d,0x61,
0x74,0x69,0x63,0x61,0x6c,1,0x61,0x36,0x6f,0x17,0x70,0x65,0x72,0x61,0x74,0x6f,
0x72,0x73,0x7f,0x11,0x6c,0x70,0x1f,0x68,0x61,0x6e,0x75,0x6d,0x65,0x72,0x69,0x63,
0x73,0x79,0x6d,0x62,0x6f,0x6c,0x73,0xa3,0x5d,0x18,0x6a,0x6f,0x6e,0x67,0x74,0x69,
0x6c,0x65,0x73,0xa3,0xaa,0x15,0x61,0x79,0x61,0x6c,0x61,0x6d,0x4f,0x13,0x64,0x61,
0x69,0x63,0xa3,0xc6,0x18,0x65,0x74,0x65,0x69,0x6d,0x61,0x79,0x65,0x6b,0xa3,0xb8,
3,0x65,0x40,0x6b,0x50,0x6f,0x54,0x75,0x18,0x6d,0x62,0x65,0x72,0x66,0x6f,0x72,
0x6d,0x73,0x7b,0x16,0x77,0x74,0x61,0x69,0x6c,0x75,0x65,0xa3,0x8b,0x10,0x6f,0xa3,
0x92,0x14,0x62,0x6c,0x6f,0x63,0x6b,0x21,4,0x67,0x42,0x6c,0x48,0x70,0xa2,0x4b,
0x72,0xa2,0x64,0x73,0x14,0x6d,0x61,0x6e,0x79,0x61,0xa3,0x7a,0x12,0x68,0x61,0x6d,
0x65,1,0x63,0x80,0x64,3,0x69,0x3a,0x70,0x46,0x73,0x54,0x74,0x14,0x75,0x72,
0x6b,0x69,0x63,0xa3,0xbf,0x14,0x74,0x61,0x6c,0x69,0x63,0xa3,0x58,0x15,0x65,0x72,
0x73,0x69,0x61,0x6e,0xa3,0x8c,0x1a,0x6f,0x75,0x74,0x68,0x61,0x72,0x61,0x62,0x69,
0x61,0x6e,0xa3,0xbb,0x13,0x68,0x69,0x6b,0x69,0xa3,0x9d,0x18,0x74,0x69,0x63,0x61,
0x6c,0x63,0x68,0x61,0x72,0x1f,0x61,0x63,0x74,0x65,0x72,0x72,0x65,0x63,0x6f,0x67,
0x6e,0x69,0x74,0x69,0x6f,0x6e,0x85,0x12,0x69,0x79,0x61,0x47,0x67,0xc2,0x28,0x67,
0xa2,0x87,0x68,0xa4,0xa,0x69,0xa4,0xae,0x6a,0xa6,0x12,0x6b,1,0x61,0x5a,0x68,
1,0x61,0x3e,0x6d,0x11,0x65,0x72,0x68,0x16,0x73,0x79,0x6d,0x62,0x6f,0x6c,0x73,
0xa3,0x71,0x16,0x72,0x6f,0x73,0x68,0x74,0x68,0x69,0xa3,0x89,3,0x69,0x38,0x6e,
0x40,0x74,0x92,0x79,0x13,0x61,0x68,0x6c,0x69,0xa3,0xa2,0x12,0x74,0x68,0x69,0xa3,
0xc1,3,0x61,0x34,0x62,0x4a,0x67,0x50,0x6e,0x12,0x61,0x64,0x61,0x4d,0x19,0x73,
0x75,0x70,0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,0xa3,0xcb,0x11,0x75,0x6e,0xa3,0x42,
0x19,0x78,0x69,0x72,0x61,0x64,0x69,0x63,0x61,0x6c,0x73,0x97,0x14,0x61,0x6b,0x61,
0x6e,0x61,0x9e,0x11,0x70,0x68,0x1f,0x6f,0x6e,0x65,0x74,0x69,0x63,0x65,0x78,0x74,
0x65,0x6e,0x73,0x69,0x6f,0x6e,0x73,0xa3,0x6b,4,0x65,0x58,0x6c,0xa2,0x52,0x6f,
0xa2,0x5a,0x72,0xa2,0x5e,0x75,1,0x6a,0x30,0x72,0x14,0x6d,0x75,0x6b,0x68,0x69,
0x43,0x14,0x61,0x72,0x61,0x74,0x69,0x45,1,0x6e,0x6a,0x6f,1,0x6d,0x48,0x72,
0x13,0x67,0x69,0x61,0x6e,0x5a,0x19,0x73,0x75,0x70,0x70,0x6c,0x65,0x6d,0x65,0x6e,
0x74,0xa3,0x87,0x1a,0x65,0x74,0x72,0x69,0x63,0x73,0x68,0x61,0x70,0x65,0x73,0x8d,
0x1e,0x65,0x72,0x61,0x6c,0x70,0x75,0x6e,0x63,0x74,0x75,0x61,0x74,0x69,0x6f,0x6e,
0x71,0x17,0x61,0x67,0x6f,0x6c,0x69,0x74,0x69,0x63,0xa3,0x88,0x13,0x74,0x68,0x69,
0x63,0xa3,0x59,0x12,0x65,0x65,0x6b,0x30,1,0x61,0x34,0x65,0x16,0x78,0x74,0x65,
0x6e,0x64,0x65,0x64,0x6f,0x17,0x6e,0x64,0x63,0x6f,0x70,0x74,0x69,0x63,0x31,2,
0x61,0x90,0x65,0xa2,0x9b,0x69,1,0x67,0x30,0x72,0x14,0x61,0x67,0x61,0x6e,0x61,
0x9d,0x10,0x68,1,0x70,0x3a,0x73,0x18,0x75,0x72,0x72,0x6f,0x67,0x61,0x74,0x65,
0x73,0xa3,0x4b,0x12,0x72,0x69,0x76,0x1f,0x61,0x74,0x65,0x75,0x73,0x65,0x73,0x75,
0x72,0x72,0x6f,0x67,0x61,0x74,0x65,0x73,0xa3,0x4c,1,0x6c,0xa2,0x47,0x6e,1,
0x67,0x2e,0x75,0x12,0x6e,0x6f,0x6f,0xa3,0x63,0x11,0x75,0x6c,2,0x63,0x3c,0x6a,
0x5e,0x73,0x17,0x79,0x6c,0x6c,0x61,0x62,0x6c,0x65,0x73,0xa3,0x4a,0x1f,0x6f,0x6d,
0x70,0x61,0x74,0x69,0x62,0x69,0x6c,0x69,0x74,0x79,0x6a,0x61,0x6d,0x6f,0xa3,0x41,
0x12,0x61,0x6d,0x6f,0x5c,0x17,0x65,0x78,0x74,0x65,0x6e,0x64,0x65,0x64,1,0x61,
0xa3,0xb4,0x62,0xa3,0xb9,0x16,0x66,0x77,0x69,0x64,0x74,0x68,0x61,0x1f,0x6e,0x64,
0x66,0x75,0x6c,0x6c,0x77,0x69,0x64,0x74,0x68,0x66,0x6f,0x72,0x6d,0x73,0xa3,0x57,
0x13,0x62,0x72,0x65,0x77,0x37,3,0x64,0x44,0x6d,0x82,0x6e,0x9e,0x70,0x1a,0x61,
0x65,0x78,0x74,0x65,0x6e,0x73,0x69,0x6f,0x6e,0x73,0x2b,0x1d,0x65,0x6f,0x67,0x72,
0x61,0x70,0x68,0x69,0x63,0x64,0x65,0x73,0x63,0x72,0x1f,0x69,0x70,0x74,0x69,0x6f,
0x6e,0x63,0x68,0x61,0x72,0x61,0x63,0x74,0x65,0x72,0x73,0x99,0x1c,0x70,0x65,0x72,
0x69,0x61,0x6c,0x61,0x72,0x61,0x6d,0x61,0x69,0x63,0xa3,0xba,0x1c,0x73,0x63,0x72,
0x69,0x70,0x74,0x69,0x6f,0x6e,0x61,0x6c,0x70,0x61,1,0x68,0x32,0x72,0x14,0x74,
0x68,0x69,0x61,0x6e,0xa3,0xbd,0x13,0x6c,0x61,0x76,0x69,0xa3,0xbe,0x16,0x61,0x76,
0x61,0x6e,0x65,0x73,0x65,0xa3,0xb5,0x61,0xa2,0xad,0x62,0xa4,0x7a,0x63,0xa6,0x2c,
0x64,0xaa,0x15,0x65,3,0x67,0x78,0x6d,0x9e,0x6e,0xa2,0x46,0x74,0x15,0x68,0x69,
0x6f,0x70,0x69,0x63,0x5e,1,0x65,0x3a,0x73,0x18,0x75,0x70,0x70,0x6c,0x65,0x6d,
0x65,0x6e,0x74,0xa3,0x86,0x16,0x78,0x74,0x65,0x6e,0x64,0x65,0x64,0xa2,0x85,0x10,
0x61,0xa3,0xc8,0x10,0x79,0x1f,0x70,0x74,0x69,0x61,0x6e,0x68,0x69,0x65,0x72,0x6f,
0x67,0x6c,0x79,0x70,0x68,0x73,0xa3,0xc2,0x16,0x6f,0x74,0x69,0x63,0x6f,0x6e,0x73,
0xa3,0xce,0x15,0x63,0x6c,0x6f,0x73,0x65,0x64,2,0x61,0x56,0x63,0x86,0x69,0x13,
0x64,0x65,0x6f,0x67,0x1f,0x72,0x61,0x70,0x68,0x69,0x63,0x73,0x75,0x70,0x70,0x6c,
0x65,0x6d,0x65,0x6e,0x74,0xa3,0xc4,0x1b,0x6c,0x70,0x68,0x61,0x6e,0x75,0x6d,0x65,
0x72,0x69,0x63,0x73,0x86,0x18,0x75,0x70,0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,0xa3,
0xc3,0x11,0x6a,0x6b,0x1f,0x6c,0x65,0x74,0x74,0x65,0x72,0x73,0x61,0x6e,0x64,0x6d,
0x6f,0x6e,0x74,0x68,0x73,0xa3,0x44,5,0x72,0x52,0x72,0x38,0x73,0xa2,0x48,0x76,
0x14,0x65,0x73,0x74,0x61,0x6e,0xa3,0xbc,2,0x61,0x30,0x6d,0x86,0x72,0x12,0x6f,
0x77,0x73,0x7d,0x12,0x62,0x69,0x63,0x38,1,0x70,0x3a,0x73,0x18,0x75,0x70,0x70,
0x6c,0x65,0x6d,0x65,0x6e,0x74,0xa3,0x80,0x1f,0x72,0x65,0x73,0x65,0x6e,0x74,0x61,
0x74,0x69,0x6f,0x6e,0x66,0x6f,0x72,0x6d,0x73,1,0x61,0xa3,0x51,0x62,0xa3,0x55,
0x14,0x65,0x6e,0x69,0x61,0x6e,0x35,0x12,0x63,0x69,0x69,0x23,0x65,0x94,0x6c,0xa2,
0x45,0x6e,0x14,0x63,0x69,0x65,0x6e,0x74,1,0x67,0x34,0x73,0x15,0x79,0x6d,0x62,
0x6f,0x6c,0x73,0xa3,0xa5,0x13,0x72,0x65,0x65,0x6b,1,0x6d,0x34,0x6e,0x15,0x75,
0x6d,0x62,0x65,0x72,0x73,0xa3,0x7f,0x1d,0x75,0x73,0x69,0x63,0x61,0x6c,0x6e,0x6f,
0x74,0x61,0x74,0x69,0x6f,0x6e,0xa3,0x7e,0x1a,0x67,0x65,0x61,0x6e,0x6e,0x75,0x6d,
0x62,0x65,0x72,0x73,0xa3,0x77,1,0x63,0x5a,0x70,0x17,0x68,0x61,0x62,0x65,0x74,
0x69,0x63,0x70,0x1f,0x72,0x65,0x73,0x65,0x6e,0x74,0x61,0x74,0x69,0x6f,0x6e,0x66,
0x6f,0x72,0x6d,0x73,0xa3,0x50,0x1d,0x68,0x65,0x6d,0x69,0x63,0x61,0x6c,0x73,0x79,
0x6d,0x62,0x6f,0x6c,0x73,0xa3,0xd0,6,0x6f,0x69,0x6f,0x5e,0x72,0x98,0x75,0xa2,
0x51,0x79,0x14,0x7a,0x61,0x6e,0x74,0x69,0x1f,0x6e,0x65,0x6d,0x75,0x73,0x69,0x63,
0x61,0x6c,0x73,0x79,0x6d,0x62,0x6f,0x6c,0x73,0xa3,0x5b,1,0x70,0x34,0x78,0x16,
0x64,0x72,0x61,0x77,0x69,0x6e,0x67,0x89,0x14,0x6f,0x6d,0x6f,0x66,0x6f,0xa0,0x17,
0x65,0x78,0x74,0x65,0x6e,0x64,0x65,0x64,0xa3,0x43,0x10,0x61,1,0x68,0x3c,0x69,
0x1a,0x6c,0x6c,0x65,0x70,0x61,0x74,0x74,0x65,0x72,0x6e,0x73,0x93,0x11,0x6d,0x69,
0xa3,0xc9,1,0x67,0x2c,0x68,0x11,0x69,0x64,0xa3,0x64,0x14,0x69,0x6e,0x65,0x73,
0x65,0xa3,0x81,0x61,0x40,0x65,0x9c,0x6c,0x1a,0x6f,0x63,0x6b,0x65,0x6c,0x65,0x6d,
0x65,0x6e,0x74,0x73,0x8b,3,0x6c,0x34,0x6d,0x40,0x73,0x60,0x74,0x11,0x61,0x6b,
0xa3,0xc7,0x14,0x69,0x6e,0x65,0x73,0x65,0xa3,0x93,0x11,0x75,0x6d,0xa2,0xb1,0x19,
0x73,0x75,0x70,0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,0xa3,0xca,0x16,0x69,0x63,0x6c,
0x61,0x74,0x69,0x6e,0x23,0x14,0x6e,0x67,0x61,0x6c,0x69,0x41,5,0x6f,0xc1,0x19,
0x6f,0xa2,0x44,0x75,0xa2,0xdf,0x79,1,0x70,0x7a,0x72,0x14,0x69,0x6c,0x6c,0x69,
0x63,0x32,1,0x65,0x46,0x73,0x18,0x75,0x70,0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,
0xa2,0x61,0x12,0x61,0x72,0x79,0xa3,0x61,0x16,0x78,0x74,0x65,0x6e,0x64,0x65,0x64,
1,0x61,0xa3,0x9e,0x62,0xa3,0xa0,0x1c,0x72,0x69,0x6f,0x74,0x73,0x79,0x6c,0x6c,
0x61,0x62,0x61,0x72,0x79,0xa3,0x7b,3,0x6d,0x54,0x6e,0xa2,0x84,0x70,0xa2,0x8f,
0x75,0x1f,0x6e,0x74,0x69,0x6e,0x67,0x72,0x6f,0x64,0x6e,0x75,0x6d,0x65,0x72,0x61,
0x6c,0x73,0xa3,0x9a,1,0x62,0x4e,0x6d,0x11,0x6f,0x6e,0x1f,0x69,0x6e,0x64,0x69,
0x63,0x6e,0x75,0x6d,0x62,0x65,0x72,0x66,0x6f,0x72,0x6d,0x73,0xa3,0xb2,0x14,0x69,
0x6e,0x69,0x6e,0x67,2,0x64,0x46,0x68,0x9a,0x6d,0x1d,0x61,0x72,0x6b,0x73,0x66,
0x6f,0x72,0x73,0x79,0x6d,0x62,0x6f,0x6c,0x73,0x77,0x1e,0x69,0x61,0x63,0x72,0x69,
0x74,0x69,0x63,0x61,0x6c,0x6d,0x61,0x72,0x6b,0x73,0x2e,1,0x66,0x3a,0x73,0x18,
0x75,0x70,0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,0xa3,0x83,0x18,0x6f,0x72,0x73,0x79,
0x6d,0x62,0x6f,0x6c,0x73,0x77,0x17,0x61,0x6c,0x66,0x6d,0x61,0x72,0x6b,0x73,0xa3,
0x52,0x1b,0x74,0x72,0x6f,0x6c,0x70,0x69,0x63,0x74,0x75,0x72,0x65,0x73,0x83,0x12,
0x74,0x69,0x63,0xa3,0x84,1,0x6e,0x3e,0x72,0x1b,0x72,0x65,0x6e,0x63,0x79,0x73,
0x79,0x6d,0x62,0x6f,0x6c,0x73,0x75,0x15,0x65,0x69,0x66,0x6f,0x72,0x6d,0xa2,0x98,
0x14,0x6e,0x75,0x6d,0x62,0x65,0x1f,0x72,0x73,0x61,0x6e,0x64,0x70,0x75,0x6e,0x63,
0x74,0x75,0x61,0x74,0x69,0x6f,0x6e,0xa3,0x99,0x61,0xa2,0xa3,0x68,0xa2,0xba,0x6a,
0x10,0x6b,3,0x63,0x82,0x72,0xa2,0x61,0x73,0xa2,0x72,0x75,0x1f,0x6e,0x69,0x66,
0x69,0x65,0x64,0x69,0x64,0x65,0x6f,0x67,0x72,0x61,0x70,0x68,0x73,0xa2,0x47,0x18,
0x65,0x78,0x74,0x65,0x6e,0x73,0x69,0x6f,0x6e,3,0x61,0xa3,0x46,0x62,0xa3,0x5e,
0x63,0xa3,0xc5,0x64,0xa3,0xd1,0x1b,0x6f,0x6d,0x70,0x61,0x74,0x69,0x62,0x69,0x6c,
0x69,0x74,0x79,0xa2,0x45,1,0x66,0x54,0x69,0x18,0x64,0x65,0x6f,0x67,0x72,0x61,
0x70,0x68,0x73,0xa2,0x4f,0x19,0x73,0x75,0x70,0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,
0xa3,0x5f,0x13,0x6f,0x72,0x6d,0x73,0xa3,0x53,0x10,0x61,0x1f,0x64,0x69,0x63,0x61,
0x6c,0x73,0x73,0x75,0x70,0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,0x95,1,0x74,0x4e,
0x79,0x12,0x6d,0x62,0x6f,0x1f,0x6c,0x73,0x61,0x6e,0x64,0x70,0x75,0x6e,0x63,0x74,
0x75,0x61,0x74,0x69,0x6f,0x6e,0x9b,0x14,0x72,0x6f,0x6b,0x65,0x73,0xa3,0x82,1,
0x6e,0x2e,0x72,0x12,0x69,0x61,0x6e,0xa3,0xa8,0x1d,0x61,0x64,0x69,0x61,0x6e,0x73,
0x79,0x6c,0x6c,0x61,0x62,0x69,0x63,0x73,0x63,1,0x61,0x30,0x65,0x14,0x72,0x6f,
0x6b,0x65,0x65,0x61,0x10,0x6d,0xa3,0xa4,2,0x65,0x3e,0x69,0x78,0x6f,0x18,0x6d,
0x69,0x6e,0x6f,0x74,0x69,0x6c,0x65,0x73,0xa3,0xab,1,0x73,0x4a,0x76,0x16,0x61,
0x6e,0x61,0x67,0x61,0x72,0x69,0x3e,0x17,0x65,0x78,0x74,0x65,0x6e,0x64,0x65,0x64,
0xa3,0xb3,0x13,0x65,0x72,0x65,0x74,0xa3,0x5a,0x15,0x6e,0x67,0x62,0x61,0x74,0x73,
0x91,8,0x6d,0x5f,0x6d,0x3a,0x6e,0x48,0x73,0x7a,0x76,0xa2,0x4b,0x77,0x12,0x69,
0x64,0x65,0x43,0x11,0x65,0x64,0x32,0x12,0x69,0x61,0x6c,0x33,2,0x61,0x40,0x62,
0x37,0x6f,1,0x62,0x28,0x6e,0x10,0x65,0x21,0x13,0x72,0x65,0x61,0x6b,0x37,0x10,
0x72,0x34,0x12,0x72,0x6f,0x77,0x35,2,0x6d,0x38,0x71,0x46,0x75,1,0x62,0x3d,
0x70,0x3e,0x11,0x65,0x72,0x3f,1,0x61,0x24,0x6c,0x39,0x11,0x6c,0x6c,0x39,1,
0x72,0x3b,0x75,0x12,0x61,0x72,0x65,0x3b,0x12,0x65,0x72,0x74,0x40,0x13,0x69,0x63,
0x61,0x6c,0x41,0x63,0x58,0x65,0x92,0x66,0x96,0x69,1,0x6e,0x36,0x73,0x10,0x6f,
0x30,0x14,0x6c,0x61,0x74,0x65,0x64,0x31,0x11,0x69,0x74,0x2e,0x12,0x69,0x61,0x6c,
0x2f,2,0x61,0x36,0x69,0x48,0x6f,0x10,0x6d,0x24,0x12,0x70,0x61,0x74,0x25,0x10,
0x6e,0x22,0x15,0x6f,0x6e,0x69,0x63,0x61,0x6c,0x23,0x13,0x72,0x63,0x6c,0x65,0x27,
0x11,0x6e,0x63,0x27,2,0x69,0x3a,0x6f,0x44,0x72,0x10,0x61,0x2c,0x14,0x63,0x74,
0x69,0x6f,0x6e,0x2d,0x10,0x6e,0x28,0x11,0x61,0x6c,0x29,0x11,0x6e,0x74,0x2b,4,
0x61,0x3a,0x66,0x4c,0x68,0x5e,0x6e,0x70,0x77,0x2a,0x12,0x69,0x64,0x65,0x2b,0x22,
0x17,0x6d,0x62,0x69,0x67,0x75,0x6f,0x75,0x73,0x23,0x26,0x17,0x75,0x6c,0x6c,0x77,
0x69,0x64,0x74,0x68,0x27,0x24,0x17,0x61,0x6c,0x66,0x77,0x69,0x64,0x74,0x68,0x25,
0x20,1,0x61,0x30,0x65,0x14,0x75,0x74,0x72,0x61,0x6c,0x21,0x28,0x13,0x72,0x72,
0x6f,0x77,0x29,0xd,0x6e,0xc0,0xfb,0x73,0x6d,0x73,0x3a,0x74,0x98,0x75,0xa2,0x49,
0x7a,2,0x6c,0x3b,0x70,0x3d,0x73,0x39,5,0x6f,0x28,0x6f,0x57,0x70,0x34,0x75,
0x16,0x72,0x72,0x6f,0x67,0x61,0x74,0x65,0x45,0x11,0x61,0x63,1,0x65,0x32,0x69,
0x15,0x6e,0x67,0x6d,0x61,0x72,0x6b,0x31,0x18,0x73,0x65,0x70,0x61,0x72,0x61,0x74,
0x6f,0x72,0x39,0x63,0x53,0x6b,0x55,0x6d,0x51,0x1d,0x69,0x74,0x6c,0x65,0x63,0x61,
0x73,0x65,0x6c,0x65,0x74,0x74,0x65,0x72,0x27,1,0x6e,0x40,0x70,0x1c,0x70,0x65,
0x72,0x63,0x61,0x73,0x65,0x6c,0x65,0x74,0x74,0x65,0x72,0x23,0x17,0x61,0x73,0x73,
0x69,0x67,0x6e,0x65,0x64,0x21,0x6e,0x8a,0x6f,0xa2,0x47,0x70,8,0x66,0x14,0x66,
0x5b,0x69,0x59,0x6f,0x4f,0x72,0x24,0x73,0x49,0x17,0x69,0x76,0x61,0x74,0x65,0x75,
0x73,0x65,0x43,0x61,0x2c,0x63,0x4d,0x64,0x47,0x65,0x4b,0x1f,0x72,0x61,0x67,0x72,
0x61,0x70,0x68,0x73,0x65,0x70,0x61,0x72,0x61,0x74,0x6f,0x72,0x3d,2,0x64,0x33,
0x6c,0x35,0x6f,0x36,0x1b,0x6e,0x73,0x70,0x61,0x63,0x69,0x6e,0x67,0x6d,0x61,0x72,
0x6b,0x2d,1,0x70,0x7c,0x74,0x12,0x68,0x65,0x72,3,0x6c,0x38,0x6e,0x42,0x70,
0x4c,0x73,0x14,0x79,0x6d,0x62,0x6f,0x6c,0x57,0x14,0x65,0x74,0x74,0x65,0x72,0x2b,
0x14,0x75,0x6d,0x62,0x65,0x72,0x37,0x19,0x75,0x6e,0x63,0x74,0x75,0x61,0x74,0x69,
0x6f,0x6e,0x4f,0x1c,0x65,0x6e,0x70,0x75,0x6e,0x63,0x74,0x75,0x61,0x74,0x69,0x6f,
0x6e,0x49,0x66,0x9e,0x66,0x88,0x69,0xa2,0x4b,0x6c,0xa2,0x5c,0x6d,4,0x61,0x60,
0x63,0x31,0x65,0x2f,0x6e,0x2d,0x6f,0x15,0x64,0x69,0x66,0x69,0x65,0x72,1,0x6c,
0x30,0x73,0x14,0x79,0x6d,0x62,0x6f,0x6c,0x55,0x14,0x65,0x74,0x74,0x65,0x72,0x29,
0x17,0x74,0x68,0x73,0x79,0x6d,0x62,0x6f,0x6c,0x51,1,0x69,0x2e,0x6f,0x13,0x72,
0x6d,0x61,0x74,0x41,0x1d,0x6e,0x61,0x6c,0x70,0x75,0x6e,0x63,0x74,0x75,0x61,0x74,
0x69,0x6f,0x6e,0x5b,0x10,0x6e,0x1f,0x69,0x74,0x69,0x61,0x6c,0x70,0x75,0x6e,0x63,
0x74,0x75,0x61,0x74,0x69,0x6f,0x6e,0x59,6,0x6d,0x18,0x6d,0x29,0x6f,0x28,0x74,
0x27,0x75,0x23,0x2a,0x1c,0x77,0x65,0x72,0x63,0x61,0x73,0x65,0x6c,0x65,0x74,0x74,
0x65,0x72,0x25,0x65,0x28,0x69,0x3c,0x6c,0x25,0x19,0x74,0x74,0x65,0x72,0x6e,0x75,
0x6d,0x62,0x65,0x72,0x35,0x1a,0x6e,0x65,0x73,0x65,0x70,0x61,0x72,0x61,0x74,0x6f,
0x72,0x3b,0x63,0x44,0x64,0xa2,0x60,0x65,0x1b,0x6e,0x63,0x6c,0x6f,0x73,0x69,0x6e,
0x67,0x6d,0x61,0x72,0x6b,0x2f,6,0x6e,0x39,0x6e,0x46,0x6f,0x4e,0x73,0x45,0x75,
0x1b,0x72,0x72,0x65,0x6e,0x63,0x79,0x73,0x79,0x6d,0x62,0x6f,0x6c,0x53,0x20,0x12,
0x74,0x72,0x6c,0x3f,0x42,0x10,0x6e,1,0x6e,0x2c,0x74,0x12,0x72,0x6f,0x6c,0x3f,
0x1f,0x65,0x63,0x74,0x6f,0x72,0x70,0x75,0x6e,0x63,0x74,0x75,0x61,0x74,0x69,0x6f,
0x6e,0x4d,0x63,0x3f,0x66,0x41,0x6c,0x1d,0x6f,0x73,0x65,0x70,0x75,0x6e,0x63,0x74,
0x75,0x61,0x74,0x69,0x6f,0x6e,0x4b,2,0x61,0x30,0x65,0x4a,0x69,0x12,0x67,0x69,
0x74,0x33,0x1c,0x73,0x68,0x70,0x75,0x6e,0x63,0x74,0x75,0x61,0x74,0x69,0x6f,0x6e,
0x47,0x1a,0x63,0x69,0x6d,0x61,0x6c,0x6e,0x75,0x6d,0x62,0x65,0x72,0x33,8,0x70,
0x26,0x70,0x34,0x73,0x46,0x74,0x31,0x76,0x33,0x78,0x10,0x78,0x21,1,0x70,0x37,
0x72,0x14,0x65,0x70,0x65,0x6e,0x64,0x37,1,0x6d,0x35,0x70,0x18,0x61,0x63,0x69,
0x6e,0x67,0x6d,0x61,0x72,0x6b,0x35,0x63,0x36,0x65,0x4e,0x6c,0x5c,0x6f,0x13,0x74,
0x68,0x65,0x72,0x21,2,0x6e,0x23,0x6f,0x24,0x72,0x25,0x14,0x6e,0x74,0x72,0x6f,
0x6c,0x23,0x10,0x78,0x26,0x13,0x74,0x65,0x6e,0x64,0x27,0x28,1,0x66,0x2b,0x76,
0x2c,0x10,0x74,0x2f,3,0x6c,0x42,0x6e,0x90,0x74,0xa2,0x46,0x76,0x24,0x17,0x6f,
0x77,0x65,0x6c,0x6a,0x61,0x6d,0x6f,0x25,0x22,1,0x65,0x54,0x76,0x28,1,0x73,
0x38,0x74,0x2a,0x17,0x73,0x79,0x6c,0x6c,0x61,0x62,0x6c,0x65,0x2b,0x16,0x79,0x6c,
0x6c,0x61,0x62,0x6c,0x65,0x29,0x18,0x61,0x64,0x69,0x6e,0x67,0x6a,0x61,0x6d,0x6f,
0x23,1,0x61,0x21,0x6f,0x1a,0x74,0x61,0x70,0x70,0x6c,0x69,0x63,0x61,0x62,0x6c,
0x65,0x21,0x26,0x1a,0x72,0x61,0x69,0x6c,0x69,0x6e,0x67,0x6a,0x61,0x6d,0x6f,0x27,
0,0x12,0x6d,0xc0,0xe3,0x73,0x92,0x73,0x4e,0x74,0xa2,0x47,0x77,0xa2,0x63,0x79,
0xa2,0x64,0x7a,1,0x61,0x2c,0x68,0x12,0x61,0x69,0x6e,0x8b,0x11,0x69,0x6e,0x85,
4,0x61,0x40,0x65,0x4a,0x68,0x60,0x77,0x64,0x79,0x16,0x72,0x69,0x61,0x63,0x77,
0x61,0x77,0x6f,0x10,0x64,0x62,0x11,0x68,0x65,0x65,1,0x65,0x2e,0x6d,0x13,0x6b,
0x61,0x74,0x68,0x69,0x10,0x6e,0x67,0x11,0x69,0x6e,0x6b,0x15,0x61,0x73,0x68,0x6b,
0x61,0x66,0x6d,1,0x61,0x4e,0x65,1,0x68,0x28,0x74,0x10,0x68,0x77,0x16,0x6d,
0x61,0x72,0x62,0x75,0x74,0x61,0x74,0x13,0x67,0x6f,0x61,0x6c,0x3d,1,0x68,0x71,
0x77,0x73,0x11,0x61,0x77,0x79,1,0x65,0x32,0x75,0x11,0x64,0x68,0x80,0x11,0x68,
0x65,0x83,0x10,0x68,0x7a,1,0x62,0x34,0x77,0x16,0x69,0x74,0x68,0x74,0x61,0x69,
0x6c,0x7f,0x14,0x61,0x72,0x72,0x65,0x65,0x7d,0x6d,0x4c,0x6e,0x5e,0x70,0x9a,0x71,
0x9c,0x72,0x10,0x65,1,0x68,0x5f,0x76,0x16,0x65,0x72,0x73,0x65,0x64,0x70,0x65,
0x61,1,0x65,0x28,0x69,0x10,0x6d,0x53,0x11,0x65,0x6d,0x51,2,0x6f,0x2c,0x75,
0x50,0x79,0x10,0x61,0x91,1,0x6a,0x28,0x6f,0x10,0x6e,0x55,0x1a,0x6f,0x69,0x6e,
0x69,0x6e,0x67,0x67,0x72,0x6f,0x75,0x70,0x21,0x10,0x6e,0x57,0x10,0x65,0x59,0x10,
0x61,1,0x66,0x5b,0x70,0x10,0x68,0x5d,0x66,0x7b,0x66,0x42,0x67,0x7a,0x68,0x8a,
0x6b,0xa2,0x56,0x6c,0x11,0x61,0x6d,0x4c,0x12,0x61,0x64,0x68,0x4f,2,0x61,0x3e,
0x65,0x4a,0x69,0x19,0x6e,0x61,0x6c,0x73,0x65,0x6d,0x6b,0x61,0x74,0x68,0x35,0x15,
0x72,0x73,0x69,0x79,0x65,0x68,0x8f,0x86,0x10,0x68,0x33,0x10,0x61,1,0x66,0x37,
0x6d,0x11,0x61,0x6c,0x39,1,0x61,0x40,0x65,0x3e,1,0x68,0x28,0x74,0x10,0x68,
0x45,0x40,0x13,0x67,0x6f,0x61,0x6c,0x43,1,0x68,0x3b,0x6d,0x1a,0x7a,0x61,0x6f,
0x6e,0x68,0x65,0x68,0x67,0x6f,0x61,0x6c,0x3d,2,0x61,0x3a,0x68,0x44,0x6e,0x17,
0x6f,0x74,0x74,0x65,0x64,0x68,0x65,0x68,0x4b,1,0x66,0x47,0x70,0x10,0x68,0x49,
0x12,0x61,0x70,0x68,0x89,0x61,0x2c,0x62,0x4c,0x64,0x86,0x65,0x31,1,0x69,0x38,
0x6c,1,0x61,0x28,0x65,0x10,0x66,0x27,0x11,0x70,0x68,0x25,0x10,0x6e,0x23,1,
0x65,0x4a,0x75,0x10,0x72,0x1f,0x75,0x73,0x68,0x61,0x73,0x6b,0x69,0x79,0x65,0x68,
0x62,0x61,0x72,0x72,0x65,0x65,0x8d,1,0x68,0x29,0x74,0x10,0x68,0x2b,0x11,0x61,
0x6c,0x2c,0x16,0x61,0x74,0x68,0x72,0x69,0x73,0x68,0x2f,7,0x6e,0x2e,0x6e,0x2c,
0x72,0x3e,0x74,0x56,0x75,0x21,0x18,0x6f,0x6e,0x6a,0x6f,0x69,0x6e,0x69,0x6e,0x67,
0x21,0x28,0x1a,0x69,0x67,0x68,0x74,0x6a,0x6f,0x69,0x6e,0x69,0x6e,0x67,0x29,0x2a,
0x19,0x72,0x61,0x6e,0x73,0x70,0x61,0x72,0x65,0x6e,0x74,0x2b,0x63,0x23,0x64,0x40,
0x6a,0x56,0x6c,0x26,0x19,0x65,0x66,0x74,0x6a,0x6f,0x69,0x6e,0x69,0x6e,0x67,0x27,
0x24,0x19,0x75,0x61,0x6c,0x6a,0x6f,0x69,0x6e,0x69,0x6e,0x67,0x25,0x19,0x6f,0x69,
0x6e,0x63,0x61,0x75,0x73,0x69,0x6e,0x67,0x23,0,0x12,0x6d,0xc0,0xc5,0x73,0x46,
0x73,0x42,0x75,0x72,0x77,0x7e,0x78,0x96,0x7a,0x10,0x77,0x58,0x14,0x73,0x70,0x61,
0x63,0x65,0x59,4,0x61,0x51,0x67,0x53,0x70,0x28,0x75,0x30,0x79,0x57,0x54,0x12,
0x61,0x63,0x65,0x55,0x16,0x72,0x72,0x6f,0x67,0x61,0x74,0x65,0x53,0x15,0x6e,0x6b,
0x6e,0x6f,0x77,0x6e,0x21,1,0x6a,0x5d,0x6f,0x17,0x72,0x64,0x6a,0x6f,0x69,0x6e,
0x65,0x72,0x5d,0x10,0x78,0x21,0x6d,0x4a,0x6e,0x64,0x6f,0xa2,0x43,0x70,0xa2,0x52,
0x71,0x10,0x75,0x4e,0x16,0x6f,0x74,0x61,0x74,0x69,0x6f,0x6e,0x4f,0x1c,0x61,0x6e,
0x64,0x61,0x74,0x6f,0x72,0x79,0x62,0x72,0x65,0x61,0x6b,0x2d,4,0x65,0x3e,0x6c,
0x5b,0x6f,0x46,0x73,0x45,0x75,0x46,0x14,0x6d,0x65,0x72,0x69,0x63,0x47,0x15,0x78,
0x74,0x6c,0x69,0x6e,0x65,0x5b,0x17,0x6e,0x73,0x74,0x61,0x72,0x74,0x65,0x72,0x45,
0x10,0x70,0x48,0x1c,0x65,0x6e,0x70,0x75,0x6e,0x63,0x74,0x75,0x61,0x74,0x69,0x6f,
0x6e,0x49,1,0x6f,0x3e,0x72,0x4c,0x1a,0x65,0x66,0x69,0x78,0x6e,0x75,0x6d,0x65,
0x72,0x69,0x63,0x4d,0x4a,0x1b,0x73,0x74,0x66,0x69,0x78,0x6e,0x75,0x6d,0x65,0x72,
0x69,0x63,0x4b,0x67,0x62,0x67,0x48,0x68,0x52,0x69,0x68,0x6a,0xa2,0x52,0x6c,1,
0x66,0x43,0x69,0x15,0x6e,0x65,0x66,0x65,0x65,0x64,0x43,0x10,0x6c,0x38,0x11,0x75,
0x65,0x39,2,0x32,0x5f,0x33,0x61,0x79,0x3a,0x13,0x70,0x68,0x65,0x6e,0x3b,2,
0x64,0x28,0x6e,0x3c,0x73,0x41,0x3c,0x18,0x65,0x6f,0x67,0x72,0x61,0x70,0x68,0x69,
0x63,0x3d,0x3e,1,0x66,0x3e,0x73,0x11,0x65,0x70,1,0x61,0x22,0x65,0x14,0x72,
0x61,0x62,0x6c,0x65,0x3f,0x18,0x69,0x78,0x6e,0x75,0x6d,0x65,0x72,0x69,0x63,0x41,
2,0x6c,0x63,0x74,0x65,0x76,0x67,0x61,0x48,0x62,0x78,0x63,0xa2,0x59,0x65,0x10,
0x78,0x36,0x18,0x63,0x6c,0x61,0x6d,0x61,0x74,0x69,0x6f,0x6e,0x37,2,0x69,0x23,
0x6c,0x34,0x6d,0x16,0x62,0x69,0x67,0x75,0x6f,0x75,0x73,0x23,0x24,0x17,0x70,0x68,
0x61,0x62,0x65,0x74,0x69,0x63,0x25,4,0x32,0x27,0x61,0x29,0x62,0x2b,0x6b,0x2d,
0x72,0x12,0x65,0x61,0x6b,2,0x61,0x36,0x62,0x3e,0x73,0x15,0x79,0x6d,0x62,0x6f,
0x6c,0x73,0x57,0x13,0x66,0x74,0x65,0x72,0x29,1,0x65,0x2a,0x6f,0x11,0x74,0x68,
0x27,0x13,0x66,0x6f,0x72,0x65,0x2b,6,0x6d,0x35,0x6d,0x33,0x6f,0x28,0x70,0x69,
0x72,0x35,1,0x6d,0x3e,0x6e,0x1b,0x74,0x69,0x6e,0x67,0x65,0x6e,0x74,0x62,0x72,
0x65,0x61,0x6b,0x2f,1,0x62,0x3a,0x70,0x19,0x6c,0x65,0x78,0x63,0x6f,0x6e,0x74,
0x65,0x78,0x74,0x51,0x18,0x69,0x6e,0x69,0x6e,0x67,0x6d,0x61,0x72,0x6b,0x33,0x61,
0x66,0x62,0x2f,0x6c,0x30,0x13,0x6f,0x73,0x65,0x70,1,0x61,0x38,0x75,0x18,0x6e,
0x63,0x74,0x75,0x61,0x74,0x69,0x6f,0x6e,0x31,0x18,0x72,0x65,0x6e,0x74,0x68,0x65,
0x73,0x69,0x73,0x69,0x1b,0x72,0x72,0x69,0x61,0x67,0x65,0x72,0x65,0x74,0x75,0x72,
0x6e,0x35,2,0x6d,0x30,0x6e,0x3a,0x79,0x22,0x11,0x65,0x73,0x23,0x24,0x13,0x61,
0x79,0x62,0x65,0x25,0x20,0x10,0x6f,0x21,1,0x6e,0x2c,0x79,0x22,0x11,0x65,0x73,
0x23,0x20,0x10,0x6f,0x21,2,0x6d,0x30,0x6e,0x3a,0x79,0x22,0x11,0x65,0x73,0x23,
0x24,0x13,0x61,0x79,0x62,0x65,0x25,0x20,0x10,0x6f,0x21,1,0x6e,0x2c,0x79,0x22,
0x11,0x65,0x73,0x23,0x20,0x10,0x6f,0x21,1,0x64,0x42,0x6e,1,0x6f,0x32,0x75,
0x26,0x14,0x6d,0x65,0x72,0x69,0x63,0x27,0x11,0x6e,0x65,0x21,1,0x65,0x2e,0x69,
0x24,0x12,0x67,0x69,0x74,0x25,0x22,0x14,0x63,0x69,0x6d,0x61,0x6c,0x23,0,0x18,
0x6e,0xc2,0xc6,0x74,0xc1,0x15,0x77,0x53,0x77,0x7e,0x78,0x96,0x79,0xa2,0x45,0x7a,
5,0x78,0x13,0x78,0x30,0x79,0x36,0x7a,0x11,0x7a,0x7a,0xa3,0x67,0x11,0x78,0x78,
0xa3,0x66,0x11,0x79,0x79,0x21,0x69,0x30,0x6d,0x34,0x73,0x11,0x79,0x6d,0xa3,0x81,
0x11,0x6e,0x68,0x23,0x11,0x74,0x68,0xa3,0x80,1,0x61,0x2c,0x6f,0x11,0x6c,0x65,
0xa3,0x9b,0x11,0x72,0x61,0xa3,0x92,1,0x70,0x2c,0x73,0x11,0x75,0x78,0xa3,0x65,
0x11,0x65,0x6f,0x9b,0x10,0x69,0x72,0x11,0x69,0x69,0x73,0x74,0x4a,0x75,0xa2,0xa5,
0x76,1,0x61,0x2c,0x69,0x11,0x73,0x70,0xa3,0x64,0x10,0x69,0xa2,0x63,0x10,0x69,
0xa3,0x63,5,0x67,0x2a,0x67,0x50,0x68,0x54,0x69,1,0x62,0x30,0x66,0x14,0x69,
0x6e,0x61,0x67,0x68,0x99,1,0x65,0x24,0x74,0x6f,0x12,0x74,0x61,0x6e,0x6f,0x11,
0x6c,0x67,0x75,0x10,0x61,1,0x61,0x24,0x69,0x6d,0x6a,0x11,0x6e,0x61,0x6b,0x61,
0x30,0x65,0xa2,0x52,0x66,0x11,0x6e,0x67,0x99,6,0x6c,0x1c,0x6c,0x32,0x6d,0x38,
0x6e,0x44,0x76,0x10,0x74,0xa3,0x7f,1,0x65,0x89,0x75,0x97,1,0x69,0x24,0x6c,
0x67,0x10,0x6c,0x67,0x10,0x67,0xa3,0x9a,0x67,0x2e,0x69,0x4a,0x6b,0x10,0x72,0xa3,
0x99,1,0x61,0x30,0x62,0x7a,0x13,0x61,0x6e,0x77,0x61,0x7b,0x12,0x6c,0x6f,0x67,
0x75,2,0x6c,0x32,0x74,0x34,0x76,0x12,0x69,0x65,0x74,0xa3,0x7f,0x10,0x65,0x89,
0x12,0x68,0x61,0x6d,0xa3,0x6a,1,0x6c,0x2a,0x6e,0x10,0x67,0xa3,0x62,0x10,0x75,
0x68,0x11,0x67,0x75,0x69,1,0x67,0x32,0x6e,0x14,0x6b,0x6e,0x6f,0x77,0x6e,0xa3,
0x67,0x11,0x61,0x72,0x8a,0x13,0x69,0x74,0x69,0x63,0x8b,0x71,0xc0,0xc1,0x71,0xa2,
0x93,0x72,0xa2,0x98,0x73,6,0x69,0x48,0x69,0x6e,0x6f,0x84,0x75,0x8a,0x79,1,
0x6c,0x46,0x72,4,0x63,0x65,0x65,0xa3,0x5f,0x69,0x2c,0x6a,0xa3,0x60,0x6e,0xa3,
0x61,0x11,0x61,0x63,0x65,0x10,0x6f,0x94,0x16,0x74,0x69,0x6e,0x61,0x67,0x72,0x69,
0x95,0x10,0x6e,1,0x64,0xa3,0x91,0x68,0x62,0x12,0x61,0x6c,0x61,0x63,0x11,0x72,
0x61,0xa3,0x98,0x11,0x6e,0x64,0xa2,0x71,0x14,0x61,0x6e,0x65,0x73,0x65,0xa3,0x71,
0x61,0x4a,0x67,0x96,0x68,1,0x61,0x2a,0x72,0x10,0x64,0xa3,0x97,1,0x76,0x24,
0x77,0x87,0x12,0x69,0x61,0x6e,0x87,2,0x6d,0x40,0x72,0x58,0x75,0x10,0x72,0xa2,
0x6f,0x15,0x61,0x73,0x68,0x74,0x72,0x61,0xa3,0x6f,1,0x61,0x26,0x72,0xa3,0x7e,
0x14,0x72,0x69,0x74,0x61,0x6e,0xa3,0x7e,1,0x61,0xa3,0x5e,0x62,0xa3,0x85,0x11,
0x6e,0x77,0xa3,0x70,0x11,0x61,0x61,1,0x63,0x2f,0x69,0x23,3,0x65,0x3e,0x6a,
0x48,0x6f,0x4e,0x75,0x10,0x6e,1,0x69,0x24,0x72,0x61,0x10,0x63,0x61,0x13,0x6a,
0x61,0x6e,0x67,0xa3,0x6e,0x11,0x6e,0x67,0xa3,0x6e,0x11,0x72,0x6f,0xa3,0x5d,0x6e,
0xa2,0x4c,0x6f,0xa2,0x79,0x70,4,0x61,0x38,0x65,0x3e,0x68,0x44,0x6c,0x94,0x72,
0x11,0x74,0x69,0xa3,0x7d,0x11,0x6c,0x6d,0xa3,0x90,0x11,0x72,0x6d,0xa3,0x59,3,
0x61,0x3e,0x6c,0x4e,0x6e,0x5e,0x6f,0x16,0x65,0x6e,0x69,0x63,0x69,0x61,0x6e,0xa3,
0x5b,0x10,0x67,0xa2,0x5a,0x12,0x73,0x70,0x61,0xa3,0x5a,2,0x69,0xa3,0x7a,0x70,
0xa3,0x7b,0x76,0xa3,0x7c,0x10,0x78,0xa3,0x5b,0x11,0x72,0x64,0xa3,0x5c,4,0x61,
0x38,0x62,0x3e,0x65,0x44,0x6b,0x52,0x73,0x11,0x68,0x75,0xa3,0x96,0x11,0x72,0x62,
0xa3,0x8e,0x11,0x61,0x74,0xa3,0x8f,0x16,0x77,0x74,0x61,0x69,0x6c,0x75,0x65,0x97,
1,0x67,0x2e,0x6f,0xa2,0x57,0x10,0x6f,0xa3,0x57,0x10,0x62,0xa3,0x84,3,0x67,
0x3e,0x6c,0x50,0x72,0xa2,0x52,0x73,0x11,0x6d,0x61,0x84,0x12,0x6e,0x79,0x61,0x85,
1,0x61,0x2a,0x68,0x11,0x61,0x6d,0x5b,0x10,0x6d,0x5b,1,0x63,0x7c,0x64,3,
0x69,0x3a,0x70,0x44,0x73,0x50,0x74,0x14,0x75,0x72,0x6b,0x69,0x63,0xa3,0x58,0x14,
0x74,0x61,0x6c,0x69,0x63,0x5d,0x15,0x65,0x72,0x73,0x69,0x61,0x6e,0x9b,0x1a,0x6f,
0x75,0x74,0x68,0x61,0x72,0x61,0x62,0x69,0x61,0x6e,0xa3,0x85,1,0x68,0x26,0x6b,
0xa3,0x6d,0x12,0x69,0x6b,0x69,0xa3,0x6d,2,0x69,0x2c,0x6b,0x30,0x79,0x10,0x61,
0x5f,0x11,0x79,0x61,0x5f,0x10,0x68,0xa3,0x58,0x68,0xc2,0x10,0x6b,0xc1,0x55,0x6b,
0xa2,0x7c,0x6c,0xa2,0xe7,0x6d,6,0x6f,0x30,0x6f,0x44,0x72,0x64,0x74,0x6a,0x79,
1,0x61,0x28,0x6d,0x10,0x72,0x59,0x13,0x6e,0x6d,0x61,0x72,0x59,1,0x6e,0x2a,
0x6f,0x10,0x6e,0xa3,0x72,0x10,0x67,0x56,0x14,0x6f,0x6c,0x69,0x61,0x6e,0x57,0x11,
0x6f,0x6f,0xa3,0x95,0x11,0x65,0x69,0xa3,0x73,0x61,0x2e,0x65,0x6a,0x6c,0x11,0x79,
0x6d,0x55,2,0x6c,0x2e,0x6e,0x3a,0x79,0x10,0x61,0xa3,0x55,0x15,0x61,0x79,0x61,
0x6c,0x61,0x6d,0x55,1,0x64,0x26,0x69,0xa3,0x79,0xa2,0x54,0x12,0x61,0x69,0x63,
0xa3,0x54,2,0x65,0x34,0x6e,0x46,0x72,1,0x63,0xa3,0x8d,0x6f,0xa3,0x56,0x17,
0x74,0x65,0x69,0x6d,0x61,0x79,0x65,0x6b,0xa3,0x73,0x10,0x64,0xa3,0x8c,5,0x6f,
0x14,0x6f,0x30,0x70,0x36,0x74,0x11,0x68,0x69,0xa3,0x78,0x11,0x72,0x65,0xa3,0x77,
0x11,0x65,0x6c,0xa3,0x8a,0x61,0x2e,0x68,0x98,0x6e,0x11,0x64,0x61,0x4b,4,0x69,
0x3c,0x6c,0x44,0x6e,0x48,0x74,0x56,0x79,0x13,0x61,0x68,0x6c,0x69,0xa3,0x4f,0x12,
0x74,0x68,0x69,0xa3,0x78,0x10,0x69,0xa3,0x4f,1,0x61,0x4d,0x6e,0x12,0x61,0x64,
0x61,0x4b,0x14,0x61,0x6b,0x61,0x6e,0x61,0x4c,0x19,0x6f,0x72,0x68,0x69,0x72,0x61,
0x67,0x61,0x6e,0x61,0x8d,1,0x61,0x32,0x6d,1,0x65,0x24,0x72,0x4f,0x10,0x72,
0x4f,0x10,0x72,0x92,0x15,0x6f,0x73,0x68,0x74,0x68,0x69,0x93,4,0x61,0x5c,0x65,
0x90,0x69,0xa0,0x6f,0xa2,0x59,0x79,1,0x63,0x34,0x64,0x10,0x69,0xa2,0x6c,0x11,
0x61,0x6e,0xa3,0x6c,0x10,0x69,0xa2,0x6b,0x11,0x61,0x6e,0xa3,0x6b,2,0x6e,0x42,
0x6f,0x46,0x74,3,0x66,0xa3,0x50,0x67,0xa3,0x51,0x69,0x24,0x6e,0x53,0x10,0x6e,
0x53,0x10,0x61,0xa3,0x6a,0x50,0x10,0x6f,0x51,0x11,0x70,0x63,0xa2,0x52,0x11,0x68,
0x61,0xa3,0x52,2,0x6d,0x2e,0x6e,0x36,0x73,0x10,0x75,0xa3,0x83,0x10,0x62,0x80,
0x10,0x75,0x81,2,0x61,0xa3,0x53,0x62,0x83,0x65,0x12,0x61,0x72,0x62,0x83,0x11,
0x6d,0x61,0xa3,0x8b,0x68,0x60,0x69,0xa2,0x67,0x6a,2,0x61,0x30,0x70,0x44,0x75,
0x11,0x72,0x63,0xa3,0x94,0x11,0x76,0x61,0xa2,0x4e,0x13,0x6e,0x65,0x73,0x65,0xa3,
0x4e,0x11,0x61,0x6e,0xa3,0x69,5,0x6d,0x13,0x6d,0x30,0x72,0x36,0x75,0x11,0x6e,
0x67,0xa3,0x4c,0x11,0x6e,0x67,0xa3,0x4b,0x11,0x6b,0x74,0x8d,0x61,0x3a,0x65,0x70,
0x69,0x11,0x72,0x61,0x48,0x13,0x67,0x61,0x6e,0x61,0x49,0x10,0x6e,0x42,5,0x73,
0xc,0x73,0xa3,0x49,0x74,0xa3,0x4a,0x75,0x12,0x6e,0x6f,0x6f,0x77,0x67,0x28,0x69,
0x43,0x6f,0x77,0x44,0x11,0x75,0x6c,0x45,0x11,0x62,0x72,0x46,0x11,0x65,0x77,0x47,
2,0x6d,0x2e,0x6e,0x4a,0x74,0x11,0x61,0x6c,0x5d,0x1c,0x70,0x65,0x72,0x69,0x61,
0x6c,0x61,0x72,0x61,0x6d,0x61,0x69,0x63,0xa3,0x74,2,0x64,0x66,0x68,0x6a,0x73,
0x1b,0x63,0x72,0x69,0x70,0x74,0x69,0x6f,0x6e,0x61,0x6c,0x70,0x61,1,0x68,0x32,
0x72,0x14,0x74,0x68,0x69,0x61,0x6e,0xa3,0x7d,0x13,0x6c,0x61,0x76,0x69,0xa3,0x7a,
0x10,0x73,0xa3,0x4d,0x15,0x65,0x72,0x69,0x74,0x65,0x64,0x23,0x64,0xb4,0x64,0xa2,
0x5a,0x65,0xa2,0x7b,0x67,4,0x65,0x62,0x6c,0x7a,0x6f,0x8e,0x72,0x9a,0x75,1,
0x6a,0x38,0x72,1,0x6d,0x24,0x75,0x41,0x13,0x75,0x6b,0x68,0x69,0x41,1,0x61,
0x24,0x72,0x3f,0x13,0x72,0x61,0x74,0x69,0x3f,0x10,0x6f,1,0x6b,0xa3,0x48,0x72,
0x38,0x13,0x67,0x69,0x61,0x6e,0x39,0x11,0x61,0x67,0x90,0x15,0x6f,0x6c,0x69,0x74,
0x69,0x63,0x91,0x11,0x74,0x68,0x3a,0x11,0x69,0x63,0x3b,1,0x61,0x32,0x65,1,
0x65,0x24,0x6b,0x3d,0x10,0x6b,0x3d,0x10,0x6e,0xa3,0x89,2,0x65,0x30,0x73,0x56,
0x75,0x11,0x70,0x6c,0xa3,0x87,1,0x73,0x38,0x76,0x10,0x61,0x34,0x15,0x6e,0x61,
0x67,0x61,0x72,0x69,0x35,0x13,0x65,0x72,0x65,0x74,0x33,0x11,0x72,0x74,0x33,2,
0x67,0x3a,0x6c,0x72,0x74,0x11,0x68,0x69,0x36,0x13,0x6f,0x70,0x69,0x63,0x37,0x10,
0x79,2,0x64,0xa3,0x45,0x68,0xa3,0x46,0x70,0xa2,0x47,0x1e,0x74,0x69,0x61,0x6e,
0x68,0x69,0x65,0x72,0x6f,0x67,0x6c,0x79,0x70,0x68,0x73,0xa3,0x47,0x11,0x62,0x61,
0xa3,0x88,0x61,0xa2,0x87,0x62,0xa2,0xb7,0x63,6,0x6f,0x3d,0x6f,0x5a,0x70,0x76,
0x75,0x7a,0x79,1,0x70,0x3e,0x72,2,0x69,0x2a,0x6c,0x31,0x73,0xa3,0x44,0x13,
0x6c,0x6c,0x69,0x63,0x31,0x13,0x72,0x69,0x6f,0x74,0x7f,1,0x6d,0x30,0x70,0x10,
0x74,0x2e,0x11,0x69,0x63,0x2f,0x12,0x6d,0x6f,0x6e,0x21,0x11,0x72,0x74,0x7f,0x16,
0x6e,0x65,0x69,0x66,0x6f,0x72,0x6d,0xa3,0x65,0x61,0x30,0x68,0x7c,0x69,0x11,0x72,
0x74,0xa3,0x43,2,0x6b,0x38,0x6e,0x3c,0x72,0x10,0x69,0xa2,0x68,0x11,0x61,0x6e,
0xa3,0x68,0x10,0x6d,0xa3,0x76,1,0x61,0x24,0x73,0x71,0x1d,0x64,0x69,0x61,0x6e,
0x61,0x62,0x6f,0x72,0x69,0x67,0x69,0x6e,0x61,0x6c,0x71,1,0x61,0x34,0x65,0x10,
0x72,0x2c,0x13,0x6f,0x6b,0x65,0x65,0x2d,0x10,0x6d,0xa3,0x42,2,0x66,0x44,0x72,
0x4a,0x76,1,0x65,0x2a,0x73,0x10,0x74,0xa3,0x75,0x13,0x73,0x74,0x61,0x6e,0xa3,
0x75,0x11,0x61,0x6b,0xa3,0x93,1,0x61,0x3e,0x6d,2,0x65,0x2a,0x69,0xa3,0x74,
0x6e,0x27,0x13,0x6e,0x69,0x61,0x6e,0x27,0x10,0x62,0x24,0x11,0x69,0x63,0x25,5,
0x6f,0x36,0x6f,0x4e,0x72,0x5e,0x75,1,0x67,0x30,0x68,1,0x64,0x79,0x69,0x10,
0x64,0x79,0x10,0x69,0x8e,0x13,0x6e,0x65,0x73,0x65,0x8f,0x11,0x70,0x6f,0x2a,0x13,
0x6d,0x6f,0x66,0x6f,0x2b,0x10,0x61,1,0x68,0x2e,0x69,0x7c,0x12,0x6c,0x6c,0x65,
0x7d,0xa2,0x41,0x11,0x6d,0x69,0xa3,0x41,0x61,0x2e,0x65,0x74,0x6c,0x11,0x69,0x73,
0xa1,3,0x6c,0x3a,0x6d,0x48,0x73,0x54,0x74,1,0x61,0x24,0x6b,0x9f,0x10,0x6b,
0x9f,0x10,0x69,0x9c,0x13,0x6e,0x65,0x73,0x65,0x9d,0x10,0x75,0xa2,0x82,0x10,0x6d,
0xa3,0x82,0x10,0x73,0xa3,0x86,0x11,0x6e,0x67,0x28,0x12,0x61,0x6c,0x69,0x29,9,
0x6e,0x4a,0x6e,0x34,0x6f,0x44,0x73,0x60,0x75,0x94,0x78,0x10,0x78,0x21,0x10,0x75,
0x2a,0x14,0x6d,0x65,0x72,0x69,0x63,0x2b,1,0x6c,0x2c,0x74,0x12,0x68,0x65,0x72,
0x21,0x14,0x65,0x74,0x74,0x65,0x72,0x2d,3,0x63,0x36,0x65,0x46,0x70,0x31,0x74,
0x32,0x12,0x65,0x72,0x6d,0x33,0x3c,0x16,0x6f,0x6e,0x74,0x69,0x6e,0x75,0x65,0x3d,
0x2e,0x10,0x70,0x2f,0x10,0x70,0x34,0x12,0x70,0x65,0x72,0x35,0x61,0x46,0x63,0x52,
0x65,0x64,0x66,0x72,0x6c,2,0x65,0x2d,0x66,0x3b,0x6f,0x28,0x12,0x77,0x65,0x72,
0x29,0x10,0x74,0x22,0x12,0x65,0x72,0x6d,0x23,1,0x6c,0x24,0x72,0x37,0x24,0x12,
0x6f,0x73,0x65,0x25,0x10,0x78,0x38,0x13,0x74,0x65,0x6e,0x64,0x39,0x10,0x6f,0x26,
0x13,0x72,0x6d,0x61,0x74,0x27,9,0x6c,0x4b,0x6c,0x34,0x6d,0x3a,0x6e,0x74,0x6f,
0x9a,0x78,0x10,0x78,0x21,1,0x65,0x23,0x66,0x35,3,0x62,0x37,0x69,0x28,0x6c,
0x29,0x6e,0x2b,0x10,0x64,1,0x6c,0x34,0x6e,0x11,0x75,0x6d,0x2a,0x12,0x6c,0x65,
0x74,0x37,0x14,0x65,0x74,0x74,0x65,0x72,0x29,2,0x65,0x36,0x6c,0x39,0x75,0x2c,
0x14,0x6d,0x65,0x72,0x69,0x63,0x2d,0x14,0x77,0x6c,0x69,0x6e,0x65,0x39,0x13,0x74,
0x68,0x65,0x72,0x21,0x61,0x44,0x63,0x50,0x65,0x52,0x66,0x70,0x6b,0x10,0x61,0x26,
0x15,0x74,0x61,0x6b,0x61,0x6e,0x61,0x27,0x15,0x6c,0x65,0x74,0x74,0x65,0x72,0x23,
0x10,0x72,0x31,0x10,0x78,0x2e,0x13,0x74,0x65,0x6e,0x64,0x32,0x15,0x6e,0x75,0x6d,
0x6c,0x65,0x74,0x2f,0x10,0x6f,0x24,0x13,0x72,0x6d,0x61,0x74,0x25,0xd,0x6e,0xc1,
0x86,0x73,0xa8,0x73,0x4c,0x74,0xa2,0x76,0x75,0xa2,0x83,0x7a,0xd8,0x70,0,2,
0x6c,0xd9,0x20,0,0x70,0xd9,0x40,0,0x73,0xc3,0,0xfe,0xf,0,0,0,
7,0x6f,0x3c,0x6f,0xff,8,0,0,0,0x70,0x3a,0x75,0x6e,0x79,0x13,0x6d,
0x62,0x6f,0x6c,0xff,0xf,0,0,0,0x11,0x61,0x63,1,0x65,0x34,0x69,0x15,
0x6e,0x67,0x6d,0x61,0x72,0x6b,0xa5,0,0x18,0x73,0x65,0x70,0x61,0x72,0x61,0x74,
0x6f,0x72,0xc3,0,0x16,0x72,0x72,0x6f,0x67,0x61,0x74,0x65,0xe1,0,0,0x63,
0xff,2,0,0,0,0x65,0x38,0x6b,0xff,4,0,0,0,0x6d,0xff,1,
0,0,0,0x16,0x70,0x61,0x72,0x61,0x74,0x6f,0x72,0xd9,0x70,0,0x1d,0x69,
0x74,0x6c,0x65,0x63,0x61,0x73,0x65,0x6c,0x65,0x74,0x74,0x65,0x72,0x31,1,0x6e,
0x40,0x70,0x1c,0x70,0x65,0x72,0x63,0x61,0x73,0x65,0x6c,0x65,0x74,0x74,0x65,0x72,
0x25,0x17,0x61,0x73,0x73,0x69,0x67,0x6e,0x65,0x64,0x23,0x6e,0xa2,0x69,0x6f,0xa2,
0x89,0x70,0xfe,0x30,0xf8,0,0,9,0x69,0x33,0x69,0xff,0x10,0,0,0,
0x6f,0xfd,0x80,0,0,0x72,0x54,0x73,0xf9,0,0,0x75,0x12,0x6e,0x63,0x74,
0xfe,0x30,0xf8,0,0,0x15,0x75,0x61,0x74,0x69,0x6f,0x6e,0xff,0x30,0xf8,0,
0,0x17,0x69,0x76,0x61,0x74,0x65,0x75,0x73,0x65,0xdd,0,0,0x61,0x48,0x63,
0xfd,0x40,0,0,0x64,0xe9,0,0,0x65,0xfd,0x20,0,0,0x66,0xff,0x20,
0,0,0,0x1f,0x72,0x61,0x67,0x72,0x61,0x70,0x68,0x73,0x65,0x70,0x61,0x72,
0x61,0x74,0x6f,0x72,0xd9,0x40,0,0xbe,0,3,0x64,0xa7,0,0x6c,0xab,0,
0x6f,0x30,0x75,0x13,0x6d,0x62,0x65,0x72,0xbf,0,0xb2,0,0x1b,0x6e,0x73,0x70,
0x61,0x63,0x69,0x6e,0x67,0x6d,0x61,0x72,0x6b,0xa1,1,0x70,0x92,0x74,0x12,0x68,
0x65,0x72,0xe6,0x80,1,3,0x6c,0x40,0x6e,0x4a,0x70,0x56,0x73,0x14,0x79,0x6d,
0x62,0x6f,0x6c,0xff,8,0,0,0,0x14,0x65,0x74,0x74,0x65,0x72,0x61,0x14,
0x75,0x6d,0x62,0x65,0x72,0xb3,0,0x19,0x75,0x6e,0x63,0x74,0x75,0x61,0x74,0x69,
0x6f,0x6e,0xfd,0x80,0,0,0x1c,0x65,0x6e,0x70,0x75,0x6e,0x63,0x74,0x75,0x61,
0x74,0x69,0x6f,0x6e,0xf9,0,0,0x66,0xc0,0xc4,0x66,0xa2,0x47,0x69,0xa2,0x64,
0x6c,0xa2,0x79,0x6d,0xa4,0xc0,4,0x61,0x6c,0x63,0xa5,0,0x65,0xa3,0x80,0x6e,
0xa1,0x6f,0x15,0x64,0x69,0x66,0x69,0x65,0x72,1,0x6c,0x38,0x73,0x14,0x79,0x6d,
0x62,0x6f,0x6c,0xff,4,0,0,0,0x14,0x65,0x74,0x74,0x65,0x72,0x41,1,
0x72,0x3c,0x74,0x16,0x68,0x73,0x79,0x6d,0x62,0x6f,0x6c,0xff,1,0,0,0,
0x10,0x6b,0xa5,0xc0,1,0x69,0x32,0x6f,0x13,0x72,0x6d,0x61,0x74,0xdb,0,0,
0x1d,0x6e,0x61,0x6c,0x70,0x75,0x6e,0x63,0x74,0x75,0x61,0x74,0x69,0x6f,0x6e,0xff,
0x20,0,0,0,0x10,0x6e,0x1f,0x69,0x74,0x69,0x61,0x6c,0x70,0x75,0x6e,0x63,
0x74,0x75,0x61,0x74,0x69,0x6f,0x6e,0xff,0x10,0,0,0,0x9c,7,0x6d,0x18,
0x6d,0x41,0x6f,0x28,0x74,0x31,0x75,0x25,0x60,0x1c,0x77,0x65,0x72,0x63,0x61,0x73,
0x65,0x6c,0x65,0x74,0x74,0x65,0x72,0x29,0x63,0x3d,0x65,0x28,0x69,0x42,0x6c,0x29,
0x13,0x74,0x74,0x65,0x72,0x9c,0x15,0x6e,0x75,0x6d,0x62,0x65,0x72,0xab,0,0x1a,
0x6e,0x65,0x73,0x65,0x70,0x61,0x72,0x61,0x74,0x6f,0x72,0xd9,0x20,0,0x63,0x46,
0x64,0xa2,0x87,0x65,0x1b,0x6e,0x63,0x6c,0x6f,0x73,0x69,0x6e,0x67,0x6d,0x61,0x72,
0x6b,0xa3,0x80,0xe6,0x80,1,7,0x6e,0x48,0x6e,0x52,0x6f,0x5e,0x73,0xe1,0,
0,0x75,0x1b,0x72,0x72,0x65,0x6e,0x63,0x79,0x73,0x79,0x6d,0x62,0x6f,0x6c,0xff,
2,0,0,0,0x22,0x12,0x74,0x72,0x6c,0xd9,0x80,0,0xdc,0,0,0x10,
0x6e,1,0x6e,0x30,0x74,0x12,0x72,0x6f,0x6c,0xd9,0x80,0,0x1f,0x65,0x63,0x74,
0x6f,0x72,0x70,0x75,0x6e,0x63,0x74,0x75,0x61,0x74,0x69,0x6f,0x6e,0xfd,0x40,0,
0,0x61,0x58,0x63,0xd9,0x80,0,0x66,0xdb,0,0,0x6c,0x1d,0x6f,0x73,0x65,
0x70,0x75,0x6e,0x63,0x74,0x75,0x61,0x74,0x69,0x6f,0x6e,0xfd,0x20,0,0,0x18,
0x73,0x65,0x64,0x6c,0x65,0x74,0x74,0x65,0x72,0x3d,2,0x61,0x32,0x65,0x50,0x69,
0x12,0x67,0x69,0x74,0xa7,0,0x1c,0x73,0x68,0x70,0x75,0x6e,0x63,0x74,0x75,0x61,
0x74,0x69,0x6f,0x6e,0xe9,0,0,0x1a,0x63,0x69,0x6d,0x61,0x6c,0x6e,0x75,0x6d,
0x62,0x65,0x72,0xa7,0
};

const char PropNameData::nameGroups[12387]={
2,'A','l','p','h','a',0,'A','l','p','h','a','b','e','t','i','c',0,
4,'N',0,'N','o',0,'F',0,'F','a','l','s','e',0,4,'Y',0,'Y','e','s',0,'T',0,'T','r','u','e',0,
2,'N','R',0,'N','o','t','_','R','e','o','r','d','e','r','e','d',0,
2,'O','V',0,'O','v','e','r','l','a','y',0,2,'A','T','B','L',0,'A','t','t','a','c','h','e','d','_','B','e','l','o','w',
'_','L','e','f','t',0,2,'A','T','B',0,'A','t','t','a','c','h','e','d','_','B','e','l','o','w',0,
2,'A','T','A',0,'A','t','t','a','c','h','e','d','_','A','b','o','v','e',0,
2,'A','T','A','R',0,'A','t','t','a','c','h','e','d','_','A','b','o','v','e','_','R','i','g','h','t',0,
2,'B','L',0,'B','e','l','o','w','_','L','e','f','t',0,2,'B',0,'B','e','l','o','w',0,
2,'B','R',0,'B','e','l','o','w','_','R','i','g','h','t',0,
2,'L',0,'L','e','f','t',0,2,'R',0,'R','i','g','h','t',0,
2,'A','L',0,'A','b','o','v','e','_','L','e','f','t',0,2,'A',0,'A','b','o','v','e',0,
2,'A','R',0,'A','b','o','v','e','_','R','i','g','h','t',0,
2,'D','B',0,'D','o','u','b','l','e','_','B','e','l','o','w',0,
2,'D','A',0,'D','o','u','b','l','e','_','A','b','o','v','e',0,
2,'I','S',0,'I','o','t','a','_','S','u','b','s','c','r','i','p','t',0,
2,'N','K',0,'N','u','k','t','a',0,2,'K','V',0,'K','a','n','a','_','V','o','i','c','i','n','g',0,
2,'V','R',0,'V','i','r','a','m','a',0,2,'A','H','e','x',0,'A','S','C','I','I','_','H','e','x','_','D','i','g','i','t',
0,2,'B','i','d','i','_','C',0,'B','i','d','i','_','C','o','n','t','r','o','l',0,
2,'B','i','d','i','_','M',0,'B','i','d','i','_','M','i','r','r','o','r','e','d',0,
2,'C','a','s','e','d',0,'C','a','s','e','d',0,2,'C','I',0,'C','a','s','e','_','I','g','n','o','r','a','b','l','e',0,
2,'S','e','n','s','i','t','i','v','e',0,'C','a','s','e','_','S','e','n','s','i','t','i','v','e',0,
2,'C','W','C','F',0,'C','h','a','n','g','e','s','_','W','h','e','n','_','C','a','s','e','f','o','l','d','e','d',0,
2,'C','W','C','M',0,'C','h','a','n','g','e','s','_','W','h','e','n','_','C','a','s','e','m','a','p','p','e','d',0,
2,'C','W','L',0,'C','h','a','n','g','e','s','_','W','h','e','n','_','L','o','w','e','r','c','a','s','e','d',0,
2,'C','W','K','C','F',0,'C','h','a','n','g','e','s','_','W','h','e','n','_','N','F','K','C','_','C','a','s','e','f','o','l',
'd','e','d',0,2,'C','W','T',0,'C','h','a','n','g','e','s','_','W','h','e','n','_','T','i','t','l','e','c','a','s','e','d',
0,2,'C','W','U',0,'C','h','a','n','g','e','s','_','W','h','e','n','_','U','p','p','e','r','c','a','s','e','d',0,
2,'D','a','s','h',0,'D','a','s','h',0,2,'D','I',0,'D','e','f','a','u','l','t','_','I','g','n','o','r','a','b','l','e',
'_','C','o','d','e','_','P','o','i','n','t',0,2,'D','e','p',0,'D','e','p','r','e','c','a','t','e','d',0,
2,'D','i','a',0,'D','i','a','c','r','i','t','i','c',0,2,'E','x','t',0,'E','x','t','e','n','d','e','r',0,
2,'C','o','m','p','_','E','x',0,'F','u','l','l','_','C','o','m','p','o','s','i','t','i','o','n','_','E','x','c','l','u','s',
'i','o','n',0,2,'G','r','_','B','a','s','e',0,'G','r','a','p','h','e','m','e','_','B','a','s','e',0,
2,'G','r','_','E','x','t',0,'G','r','a','p','h','e','m','e','_','E','x','t','e','n','d',0,
2,'G','r','_','L','i','n','k',0,'G','r','a','p','h','e','m','e','_','L','i','n','k',0,
2,'H','e','x',0,'H','e','x','_','D','i','g','i','t',0,2,'H','y','p','h','e','n',0,'H','y','p','h','e','n',0,
2,'I','d','e','o',0,'I','d','e','o','g','r','a','p','h','i','c',0,
2,'I','D','S','B',0,'I','D','S','_','B','i','n','a','r','y','_','O','p','e','r','a','t','o','r',0,
2,'I','D','S','T',0,'I','D','S','_','T','r','i','n','a','r','y','_','O','p','e','r','a','t','o','r',0,
2,'I','D','C',0,'I','D','_','C','o','n','t','i','n','u','e',0,
2,'I','D','S',0,'I','D','_','S','t','a','r','t',0,2,'J','o','i','n','_','C',0,'J','o','i','n','_','C','o','n','t','r',
'o','l',0,2,'L','O','E',0,'L','o','g','i','c','a','l','_','O','r','d','e','r','_','E','x','c','e','p','t','i','o','n',0,
2,'L','o','w','e','r',0,'L','o','w','e','r','c','a','s','e',0,
2,'M','a','t','h',0,'M','a','t','h',0,2,'n','f','c','i','n','e','r','t',0,'N','F','C','_','I','n','e','r','t',0,
2,'n','f','d','i','n','e','r','t',0,'N','F','D','_','I','n','e','r','t',0,
2,'n','f','k','c','i','n','e','r','t',0,'N','F','K','C','_','I','n','e','r','t',0,
2,'n','f','k','d','i','n','e','r','t',0,'N','F','K','D','_','I','n','e','r','t',0,
2,'N','C','h','a','r',0,'N','o','n','c','h','a','r','a','c','t','e','r','_','C','o','d','e','_','P','o','i','n','t',0,
2,'P','a','t','_','S','y','n',0,'P','a','t','t','e','r','n','_','S','y','n','t','a','x',0,
2,'P','a','t','_','W','S',0,'P','a','t','t','e','r','n','_','W','h','i','t','e','_','S','p','a','c','e',0,
2,0,'a','l','n','u','m',0,2,0,'b','l','a','n','k',0,
2,0,'g','r','a','p','h',0,2,0,'p','r','i','n','t',0,
2,0,'x','d','i','g','i','t',0,2,'Q','M','a','r','k',0,'Q','u','o','t','a','t','i','o','n','_','M','a','r','k',0,
2,'R','a','d','i','c','a','l',0,'R','a','d','i','c','a','l',0,
2,'s','e','g','s','t','a','r','t',0,'S','e','g','m','e','n','t','_','S','t','a','r','t','e','r',0,
2,'S','D',0,'S','o','f','t','_','D','o','t','t','e','d',0,
2,'S','T','e','r','m',0,'S','T','e','r','m',0,2,'T','e','r','m',0,'T','e','r','m','i','n','a','l','_','P','u','n','c',
't','u','a','t','i','o','n',0,2,'U','I','d','e','o',0,'U','n','i','f','i','e','d','_','I','d','e','o','g','r','a','p','h',
0,2,'U','p','p','e','r',0,'U','p','p','e','r','c','a','s','e',0,
2,'V','S',0,'V','a','r','i','a','t','i','o','n','_','S','e','l','e','c','t','o','r',0,
3,'W','S','p','a','c','e',0,'W','h','i','t','e','_','S','p','a','c','e',0,'s','p','a','c','e',0,
2,'X','I','D','C',0,'X','I','D','_','C','o','n','t','i','n','u','e',0,
2,'X','I','D','S',0,'X','I','D','_','S','t','a','r','t',0,
2,'b','c',0,'B','i','d','i','_','C','l','a','s','s',0,2,'A','N',0,'A','r','a','b','i','c','_','N','u','m','b','e','r',
0,2,'B',0,'P','a','r','a','g','r','a','p','h','_','S','e','p','a','r','a','t','o','r',0,
2,'B','N',0,'B','o','u','n','d','a','r','y','_','N','e','u','t','r','a','l',0,
2,'C','S',0,'C','o','m','m','o','n','_','S','e','p','a','r','a','t','o','r',0,
2,'N','S','M',0,'N','o','n','s','p','a','c','i','n','g','_','M','a','r','k',0,
2,'E','N',0,'E','u','r','o','p','e','a','n','_','N','u','m','b','e','r',0,
2,'E','S',0,'E','u','r','o','p','e','a','n','_','S','e','p','a','r','a','t','o','r',0,
2,'E','T',0,'E','u','r','o','p','e','a','n','_','T','e','r','m','i','n','a','t','o','r',0,
2,'L',0,'L','e','f','t','_','T','o','_','R','i','g','h','t',0,
2,'L','R','E',0,'L','e','f','t','_','T','o','_','R','i','g','h','t','_','E','m','b','e','d','d','i','n','g',0,
2,'L','R','O',0,'L','e','f','t','_','T','o','_','R','i','g','h','t','_','O','v','e','r','r','i','d','e',0,
2,'O','N',0,'O','t','h','e','r','_','N','e','u','t','r','a','l',0,
2,'P','D','F',0,'P','o','p','_','D','i','r','e','c','t','i','o','n','a','l','_','F','o','r','m','a','t',0,
2,'R',0,'R','i','g','h','t','_','T','o','_','L','e','f','t',0,
2,'A','L',0,'A','r','a','b','i','c','_','L','e','t','t','e','r',0,
2,'R','L','E',0,'R','i','g','h','t','_','T','o','_','L','e','f','t','_','E','m','b','e','d','d','i','n','g',0,
2,'R','L','O',0,'R','i','g','h','t','_','T','o','_','L','e','f','t','_','O','v','e','r','r','i','d','e',0,
2,'S',0,'S','e','g','m','e','n','t','_','S','e','p','a','r','a','t','o','r',0,
2,'W','S',0,'W','h','i','t','e','_','S','p','a','c','e',0,
2,'b','l','k',0,'B','l','o','c','k',0,2,0,'A','e','g','e','a','n','_','N','u','m','b','e','r','s',0,
2,0,'A','l','c','h','e','m','i','c','a','l','_','S','y','m','b','o','l','s',0,
2,0,'A','l','p','h','a','b','e','t','i','c','_','P','r','e','s','e','n','t','a','t','i','o','n','_','F','o','r','m','s',0,
2,0,'A','n','c','i','e','n','t','_','G','r','e','e','k','_','M','u','s','i','c','a','l','_','N','o','t','a','t','i','o','n',
0,2,0,'A','n','c','i','e','n','t','_','G','r','e','e','k','_','N','u','m','b','e','r','s',0,
2,0,'A','n','c','i','e','n','t','_','S','y','m','b','o','l','s',0,
2,0,'A','r','a','b','i','c',0,3,0,'A','r','a','b','i','c','_','P','r','e','s','e','n','t','a','t','i','o','n','_','F',
'o','r','m','s','_','A',0,'A','r','a','b','i','c','_','P','r','e','s','e','n','t','a','t','i','o','n','_','F','o','r','m','s',
'-','A',0,2,0,'A','r','a','b','i','c','_','P','r','e','s','e','n','t','a','t','i','o','n','_','F','o','r','m','s','_','B',
0,2,0,'A','r','a','b','i','c','_','S','u','p','p','l','e','m','e','n','t',0,
2,0,'A','r','m','e','n','i','a','n',0,2,0,'A','r','r','o','w','s',0,
2,0,'A','v','e','s','t','a','n',0,2,0,'B','a','l','i','n','e','s','e',0,
2,0,'B','a','m','u','m',0,2,0,'B','a','m','u','m','_','S','u','p','p','l','e','m','e','n','t',0,
3,0,'B','a','s','i','c','_','L','a','t','i','n',0,'A','S','C','I','I',0,
2,0,'B','a','t','a','k',0,2,0,'B','e','n','g','a','l','i',0,
2,0,'B','l','o','c','k','_','E','l','e','m','e','n','t','s',0,
2,0,'B','o','p','o','m','o','f','o',0,2,0,'B','o','p','o','m','o','f','o','_','E','x','t','e','n','d','e','d',0,
2,0,'B','o','x','_','D','r','a','w','i','n','g',0,2,0,'B','r','a','h','m','i',0,
2,0,'B','r','a','i','l','l','e','_','P','a','t','t','e','r','n','s',0,
2,0,'B','u','g','i','n','e','s','e',0,2,0,'B','u','h','i','d',0,
2,0,'B','y','z','a','n','t','i','n','e','_','M','u','s','i','c','a','l','_','S','y','m','b','o','l','s',0,
2,0,'C','a','r','i','a','n',0,2,0,'C','h','a','m',0,
2,0,'C','h','e','r','o','k','e','e',0,2,0,'C','J','K','_','C','o','m','p','a','t','i','b','i','l','i','t','y',0,
2,0,'C','J','K','_','C','o','m','p','a','t','i','b','i','l','i','t','y','_','F','o','r','m','s',0,
2,0,'C','J','K','_','C','o','m','p','a','t','i','b','i','l','i','t','y','_','I','d','e','o','g','r','a','p','h','s',0,
2,0,'C','J','K','_','C','o','m','p','a','t','i','b','i','l','i','t','y','_','I','d','e','o','g','r','a','p','h','s','_','S',
'u','p','p','l','e','m','e','n','t',0,2,0,'C','J','K','_','R','a','d','i','c','a','l','s','_','S','u','p','p','l','e','m',
'e','n','t',0,2,0,'C','J','K','_','S','t','r','o','k','e','s',0,
2,0,'C','J','K','_','S','y','m','b','o','l','s','_','A','n','d','_','P','u','n','c','t','u','a','t','i','o','n',0,
2,0,'C','J','K','_','U','n','i','f','i','e','d','_','I','d','e','o','g','r','a','p','h','s',0,
2,0,'C','J','K','_','U','n','i','f','i','e','d','_','I','d','e','o','g','r','a','p','h','s','_','E','x','t','e','n','s','i',
'o','n','_','A',0,2,0,'C','J','K','_','U','n','i','f','i','e','d','_','I','d','e','o','g','r','a','p','h','s','_','E','x',
't','e','n','s','i','o','n','_','B',0,2,0,'C','J','K','_','U','n','i','f','i','e','d','_','I','d','e','o','g','r','a','p',
'h','s','_','E','x','t','e','n','s','i','o','n','_','C',0,2,0,'C','J','K','_','U','n','i','f','i','e','d','_','I','d','e',
'o','g','r','a','p','h','s','_','E','x','t','e','n','s','i','o','n','_','D',0,
2,0,'C','o','m','b','i','n','i','n','g','_','D','i','a','c','r','i','t','i','c','a','l','_','M','a','r','k','s',0,
2,0,'C','o','m','b','i','n','i','n','g','_','D','i','a','c','r','i','t','i','c','a','l','_','M','a','r','k','s','_','S','u',
'p','p','l','e','m','e','n','t',0,2,0,'C','o','m','b','i','n','i','n','g','_','H','a','l','f','_','M','a','r','k','s',0,
3,0,'C','o','m','b','i','n','i','n','g','_','D','i','a','c','r','i','t','i','c','a','l','_','M','a','r','k','s','_','F','o',
'r','_','S','y','m','b','o','l','s',0,'C','o','m','b','i','n','i','n','g','_','M','a','r','k','s','_','F','o','r','_','S','y',
'm','b','o','l','s',0,2,0,'C','o','m','m','o','n','_','I','n','d','i','c','_','N','u','m','b','e','r','_','F','o','r','m',
's',0,2,0,'C','o','n','t','r','o','l','_','P','i','c','t','u','r','e','s',0,
2,0,'C','o','p','t','i','c',0,2,0,'C','o','u','n','t','i','n','g','_','R','o','d','_','N','u','m','e','r','a','l','s',
0,2,0,'C','u','n','e','i','f','o','r','m',0,2,0,'C','u','n','e','i','f','o','r','m','_','N','u','m','b','e','r','s',
'_','A','n','d','_','P','u','n','c','t','u','a','t','i','o','n',0,
2,0,'C','u','r','r','e','n','c','y','_','S','y','m','b','o','l','s',0,
2,0,'C','y','p','r','i','o','t','_','S','y','l','l','a','b','a','r','y',0,
2,0,'C','y','r','i','l','l','i','c',0,2,0,'C','y','r','i','l','l','i','c','_','E','x','t','e','n','d','e','d','_','A',
0,2,0,'C','y','r','i','l','l','i','c','_','E','x','t','e','n','d','e','d','_','B',0,
3,0,'C','y','r','i','l','l','i','c','_','S','u','p','p','l','e','m','e','n','t',0,'C','y','r','i','l','l','i','c','_','S',
'u','p','p','l','e','m','e','n','t','a','r','y',0,2,0,'D','e','s','e','r','e','t',0,
2,0,'D','e','v','a','n','a','g','a','r','i',0,2,0,'D','e','v','a','n','a','g','a','r','i','_','E','x','t','e','n','d',
'e','d',0,2,0,'D','i','n','g','b','a','t','s',0,2,0,'D','o','m','i','n','o','_','T','i','l','e','s',0,
2,0,'E','g','y','p','t','i','a','n','_','H','i','e','r','o','g','l','y','p','h','s',0,
2,0,'E','m','o','t','i','c','o','n','s',0,2,0,'E','n','c','l','o','s','e','d','_','A','l','p','h','a','n','u','m','e',
'r','i','c','s',0,2,0,'E','n','c','l','o','s','e','d','_','A','l','p','h','a','n','u','m','e','r','i','c','_','S','u','p',
'p','l','e','m','e','n','t',0,2,0,'E','n','c','l','o','s','e','d','_','C','J','K','_','L','e','t','t','e','r','s','_','A',
'n','d','_','M','o','n','t','h','s',0,2,0,'E','n','c','l','o','s','e','d','_','I','d','e','o','g','r','a','p','h','i','c',
'_','S','u','p','p','l','e','m','e','n','t',0,2,0,'E','t','h','i','o','p','i','c',0,
2,0,'E','t','h','i','o','p','i','c','_','E','x','t','e','n','d','e','d',0,
2,0,'E','t','h','i','o','p','i','c','_','E','x','t','e','n','d','e','d','_','A',0,
2,0,'E','t','h','i','o','p','i','c','_','S','u','p','p','l','e','m','e','n','t',0,
2,0,'G','e','n','e','r','a','l','_','P','u','n','c','t','u','a','t','i','o','n',0,
2,0,'G','e','o','m','e','t','r','i','c','_','S','h','a','p','e','s',0,
2,0,'G','e','o','r','g','i','a','n',0,2,0,'G','e','o','r','g','i','a','n','_','S','u','p','p','l','e','m','e','n','t',
0,2,0,'G','l','a','g','o','l','i','t','i','c',0,2,0,'G','o','t','h','i','c',0,
3,0,'G','r','e','e','k','_','A','n','d','_','C','o','p','t','i','c',0,'G','r','e','e','k',0,
2,0,'G','r','e','e','k','_','E','x','t','e','n','d','e','d',0,
2,0,'G','u','j','a','r','a','t','i',0,2,0,'G','u','r','m','u','k','h','i',0,
2,0,'H','a','l','f','w','i','d','t','h','_','A','n','d','_','F','u','l','l','w','i','d','t','h','_','F','o','r','m','s',0,
2,0,'H','a','n','g','u','l','_','C','o','m','p','a','t','i','b','i','l','i','t','y','_','J','a','m','o',0,
2,0,'H','a','n','g','u','l','_','J','a','m','o',0,2,0,'H','a','n','g','u','l','_','J','a','m','o','_','E','x','t','e',
'n','d','e','d','_','A',0,2,0,'H','a','n','g','u','l','_','J','a','m','o','_','E','x','t','e','n','d','e','d','_','B',0,
2,0,'H','a','n','g','u','l','_','S','y','l','l','a','b','l','e','s',0,
2,0,'H','a','n','u','n','o','o',0,2,0,'H','e','b','r','e','w',0,
2,0,'H','i','g','h','_','P','r','i','v','a','t','e','_','U','s','e','_','S','u','r','r','o','g','a','t','e','s',0,
2,0,'H','i','g','h','_','S','u','r','r','o','g','a','t','e','s',0,
2,0,'H','i','r','a','g','a','n','a',0,2,0,'I','d','e','o','g','r','a','p','h','i','c','_','D','e','s','c','r','i','p',
't','i','o','n','_','C','h','a','r','a','c','t','e','r','s',0,
2,0,'I','m','p','e','r','i','a','l','_','A','r','a','m','a','i','c',0,
2,0,'I','n','s','c','r','i','p','t','i','o','n','a','l','_','P','a','h','l','a','v','i',0,
2,0,'I','n','s','c','r','i','p','t','i','o','n','a','l','_','P','a','r','t','h','i','a','n',0,
2,0,'I','P','A','_','E','x','t','e','n','s','i','o','n','s',0,
2,0,'J','a','v','a','n','e','s','e',0,2,0,'K','a','i','t','h','i',0,
2,0,'K','a','n','a','_','S','u','p','p','l','e','m','e','n','t',0,
2,0,'K','a','n','b','u','n',0,2,0,'K','a','n','g','x','i','_','R','a','d','i','c','a','l','s',0,
2,0,'K','a','n','n','a','d','a',0,2,0,'K','a','t','a','k','a','n','a',0,
2,0,'K','a','t','a','k','a','n','a','_','P','h','o','n','e','t','i','c','_','E','x','t','e','n','s','i','o','n','s',0,
2,0,'K','a','y','a','h','_','L','i',0,2,0,'K','h','a','r','o','s','h','t','h','i',0,
2,0,'K','h','m','e','r',0,2,0,'K','h','m','e','r','_','S','y','m','b','o','l','s',0,
2,0,'L','a','o',0,3,0,'L','a','t','i','n','_','1','_','S','u','p','p','l','e','m','e','n','t',0,
'L','a','t','i','n','_','1',0,2,0,'L','a','t','i','n','_','E','x','t','e','n','d','e','d','_','A',0,
2,0,'L','a','t','i','n','_','E','x','t','e','n','d','e','d','_','A','d','d','i','t','i','o','n','a','l',0,
2,0,'L','a','t','i','n','_','E','x','t','e','n','d','e','d','_','B',0,
2,0,'L','a','t','i','n','_','E','x','t','e','n','d','e','d','_','C',0,
2,0,'L','a','t','i','n','_','E','x','t','e','n','d','e','d','_','D',0,
2,0,'L','e','p','c','h','a',0,2,0,'L','e','t','t','e','r','l','i','k','e','_','S','y','m','b','o','l','s',0,
2,0,'L','i','m','b','u',0,2,0,'L','i','n','e','a','r','_','B','_','I','d','e','o','g','r','a','m','s',0,
2,0,'L','i','n','e','a','r','_','B','_','S','y','l','l','a','b','a','r','y',0,
2,0,'L','i','s','u',0,2,0,'L','o','w','_','S','u','r','r','o','g','a','t','e','s',0,
2,0,'L','y','c','i','a','n',0,2,0,'L','y','d','i','a','n',0,
2,0,'M','a','h','j','o','n','g','_','T','i','l','e','s',0,
2,0,'M','a','l','a','y','a','l','a','m',0,2,0,'M','a','n','d','a','i','c',0,
2,0,'M','a','t','h','e','m','a','t','i','c','a','l','_','A','l','p','h','a','n','u','m','e','r','i','c','_','S','y','m','b',
'o','l','s',0,2,0,'M','a','t','h','e','m','a','t','i','c','a','l','_','O','p','e','r','a','t','o','r','s',0,
2,0,'M','e','e','t','e','i','_','M','a','y','e','k',0,2,0,'M','i','s','c','e','l','l','a','n','e','o','u','s','_','M',
'a','t','h','e','m','a','t','i','c','a','l','_','S','y','m','b','o','l','s','_','A',0,
2,0,'M','i','s','c','e','l','l','a','n','e','o','u','s','_','M','a','t','h','e','m','a','t','i','c','a','l','_','S','y','m',
'b','o','l','s','_','B',0,2,0,'M','i','s','c','e','l','l','a','n','e','o','u','s','_','S','y','m','b','o','l','s',0,
2,0,'M','i','s','c','e','l','l','a','n','e','o','u','s','_','S','y','m','b','o','l','s','_','A','n','d','_','A','r','r','o',
'w','s',0,2,0,'M','i','s','c','e','l','l','a','n','e','o','u','s','_','S','y','m','b','o','l','s','_','A','n','d','_','P',
'i','c','t','o','g','r','a','p','h','s',0,2,0,'M','i','s','c','e','l','l','a','n','e','o','u','s','_','T','e','c','h','n',
'i','c','a','l',0,2,0,'M','o','d','i','f','i','e','r','_','T','o','n','e','_','L','e','t','t','e','r','s',0,
2,0,'M','o','n','g','o','l','i','a','n',0,2,0,'M','u','s','i','c','a','l','_','S','y','m','b','o','l','s',0,
2,0,'M','y','a','n','m','a','r',0,2,0,'M','y','a','n','m','a','r','_','E','x','t','e','n','d','e','d','_','A',0,
2,0,'N','e','w','_','T','a','i','_','L','u','e',0,2,0,'N','K','o',0,
2,0,'N','o','_','B','l','o','c','k',0,2,0,'N','u','m','b','e','r','_','F','o','r','m','s',0,
2,0,'O','g','h','a','m',0,2,0,'O','l','d','_','I','t','a','l','i','c',0,
2,0,'O','l','d','_','P','e','r','s','i','a','n',0,2,0,'O','l','d','_','S','o','u','t','h','_','A','r','a','b','i','a',
'n',0,2,0,'O','l','d','_','T','u','r','k','i','c',0,2,0,'O','l','_','C','h','i','k','i',0,
2,0,'O','p','t','i','c','a','l','_','C','h','a','r','a','c','t','e','r','_','R','e','c','o','g','n','i','t','i','o','n',0,
2,0,'O','r','i','y','a',0,2,0,'O','s','m','a','n','y','a',0,
2,0,'P','h','a','g','s','_','P','a',0,2,0,'P','h','a','i','s','t','o','s','_','D','i','s','c',0,
2,0,'P','h','o','e','n','i','c','i','a','n',0,2,0,'P','h','o','n','e','t','i','c','_','E','x','t','e','n','s','i','o',
'n','s',0,2,0,'P','h','o','n','e','t','i','c','_','E','x','t','e','n','s','i','o','n','s','_','S','u','p','p','l','e','m',
'e','n','t',0,2,0,'P','l','a','y','i','n','g','_','C','a','r','d','s',0,
3,0,'P','r','i','v','a','t','e','_','U','s','e','_','A','r','e','a',0,'P','r','i','v','a','t','e','_','U','s','e',0,
2,0,'R','e','j','a','n','g',0,2,0,'R','u','m','i','_','N','u','m','e','r','a','l','_','S','y','m','b','o','l','s',0,
2,0,'R','u','n','i','c',0,2,0,'S','a','m','a','r','i','t','a','n',0,
2,0,'S','a','u','r','a','s','h','t','r','a',0,2,0,'S','h','a','v','i','a','n',0,
2,0,'S','i','n','h','a','l','a',0,2,0,'S','m','a','l','l','_','F','o','r','m','_','V','a','r','i','a','n','t','s',0,
2,0,'S','p','a','c','i','n','g','_','M','o','d','i','f','i','e','r','_','L','e','t','t','e','r','s',0,
2,0,'S','p','e','c','i','a','l','s',0,2,0,'S','u','n','d','a','n','e','s','e',0,
2,0,'S','u','p','e','r','s','c','r','i','p','t','s','_','A','n','d','_','S','u','b','s','c','r','i','p','t','s',0,
2,0,'S','u','p','p','l','e','m','e','n','t','a','l','_','A','r','r','o','w','s','_','A',0,
2,0,'S','u','p','p','l','e','m','e','n','t','a','l','_','A','r','r','o','w','s','_','B',0,
2,0,'S','u','p','p','l','e','m','e','n','t','a','l','_','M','a','t','h','e','m','a','t','i','c','a','l','_','O','p','e','r',
'a','t','o','r','s',0,2,0,'S','u','p','p','l','e','m','e','n','t','a','l','_','P','u','n','c','t','u','a','t','i','o','n',
0,2,0,'S','u','p','p','l','e','m','e','n','t','a','r','y','_','P','r','i','v','a','t','e','_','U','s','e','_','A','r','e',
'a','_','A',0,2,0,'S','u','p','p','l','e','m','e','n','t','a','r','y','_','P','r','i','v','a','t','e','_','U','s','e','_',
'A','r','e','a','_','B',0,2,0,'S','y','l','o','t','i','_','N','a','g','r','i',0,
2,0,'S','y','r','i','a','c',0,2,0,'T','a','g','a','l','o','g',0,
2,0,'T','a','g','b','a','n','w','a',0,2,0,'T','a','g','s',0,
2,0,'T','a','i','_','L','e',0,2,0,'T','a','i','_','T','h','a','m',0,
2,0,'T','a','i','_','V','i','e','t',0,2,0,'T','a','i','_','X','u','a','n','_','J','i','n','g','_','S','y','m','b','o',
'l','s',0,2,0,'T','a','m','i','l',0,2,0,'T','e','l','u','g','u',0,
2,0,'T','h','a','a','n','a',0,2,0,'T','h','a','i',0,
2,0,'T','i','b','e','t','a','n',0,2,0,'T','i','f','i','n','a','g','h',0,
2,0,'T','r','a','n','s','p','o','r','t','_','A','n','d','_','M','a','p','_','S','y','m','b','o','l','s',0,
2,0,'U','g','a','r','i','t','i','c',0,3,0,'U','n','i','f','i','e','d','_','C','a','n','a','d','i','a','n','_','A','b',
'o','r','i','g','i','n','a','l','_','S','y','l','l','a','b','i','c','s',0,'C','a','n','a','d','i','a','n','_','S','y','l','l',
'a','b','i','c','s',0,2,0,'U','n','i','f','i','e','d','_','C','a','n','a','d','i','a','n','_','A','b','o','r','i','g','i',
'n','a','l','_','S','y','l','l','a','b','i','c','s','_','E','x','t','e','n','d','e','d',0,
2,0,'V','a','i',0,2,0,'V','a','r','i','a','t','i','o','n','_','S','e','l','e','c','t','o','r','s',0,
2,0,'V','a','r','i','a','t','i','o','n','_','S','e','l','e','c','t','o','r','s','_','S','u','p','p','l','e','m','e','n','t',
0,2,0,'V','e','d','i','c','_','E','x','t','e','n','s','i','o','n','s',0,
2,0,'V','e','r','t','i','c','a','l','_','F','o','r','m','s',0,
2,0,'Y','i','j','i','n','g','_','H','e','x','a','g','r','a','m','_','S','y','m','b','o','l','s',0,
2,0,'Y','i','_','R','a','d','i','c','a','l','s',0,2,0,'Y','i','_','S','y','l','l','a','b','l','e','s',0,
2,'c','c','c',0,'C','a','n','o','n','i','c','a','l','_','C','o','m','b','i','n','i','n','g','_','C','l','a','s','s',0,
2,'d','t',0,'D','e','c','o','m','p','o','s','i','t','i','o','n','_','T','y','p','e',0,
3,'C','a','n',0,'C','a','n','o','n','i','c','a','l',0,'c','a','n',0,
3,'E','n','c',0,'C','i','r','c','l','e',0,'e','n','c',0,
3,'C','o','m',0,'C','o','m','p','a','t',0,'c','o','m',0,
3,'F','i','n',0,'F','i','n','a','l',0,'f','i','n',0,2,'F','o','n','t',0,'f','o','n','t',0,
3,'F','r','a',0,'F','r','a','c','t','i','o','n',0,'f','r','a',0,
3,'I','n','i','t',0,'I','n','i','t','i','a','l',0,'i','n','i','t',0,
3,'I','s','o',0,'I','s','o','l','a','t','e','d',0,'i','s','o',0,
3,'M','e','d',0,'M','e','d','i','a','l',0,'m','e','d',0,
3,'N','a','r',0,'N','a','r','r','o','w',0,'n','a','r',0,
3,'N','b',0,'N','o','b','r','e','a','k',0,'n','b',0,2,'N','o','n','e',0,'n','o','n','e',0,
3,'S','m','l',0,'S','m','a','l','l',0,'s','m','l',0,3,'S','q','r',0,'S','q','u','a','r','e',0,
's','q','r',0,2,'S','u','b',0,'s','u','b',0,3,'S','u','p',0,'S','u','p','e','r',0,
's','u','p',0,3,'V','e','r','t',0,'V','e','r','t','i','c','a','l',0,'v','e','r','t',0,
2,'W','i','d','e',0,'w','i','d','e',0,2,'e','a',0,'E','a','s','t','_','A','s','i','a','n','_','W','i','d','t','h',0,
2,'A',0,'A','m','b','i','g','u','o','u','s',0,2,'F',0,'F','u','l','l','w','i','d','t','h',0,
2,'H',0,'H','a','l','f','w','i','d','t','h',0,2,'N','a',0,'N','a','r','r','o','w',0,
2,'N',0,'N','e','u','t','r','a','l',0,2,'W',0,'W','i','d','e',0,
2,'g','c',0,'G','e','n','e','r','a','l','_','C','a','t','e','g','o','r','y',0,
2,'M','c',0,'S','p','a','c','i','n','g','_','M','a','r','k',0,
2,'P','c',0,'C','o','n','n','e','c','t','o','r','_','P','u','n','c','t','u','a','t','i','o','n',0,
3,'C','c',0,'C','o','n','t','r','o','l',0,'c','n','t','r','l',0,
2,'S','c',0,'C','u','r','r','e','n','c','y','_','S','y','m','b','o','l',0,
2,'P','d',0,'D','a','s','h','_','P','u','n','c','t','u','a','t','i','o','n',0,
3,'N','d',0,'D','e','c','i','m','a','l','_','N','u','m','b','e','r',0,'d','i','g','i','t',0,
2,'M','e',0,'E','n','c','l','o','s','i','n','g','_','M','a','r','k',0,
2,'P','e',0,'C','l','o','s','e','_','P','u','n','c','t','u','a','t','i','o','n',0,
2,'P','f',0,'F','i','n','a','l','_','P','u','n','c','t','u','a','t','i','o','n',0,
2,'C','f',0,'F','o','r','m','a','t',0,2,'C','n',0,'U','n','a','s','s','i','g','n','e','d',0,
2,'P','i',0,'I','n','i','t','i','a','l','_','P','u','n','c','t','u','a','t','i','o','n',0,
2,'N','l',0,'L','e','t','t','e','r','_','N','u','m','b','e','r',0,
2,'Z','l',0,'L','i','n','e','_','S','e','p','a','r','a','t','o','r',0,
2,'L','l',0,'L','o','w','e','r','c','a','s','e','_','L','e','t','t','e','r',0,
2,'S','m',0,'M','a','t','h','_','S','y','m','b','o','l',0,
2,'L','m',0,'M','o','d','i','f','i','e','r','_','L','e','t','t','e','r',0,
2,'S','k',0,'M','o','d','i','f','i','e','r','_','S','y','m','b','o','l',0,
2,'M','n',0,'N','o','n','s','p','a','c','i','n','g','_','M','a','r','k',0,
2,'L','o',0,'O','t','h','e','r','_','L','e','t','t','e','r',0,
2,'N','o',0,'O','t','h','e','r','_','N','u','m','b','e','r',0,
2,'P','o',0,'O','t','h','e','r','_','P','u','n','c','t','u','a','t','i','o','n',0,
2,'S','o',0,'O','t','h','e','r','_','S','y','m','b','o','l',0,
2,'Z','p',0,'P','a','r','a','g','r','a','p','h','_','S','e','p','a','r','a','t','o','r',0,
2,'C','o',0,'P','r','i','v','a','t','e','_','U','s','e',0,
2,'Z','s',0,'S','p','a','c','e','_','S','e','p','a','r','a','t','o','r',0,
2,'P','s',0,'O','p','e','n','_','P','u','n','c','t','u','a','t','i','o','n',0,
2,'C','s',0,'S','u','r','r','o','g','a','t','e',0,2,'L','t',0,'T','i','t','l','e','c','a','s','e','_','L','e','t','t',
'e','r',0,2,'L','u',0,'U','p','p','e','r','c','a','s','e','_','L','e','t','t','e','r',0,
2,'G','C','B',0,'G','r','a','p','h','e','m','e','_','C','l','u','s','t','e','r','_','B','r','e','a','k',0,
2,'C','N',0,'C','o','n','t','r','o','l',0,2,'C','R',0,'C','R',0,
2,'E','X',0,'E','x','t','e','n','d',0,2,'L',0,'L',0,
2,'L','F',0,'L','F',0,2,'L','V',0,'L','V',0,2,'L','V','T',0,'L','V','T',0,
2,'X','X',0,'O','t','h','e','r',0,2,'P','P',0,'P','r','e','p','e','n','d',0,
2,'S','M',0,'S','p','a','c','i','n','g','M','a','r','k',0,
2,'T',0,'T',0,2,'V',0,'V',0,2,'h','s','t',0,'H','a','n','g','u','l','_','S','y','l','l','a','b','l','e','_','T',
'y','p','e',0,2,'L',0,'L','e','a','d','i','n','g','_','J','a','m','o',0,
2,'L','V','T',0,'L','V','T','_','S','y','l','l','a','b','l','e',0,
2,'L','V',0,'L','V','_','S','y','l','l','a','b','l','e',0,
2,'N','A',0,'N','o','t','_','A','p','p','l','i','c','a','b','l','e',0,
2,'T',0,'T','r','a','i','l','i','n','g','_','J','a','m','o',0,
2,'V',0,'V','o','w','e','l','_','J','a','m','o',0,2,'j','g',0,'J','o','i','n','i','n','g','_','G','r','o','u','p',0,
2,0,'A','i','n',0,2,0,'A','l','a','p','h',0,2,0,'A','l','e','f',0,
2,0,'B','e','h',0,2,0,'B','e','t','h',0,2,0,'B','u','r','u','s','h','a','s','k','i','_','Y','e','h','_','B','a',
'r','r','e','e',0,2,0,'D','a','l',0,2,0,'D','a','l','a','t','h','_','R','i','s','h',0,
2,0,'E',0,2,0,'F','a','r','s','i','_','Y','e','h',0,
2,0,'F','e',0,2,0,'F','e','h',0,2,0,'F','i','n','a','l','_','S','e','m','k','a','t','h',0,
2,0,'G','a','f',0,2,0,'G','a','m','a','l',0,2,0,'H','a','h',0,
2,0,'H','e',0,2,0,'H','e','h',0,2,0,'H','e','h','_','G','o','a','l',0,
2,0,'H','e','t','h',0,2,0,'K','a','f',0,2,0,'K','a','p','h',0,
2,0,'K','h','a','p','h',0,2,0,'K','n','o','t','t','e','d','_','H','e','h',0,
2,0,'L','a','m',0,2,0,'L','a','m','a','d','h',0,2,0,'M','e','e','m',0,
2,0,'M','i','m',0,2,0,'N','o','o','n',0,2,0,'N','o','_','J','o','i','n','i','n','g','_','G','r','o','u','p',0,
2,0,'N','u','n',0,2,0,'N','y','a',0,2,0,'P','e',0,
2,0,'Q','a','f',0,2,0,'Q','a','p','h',0,2,0,'R','e','h',0,
2,0,'R','e','v','e','r','s','e','d','_','P','e',0,2,0,'S','a','d',0,
2,0,'S','a','d','h','e',0,2,0,'S','e','e','n',0,2,0,'S','e','m','k','a','t','h',0,
2,0,'S','h','i','n',0,2,0,'S','w','a','s','h','_','K','a','f',0,
2,0,'S','y','r','i','a','c','_','W','a','w',0,2,0,'T','a','h',0,
2,0,'T','a','w',0,2,0,'T','e','h','_','M','a','r','b','u','t','a',0,
3,0,'T','e','h','_','M','a','r','b','u','t','a','_','G','o','a','l',0,'H','a','m','z','a','_','O','n','_','H','e','h','_',
'G','o','a','l',0,2,0,'T','e','t','h',0,2,0,'W','a','w',0,
2,0,'Y','e','h',0,2,0,'Y','e','h','_','B','a','r','r','e','e',0,
2,0,'Y','e','h','_','W','i','t','h','_','T','a','i','l',0,
2,0,'Y','u','d','h',0,2,0,'Y','u','d','h','_','H','e',0,
2,0,'Z','a','i','n',0,2,0,'Z','h','a','i','n',0,2,'j','t',0,'J','o','i','n','i','n','g','_','T','y','p','e',0,
2,'D',0,'D','u','a','l','_','J','o','i','n','i','n','g',0,
2,'C',0,'J','o','i','n','_','C','a','u','s','i','n','g',0,
2,'L',0,'L','e','f','t','_','J','o','i','n','i','n','g',0,
2,'U',0,'N','o','n','_','J','o','i','n','i','n','g',0,2,'R',0,'R','i','g','h','t','_','J','o','i','n','i','n','g',0,
2,'T',0,'T','r','a','n','s','p','a','r','e','n','t',0,2,'l','c','c','c',0,'L','e','a','d','_','C','a','n','o','n','i',
'c','a','l','_','C','o','m','b','i','n','i','n','g','_','C','l','a','s','s',0,
2,'l','b',0,'L','i','n','e','_','B','r','e','a','k',0,2,'A','L',0,'A','l','p','h','a','b','e','t','i','c',0,
2,'A','I',0,'A','m','b','i','g','u','o','u','s',0,2,'B','A',0,'B','r','e','a','k','_','A','f','t','e','r',0,
2,'B','B',0,'B','r','e','a','k','_','B','e','f','o','r','e',0,
2,'B','2',0,'B','r','e','a','k','_','B','o','t','h',0,2,'S','Y',0,'B','r','e','a','k','_','S','y','m','b','o','l','s',
0,2,'C','R',0,'C','a','r','r','i','a','g','e','_','R','e','t','u','r','n',0,
2,'C','P',0,'C','l','o','s','e','_','P','a','r','e','n','t','h','e','s','i','s',0,
2,'C','L',0,'C','l','o','s','e','_','P','u','n','c','t','u','a','t','i','o','n',0,
2,'C','M',0,'C','o','m','b','i','n','i','n','g','_','M','a','r','k',0,
2,'S','A',0,'C','o','m','p','l','e','x','_','C','o','n','t','e','x','t',0,
2,'C','B',0,'C','o','n','t','i','n','g','e','n','t','_','B','r','e','a','k',0,
2,'E','X',0,'E','x','c','l','a','m','a','t','i','o','n',0,
2,'G','L',0,'G','l','u','e',0,2,'H','2',0,'H','2',0,
2,'H','3',0,'H','3',0,2,'H','Y',0,'H','y','p','h','e','n',0,
2,'I','D',0,'I','d','e','o','g','r','a','p','h','i','c',0,
2,'I','S',0,'I','n','f','i','x','_','N','u','m','e','r','i','c',0,
3,'I','N',0,'I','n','s','e','p','a','r','a','b','l','e',0,'I','n','s','e','p','e','r','a','b','l','e',0,
2,'J','L',0,'J','L',0,2,'J','T',0,'J','T',0,2,'J','V',0,'J','V',0,
2,'L','F',0,'L','i','n','e','_','F','e','e','d',0,2,'B','K',0,'M','a','n','d','a','t','o','r','y','_','B','r','e','a',
'k',0,2,'N','L',0,'N','e','x','t','_','L','i','n','e',0,
2,'N','S',0,'N','o','n','s','t','a','r','t','e','r',0,2,'N','U',0,'N','u','m','e','r','i','c',0,
2,'O','P',0,'O','p','e','n','_','P','u','n','c','t','u','a','t','i','o','n',0,
2,'P','O',0,'P','o','s','t','f','i','x','_','N','u','m','e','r','i','c',0,
2,'P','R',0,'P','r','e','f','i','x','_','N','u','m','e','r','i','c',0,
2,'Q','U',0,'Q','u','o','t','a','t','i','o','n',0,2,'S','P',0,'S','p','a','c','e',0,
2,'S','G',0,'S','u','r','r','o','g','a','t','e',0,2,'X','X',0,'U','n','k','n','o','w','n',0,
2,'W','J',0,'W','o','r','d','_','J','o','i','n','e','r',0,
2,'Z','W',0,'Z','W','S','p','a','c','e',0,2,'N','F','C','_','Q','C',0,'N','F','C','_','Q','u','i','c','k','_','C','h',
'e','c','k',0,2,'M',0,'M','a','y','b','e',0,2,'N',0,'N','o',0,
2,'Y',0,'Y','e','s',0,2,'N','F','D','_','Q','C',0,'N','F','D','_','Q','u','i','c','k','_','C','h','e','c','k',0,
2,'N',0,'N','o',0,2,'Y',0,'Y','e','s',0,2,'N','F','K','C','_','Q','C',0,'N','F','K','C','_','Q','u','i','c','k',
'_','C','h','e','c','k',0,2,'M',0,'M','a','y','b','e',0,
2,'N',0,'N','o',0,2,'Y',0,'Y','e','s',0,2,'N','F','K','D','_','Q','C',0,'N','F','K','D','_','Q','u','i','c','k',
'_','C','h','e','c','k',0,2,'N',0,'N','o',0,2,'Y',0,'Y','e','s',0,
2,'n','t',0,'N','u','m','e','r','i','c','_','T','y','p','e',0,
2,'D','e',0,'D','e','c','i','m','a','l',0,2,'D','i',0,'D','i','g','i','t',0,
2,'N','o','n','e',0,'N','o','n','e',0,2,'N','u',0,'N','u','m','e','r','i','c',0,
2,'s','c',0,'S','c','r','i','p','t',0,2,'A','f','a','k',0,'A','f','a','k',0,
2,'A','r','a','b',0,'A','r','a','b','i','c',0,2,'A','r','m','n',0,'A','r','m','e','n','i','a','n',0,
2,'A','v','s','t',0,'A','v','e','s','t','a','n',0,2,'B','a','l','i',0,'B','a','l','i','n','e','s','e',0,
2,'B','a','m','u',0,'B','a','m','u','m',0,2,'B','a','s','s',0,'B','a','s','s',0,
2,'B','a','t','k',0,'B','a','t','a','k',0,2,'B','e','n','g',0,'B','e','n','g','a','l','i',0,
2,'B','l','i','s',0,'B','l','i','s',0,2,'P','h','l','v',0,'P','h','l','v',0,
2,'B','o','p','o',0,'B','o','p','o','m','o','f','o',0,2,'B','r','a','h',0,'B','r','a','h','m','i',0,
2,'B','r','a','i',0,'B','r','a','i','l','l','e',0,2,'B','u','g','i',0,'B','u','g','i','n','e','s','e',0,
2,'B','u','h','d',0,'B','u','h','i','d',0,2,'C','a','n','s',0,'C','a','n','a','d','i','a','n','_','A','b','o','r','i',
'g','i','n','a','l',0,2,'C','a','r','i',0,'C','a','r','i','a','n',0,
2,'C','a','k','m',0,'C','a','k','m',0,2,'C','h','a','m',0,'C','h','a','m',0,
2,'C','h','e','r',0,'C','h','e','r','o','k','e','e',0,2,'C','i','r','t',0,'C','i','r','t',0,
2,'Z','y','y','y',0,'C','o','m','m','o','n',0,3,'C','o','p','t',0,'C','o','p','t','i','c',0,
'Q','a','a','c',0,2,'X','s','u','x',0,'C','u','n','e','i','f','o','r','m',0,
2,'C','p','r','t',0,'C','y','p','r','i','o','t',0,2,'C','y','r','l',0,'C','y','r','i','l','l','i','c',0,
2,'E','g','y','d',0,'E','g','y','d',0,2,'D','s','r','t',0,'D','e','s','e','r','e','t',0,
2,'D','e','v','a',0,'D','e','v','a','n','a','g','a','r','i',0,
2,'D','u','p','l',0,'D','u','p','l',0,2,'S','y','r','n',0,'S','y','r','n',0,
2,'E','g','y','p',0,'E','g','y','p','t','i','a','n','_','H','i','e','r','o','g','l','y','p','h','s',0,
2,'E','l','b','a',0,'E','l','b','a',0,2,'S','y','r','e',0,'S','y','r','e',0,
2,'E','t','h','i',0,'E','t','h','i','o','p','i','c',0,2,'G','e','o','r',0,'G','e','o','r','g','i','a','n',0,
2,'G','l','a','g',0,'G','l','a','g','o','l','i','t','i','c',0,
2,'G','o','t','h',0,'G','o','t','h','i','c',0,2,'G','r','a','n',0,'G','r','a','n',0,
2,'G','r','e','k',0,'G','r','e','e','k',0,2,'G','u','j','r',0,'G','u','j','a','r','a','t','i',0,
2,'G','u','r','u',0,'G','u','r','m','u','k','h','i',0,2,'H','a','n','i',0,'H','a','n',0,
2,'H','a','n','g',0,'H','a','n','g','u','l',0,2,'H','a','n','o',0,'H','a','n','u','n','o','o',0,
2,'I','n','d','s',0,'I','n','d','s',0,2,'H','e','b','r',0,'H','e','b','r','e','w',0,
2,'E','g','y','h',0,'E','g','y','h',0,2,'H','i','r','a',0,'H','i','r','a','g','a','n','a',0,
2,'A','r','m','i',0,'I','m','p','e','r','i','a','l','_','A','r','a','m','a','i','c',0,
3,'Z','i','n','h',0,'I','n','h','e','r','i','t','e','d',0,'Q','a','a','i',0,
2,'P','h','l','i',0,'I','n','s','c','r','i','p','t','i','o','n','a','l','_','P','a','h','l','a','v','i',0,
2,'P','r','t','i',0,'I','n','s','c','r','i','p','t','i','o','n','a','l','_','P','a','r','t','h','i','a','n',0,
2,'J','p','a','n',0,'J','p','a','n',0,2,'J','a','v','a',0,'J','a','v','a','n','e','s','e',0,
2,'J','u','r','c',0,'J','u','r','c',0,2,'K','t','h','i',0,'K','a','i','t','h','i',0,
2,'K','n','d','a',0,'K','a','n','n','a','d','a',0,2,'K','a','n','a',0,'K','a','t','a','k','a','n','a',0,
2,'H','r','k','t',0,'K','a','t','a','k','a','n','a','_','O','r','_','H','i','r','a','g','a','n','a',0,
2,'K','a','l','i',0,'K','a','y','a','h','_','L','i',0,2,'K','h','a','r',0,'K','h','a','r','o','s','h','t','h','i',0,
2,'K','h','m','r',0,'K','h','m','e','r',0,2,'G','e','o','k',0,'G','e','o','k',0,
2,'K','o','r','e',0,'K','o','r','e',0,2,'K','p','e','l',0,'K','p','e','l',0,
2,'L','a','n','a',0,'T','a','i','_','T','h','a','m',0,2,'L','a','o','o',0,'L','a','o',0,
2,'L','a','t','n',0,'L','a','t','i','n',0,2,'L','a','t','f',0,'L','a','t','f',0,
2,'L','a','t','g',0,'L','a','t','g',0,2,'L','e','p','c',0,'L','e','p','c','h','a',0,
2,'L','i','m','b',0,'L','i','m','b','u',0,2,'L','i','n','a',0,'L','i','n','a',0,
2,'L','i','n','b',0,'L','i','n','e','a','r','_','B',0,2,'L','i','s','u',0,'L','i','s','u',0,
2,'L','o','m','a',0,'L','o','m','a',0,2,'L','y','c','i',0,'L','y','c','i','a','n',0,
2,'L','y','d','i',0,'L','y','d','i','a','n',0,2,'M','l','y','m',0,'M','a','l','a','y','a','l','a','m',0,
2,'M','a','n','d',0,'M','a','n','d','a','i','c',0,2,'M','a','n','i',0,'M','a','n','i',0,
2,'Z','m','t','h',0,'Z','m','t','h',0,2,'M','a','y','a',0,'M','a','y','a',0,
2,'M','t','e','i',0,'M','e','e','t','e','i','_','M','a','y','e','k',0,
2,'M','e','n','d',0,'M','e','n','d',0,2,'M','e','r','c',0,'M','e','r','c',0,
2,'M','e','r','o',0,'M','e','r','o',0,2,'M','o','n','g',0,'M','o','n','g','o','l','i','a','n',0,
2,'M','o','o','n',0,'M','o','o','n',0,2,'M','r','o','o',0,'M','r','o','o',0,
2,'M','y','m','r',0,'M','y','a','n','m','a','r',0,2,'N','b','a','t',0,'N','b','a','t',0,
2,'N','k','g','b',0,'N','k','g','b',0,2,'T','a','l','u',0,'N','e','w','_','T','a','i','_','L','u','e',0,
2,'N','k','o','o',0,'N','k','o',0,2,'N','s','h','u',0,'N','s','h','u',0,
2,'O','g','a','m',0,'O','g','h','a','m',0,2,'C','y','r','s',0,'C','y','r','s',0,
2,'H','u','n','g',0,'H','u','n','g',0,2,'I','t','a','l',0,'O','l','d','_','I','t','a','l','i','c',0,
2,'N','a','r','b',0,'N','a','r','b',0,2,'P','e','r','m',0,'P','e','r','m',0,
2,'X','p','e','o',0,'O','l','d','_','P','e','r','s','i','a','n',0,
2,'S','a','r','b',0,'O','l','d','_','S','o','u','t','h','_','A','r','a','b','i','a','n',0,
2,'O','l','c','k',0,'O','l','_','C','h','i','k','i',0,2,'O','r','y','a',0,'O','r','i','y','a',0,
2,'O','r','k','h',0,'O','l','d','_','T','u','r','k','i','c',0,
2,'O','s','m','a',0,'O','s','m','a','n','y','a',0,2,'H','m','n','g',0,'H','m','n','g',0,
2,'P','a','l','m',0,'P','a','l','m',0,2,'P','h','a','g',0,'P','h','a','g','s','_','P','a',0,
2,'P','h','n','x',0,'P','h','o','e','n','i','c','i','a','n',0,
2,'P','l','r','d',0,'P','l','r','d',0,2,'P','h','l','p',0,'P','h','l','p',0,
2,'R','j','n','g',0,'R','e','j','a','n','g',0,2,'R','o','r','o',0,'R','o','r','o',0,
2,'R','u','n','r',0,'R','u','n','i','c',0,2,'S','a','m','r',0,'S','a','m','a','r','i','t','a','n',0,
2,'S','a','r','a',0,'S','a','r','a',0,2,'S','a','u','r',0,'S','a','u','r','a','s','h','t','r','a',0,
2,'S','h','r','d',0,'S','h','r','d',0,2,'S','h','a','w',0,'S','h','a','v','i','a','n',0,
2,'S','g','n','w',0,'S','g','n','w',0,2,'H','a','n','s',0,'H','a','n','s',0,
2,'S','i','n','d',0,'S','i','n','d',0,2,'S','i','n','h',0,'S','i','n','h','a','l','a',0,
2,'S','o','r','a',0,'S','o','r','a',0,2,'S','u','n','d',0,'S','u','n','d','a','n','e','s','e',0,
2,'S','y','l','o',0,'S','y','l','o','t','i','_','N','a','g','r','i',0,
2,'Z','s','y','m',0,'Z','s','y','m',0,2,'S','y','r','c',0,'S','y','r','i','a','c',0,
2,'T','g','l','g',0,'T','a','g','a','l','o','g',0,2,'T','a','g','b',0,'T','a','g','b','a','n','w','a',0,
2,'T','a','l','e',0,'T','a','i','_','L','e',0,2,'T','a','v','t',0,'T','a','i','_','V','i','e','t',0,
2,'T','a','k','r',0,'T','a','k','r',0,2,'T','a','m','l',0,'T','a','m','i','l',0,
2,'T','a','n','g',0,'T','a','n','g',0,2,'T','e','l','u',0,'T','e','l','u','g','u',0,
2,'T','e','n','g',0,'T','e','n','g',0,2,'T','h','a','a',0,'T','h','a','a','n','a',0,
2,'T','h','a','i',0,'T','h','a','i',0,2,'T','i','b','t',0,'T','i','b','e','t','a','n',0,
2,'T','f','n','g',0,'T','i','f','i','n','a','g','h',0,2,'H','a','n','t',0,'H','a','n','t',0,
2,'U','g','a','r',0,'U','g','a','r','i','t','i','c',0,2,'Z','z','z','z',0,'U','n','k','n','o','w','n',0,
2,'Z','x','x','x',0,'Z','x','x','x',0,2,'V','a','i','i',0,'V','a','i',0,
2,'V','i','s','p',0,'V','i','s','p',0,2,'W','a','r','a',0,'W','a','r','a',0,
2,'S','y','r','j',0,'S','y','r','j',0,2,'W','o','l','e',0,'W','o','l','e',0,
2,'Y','i','i','i',0,'Y','i',0,2,'S','B',0,'S','e','n','t','e','n','c','e','_','B','r','e','a','k',0,
2,'A','T',0,'A','T','e','r','m',0,2,'C','L',0,'C','l','o','s','e',0,
2,'C','R',0,'C','R',0,2,'E','X',0,'E','x','t','e','n','d',0,
2,'F','O',0,'F','o','r','m','a','t',0,2,'L','F',0,'L','F',0,
2,'L','O',0,'L','o','w','e','r',0,2,'N','U',0,'N','u','m','e','r','i','c',0,
2,'L','E',0,'O','L','e','t','t','e','r',0,2,'X','X',0,'O','t','h','e','r',0,
2,'S','C',0,'S','C','o','n','t','i','n','u','e',0,2,'S','E',0,'S','e','p',0,
2,'S','P',0,'S','p',0,2,'S','T',0,'S','T','e','r','m',0,
2,'U','P',0,'U','p','p','e','r',0,2,'t','c','c','c',0,'T','r','a','i','l','_','C','a','n','o','n','i','c','a','l','_',
'C','o','m','b','i','n','i','n','g','_','C','l','a','s','s',0,
2,'W','B',0,'W','o','r','d','_','B','r','e','a','k',0,2,'L','E',0,'A','L','e','t','t','e','r',0,
2,'C','R',0,'C','R',0,2,'E','x','t','e','n','d',0,'E','x','t','e','n','d',0,
2,'E','X',0,'E','x','t','e','n','d','N','u','m','L','e','t',0,
2,'F','O',0,'F','o','r','m','a','t',0,2,'K','A',0,'K','a','t','a','k','a','n','a',0,
2,'L','F',0,'L','F',0,2,'M','L',0,'M','i','d','L','e','t','t','e','r',0,
2,'M','N',0,'M','i','d','N','u','m',0,2,'M','B',0,'M','i','d','N','u','m','L','e','t',0,
2,'N','L',0,'N','e','w','l','i','n','e',0,2,'N','U',0,'N','u','m','e','r','i','c',0,
2,'X','X',0,'O','t','h','e','r',0,2,'a','g','e',0,'A','g','e',0,
2,'b','m','g',0,'B','i','d','i','_','M','i','r','r','o','r','i','n','g','_','G','l','y','p','h',0,
2,'c','f',0,'C','a','s','e','_','F','o','l','d','i','n','g',0,
2,'i','s','c',0,'I','S','O','_','C','o','m','m','e','n','t',0,
2,'l','c',0,'L','o','w','e','r','c','a','s','e','_','M','a','p','p','i','n','g',0,
2,'n','a',0,'N','a','m','e',0,3,'s','c','f',0,'S','i','m','p','l','e','_','C','a','s','e','_','F','o','l','d','i','n',
'g',0,'s','f','c',0,2,'s','l','c',0,'S','i','m','p','l','e','_','L','o','w','e','r','c','a','s','e','_','M','a','p','p',
'i','n','g',0,2,'s','t','c',0,'S','i','m','p','l','e','_','T','i','t','l','e','c','a','s','e','_','M','a','p','p','i','n',
'g',0,2,'s','u','c',0,'S','i','m','p','l','e','_','U','p','p','e','r','c','a','s','e','_','M','a','p','p','i','n','g',0,
2,'t','c',0,'T','i','t','l','e','c','a','s','e','_','M','a','p','p','i','n','g',0,
2,'n','a','1',0,'U','n','i','c','o','d','e','_','1','_','N','a','m','e',0,
2,'u','c',0,'U','p','p','e','r','c','a','s','e','_','M','a','p','p','i','n','g',0,
2,'n','v',0,'N','u','m','e','r','i','c','_','V','a','l','u','e',0,
2,'g','c','m',0,'G','e','n','e','r','a','l','_','C','a','t','e','g','o','r','y','_','M','a','s','k',0,
3,'C','c',0,'C','o','n','t','r','o','l',0,'c','n','t','r','l',0,
2,'C','f',0,'F','o','r','m','a','t',0,2,'C','n',0,'U','n','a','s','s','i','g','n','e','d',0,
2,'C','o',0,'P','r','i','v','a','t','e','_','U','s','e',0,
2,'C','s',0,'S','u','r','r','o','g','a','t','e',0,2,'C',0,'O','t','h','e','r',0,
2,'L','C',0,'C','a','s','e','d','_','L','e','t','t','e','r',0,
2,'L','l',0,'L','o','w','e','r','c','a','s','e','_','L','e','t','t','e','r',0,
2,'L','m',0,'M','o','d','i','f','i','e','r','_','L','e','t','t','e','r',0,
2,'L','o',0,'O','t','h','e','r','_','L','e','t','t','e','r',0,
2,'L','t',0,'T','i','t','l','e','c','a','s','e','_','L','e','t','t','e','r',0,
2,'L','u',0,'U','p','p','e','r','c','a','s','e','_','L','e','t','t','e','r',0,
2,'L',0,'L','e','t','t','e','r',0,2,'M','c',0,'S','p','a','c','i','n','g','_','M','a','r','k',0,
2,'M','e',0,'E','n','c','l','o','s','i','n','g','_','M','a','r','k',0,
2,'M','n',0,'N','o','n','s','p','a','c','i','n','g','_','M','a','r','k',0,
2,'M',0,'M','a','r','k',0,3,'N','d',0,'D','e','c','i','m','a','l','_','N','u','m','b','e','r',0,
'd','i','g','i','t',0,2,'N','l',0,'L','e','t','t','e','r','_','N','u','m','b','e','r',0,
2,'N','o',0,'O','t','h','e','r','_','N','u','m','b','e','r',0,
2,'N',0,'N','u','m','b','e','r',0,2,'P','c',0,'C','o','n','n','e','c','t','o','r','_','P','u','n','c','t','u','a','t',
'i','o','n',0,2,'P','d',0,'D','a','s','h','_','P','u','n','c','t','u','a','t','i','o','n',0,
2,'P','e',0,'C','l','o','s','e','_','P','u','n','c','t','u','a','t','i','o','n',0,
2,'P','f',0,'F','i','n','a','l','_','P','u','n','c','t','u','a','t','i','o','n',0,
2,'P','i',0,'I','n','i','t','i','a','l','_','P','u','n','c','t','u','a','t','i','o','n',0,
2,'P','o',0,'O','t','h','e','r','_','P','u','n','c','t','u','a','t','i','o','n',0,
2,'P','s',0,'O','p','e','n','_','P','u','n','c','t','u','a','t','i','o','n',0,
3,'P',0,'P','u','n','c','t','u','a','t','i','o','n',0,'p','u','n','c','t',0,
2,'S','c',0,'C','u','r','r','e','n','c','y','_','S','y','m','b','o','l',0,
2,'S','k',0,'M','o','d','i','f','i','e','r','_','S','y','m','b','o','l',0,
2,'S','m',0,'M','a','t','h','_','S','y','m','b','o','l',0,
2,'S','o',0,'O','t','h','e','r','_','S','y','m','b','o','l',0,
2,'S',0,'S','y','m','b','o','l',0,2,'Z','l',0,'L','i','n','e','_','S','e','p','a','r','a','t','o','r',0,
2,'Z','p',0,'P','a','r','a','g','r','a','p','h','_','S','e','p','a','r','a','t','o','r',0,
2,'Z','s',0,'S','p','a','c','e','_','S','e','p','a','r','a','t','o','r',0,
2,'Z',0,'S','e','p','a','r','a','t','o','r',0,2,'s','c','x',0,'S','c','r','i','p','t','_','E','x','t','e','n','s','i',
'o','n','s',0
};

} }
# 24 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/propname.cpp" 2

extern "C" {






static inline int32_t
getASCIIPropertyNameChar(const char *name) {
    int32_t i;
    char c;


    for(i=0;
        (c=name[i++])==0x2d || c==0x5f ||
        c==0x20 || (0x09<=c && c<=0x0d);
    ) {}

    if(c!=0) {
        return (i<<8)|(uint8_t)uprv_asciitolower_48((char)c);
    } else {
        return i<<8;
    }
}






static inline int32_t
getEBCDICPropertyNameChar(const char *name) {
    int32_t i;
    char c;


    for(i=0;
        (c=name[i++])==0x60 || c==0x6d ||
        c==0x40 || c==0x05 || c==0x15 || c==0x25 || c==0x0b || c==0x0c || c==0x0d;
    ) {}

    if(c!=0) {
        return (i<<8)|(uint8_t)uprv_ebcdictolower_48((char)c);
    } else {
        return i<<8;
    }
}
# 90 "c:/users/will/documents/utterspeech/marmalade/icu/common/source/propname.cpp"
extern "C" int32_t
uprv_compareASCIIPropertyNames_48(const char *name1, const char *name2) {
    int32_t rc, r1, r2;

    for(;;) {
        r1=getASCIIPropertyNameChar(name1);
        r2=getASCIIPropertyNameChar(name2);


        if(((r1|r2)&0xff)==0) {
            return 0;
        }


        if(r1!=r2) {
            rc=(r1&0xff)-(r2&0xff);
            if(rc!=0) {
                return rc;
            }
        }

        name1+=r1>>8;
        name2+=r2>>8;
    }
}

extern "C" int32_t
uprv_compareEBCDICPropertyNames_48(const char *name1, const char *name2) {
    int32_t rc, r1, r2;

    for(;;) {
        r1=getEBCDICPropertyNameChar(name1);
        r2=getEBCDICPropertyNameChar(name2);


        if(((r1|r2)&0xff)==0) {
            return 0;
        }


        if(r1!=r2) {
            rc=(r1&0xff)-(r2&0xff);
            if(rc!=0) {
                return rc;
            }
        }

        name1+=r1>>8;
        name2+=r2>>8;
    }
}

}

extern "C++" { namespace icu_48 {

int32_t PropNameData::findProperty(int32_t property) {
    int32_t i=1;
    for(int32_t numRanges=valueMaps[0]; numRanges>0; --numRanges) {

        int32_t start=valueMaps[i];
        int32_t limit=valueMaps[i+1];
        i+=2;
        if(property<start) {
            break;
        }
        if(property<limit) {
            return i+(property-start)*2;
        }
        i+=(limit-start)*2;
    }
    return 0;
}

int32_t PropNameData::findPropertyValueNameGroup(int32_t valueMapIndex, int32_t value) {
    if(valueMapIndex==0) {
        return 0;
    }
    ++valueMapIndex;
    int32_t numRanges=valueMaps[valueMapIndex++];
    if(numRanges<0x10) {

        for(; numRanges>0; --numRanges) {

            int32_t start=valueMaps[valueMapIndex];
            int32_t limit=valueMaps[valueMapIndex+1];
            valueMapIndex+=2;
            if(value<start) {
                break;
            }
            if(value<limit) {
                return valueMaps[valueMapIndex+value-start];
            }
            valueMapIndex+=limit-start;
        }
    } else {

        int32_t valuesStart=valueMapIndex;
        int32_t nameGroupOffsetsStart=valueMapIndex+numRanges-0x10;
        do {
            int32_t v=valueMaps[valueMapIndex];
            if(value<v) {
                break;
            }
            if(value==v) {
                return valueMaps[nameGroupOffsetsStart+valueMapIndex-valuesStart];
            }
        } while(++valueMapIndex<nameGroupOffsetsStart);
    }
    return 0;
}

const char *PropNameData::getName(const char *nameGroup, int32_t nameIndex) {
    int32_t numNames=*nameGroup++;
    if(nameIndex<0 || numNames<=nameIndex) {
        return __null;
    }

    for(; nameIndex>0; --nameIndex) {
        nameGroup=:: strchr(nameGroup, 0)+1;
    }
    if(*nameGroup==0) {
        return __null;
    }
    return nameGroup;
}

UBool PropNameData::containsName(BytesTrie &trie, const char *name) {
    if(name==__null) {
        return 0;
    }
    UStringTrieResult result=USTRINGTRIE_NO_VALUE;
    char c;
    while((c=*name++)!=0) {
        c=uprv_asciitolower_48(c);

        if(c==0x2d || c==0x5f || c==0x20 || (0x09<=c && c<=0x0d)) {
            continue;
        }
        if(!((result)&1)) {
            return 0;
        }
        result=trie.next((uint8_t)c);
    }
    return ((result)>=USTRINGTRIE_FINAL_VALUE);
}

const char *PropNameData::getPropertyName(int32_t property, int32_t nameChoice) {
    int32_t valueMapIndex=findProperty(property);
    if(valueMapIndex==0) {
        return __null;
    }
    return getName(nameGroups+valueMaps[valueMapIndex], nameChoice);
}

const char *PropNameData::getPropertyValueName(int32_t property, int32_t value, int32_t nameChoice) {
    int32_t valueMapIndex=findProperty(property);
    if(valueMapIndex==0) {
        return __null;
    }
    int32_t nameGroupOffset=findPropertyValueNameGroup(valueMaps[valueMapIndex+1], value);
    if(nameGroupOffset==0) {
        return __null;
    }
    return getName(nameGroups+nameGroupOffset, nameChoice);
}

int32_t PropNameData::getPropertyOrValueEnum(int32_t bytesTrieOffset, const char *alias) {
    BytesTrie trie(bytesTries+bytesTrieOffset);
    if(containsName(trie, alias)) {
        return trie.getValue();
    } else {
        return UCHAR_INVALID_CODE;
    }
}

int32_t PropNameData::getPropertyEnum(const char *alias) {
    return getPropertyOrValueEnum(0, alias);
}

int32_t PropNameData::getPropertyValueEnum(int32_t property, const char *alias) {
    int32_t valueMapIndex=findProperty(property);
    if(valueMapIndex==0) {
        return UCHAR_INVALID_CODE;
    }
    valueMapIndex=valueMaps[valueMapIndex+1];
    if(valueMapIndex==0) {
        return UCHAR_INVALID_CODE;
    }


    return getPropertyOrValueEnum(valueMaps[valueMapIndex], alias);
}
} }




extern "C" const char*
u_getPropertyName_48(UProperty property,
                  UPropertyNameChoice nameChoice) {
    using namespace icu_48;
    return PropNameData::getPropertyName(property, nameChoice);
}

extern "C" UProperty
u_getPropertyEnum_48(const char* alias) {
    using namespace icu_48;
    return (UProperty)PropNameData::getPropertyEnum(alias);
}

extern "C" const char*
u_getPropertyValueName_48(UProperty property,
                       int32_t value,
                       UPropertyNameChoice nameChoice) {
    using namespace icu_48;
    return PropNameData::getPropertyValueName(property, value, nameChoice);
}

extern "C" int32_t
u_getPropertyValueEnum_48(UProperty property,
                       const char* alias) {
    using namespace icu_48;
    return PropNameData::getPropertyValueEnum(property, alias);
}
